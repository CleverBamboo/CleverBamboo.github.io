{"pages":[],"posts":[{"title":"CSS黑魔法","text":"CSS黑魔法，可以理解为。你用它的情况很少，但是在你需要黑魔法来实现一下CSS布局或者效果的时候，你会发现它非常好用。以下，是我在工作中，用到的黑魔法。写下来是方便以后查阅。 撑起图片高度 它的实现效果利用该元素的 position:relative 和 padding-top 的值来设置。但是，得有前提条件设置这个元素的 width: 100%;height: 0。最后,设置 padding-top 的值，就会根据 width:100% 的百分比来计算。比如，如果你 padding-top: 70% 其实就 width 的百分之七十代码如下: 12345678&lt;div class=&quot;bg-img&quot;&gt;&lt;/div&gt;.bg-img position: relative padding-top: 70%; width: 100% height: 0 background-image: url('xxx') backgorund-size: cover 子元素垂直居中简单介绍一下: 这种方法是把父元素变成display: table,就是此元素将以块级表格来显示。子元素变成display: table-cell,此元素会作为一个表格单元格显示。子元素就利用单元格的属性: vertical-align: middle,来进行居中。 1.利用 display:table 1234567891011121314151617&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; 垂直居中 &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent{ display：table; width:500px; height:500px; } .child{ display: table-cell; vertical-align: middle; }&lt;/style&gt; 2.利用display: flex 1234567891011121314&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; 垂直居中 &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent{ display: flex justify-content: center align-items: center } .child {}&lt;/style&gt; 1像素边框1.用height：1px的div，然后根据媒体查询设置transform: scaleY(0.5);， 123456div height:1px background:#000 -webkit-transform: scaleY(0.5) -webkit-transform-origin:0 0 overflow: hidden 2.用::after设置border：1px solid #000; width:200%; height:200%,然后再缩放scaleY(0.5); 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。 12345678910111213.div::after content: '' width: 200% height: 200% position: absolute top: 0 left: 0 border: 1px solid #bfbfbf border-radius: 4px -webkit-transform: scale(0.5,0.5) transform: scale(0.5,0.5) -webkit-transform-origin: top left 3.伪类 + transform 实现 对于老项目，有没有什么办法能兼容1px的尴尬问题了，个人认为伪类+transform是比较完美的方法了。原理是把原先元素的 border 去掉，然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，原先的元素相对定位，新做的 border 绝对定位。 1234567891011121314151617.scale-1px position: relative border:none.scale-1px:after content: '' position: absolute bottom: 0 // top left right 来控制位置 ==&gt; 上边框或者下边框 background: #000 width: 100% height: 1px -webkit-transform: scaleY(0.5) transform: scaleY(0.5) -webkit-transform-origin: 0 0 transform-origin: 0 0 -webkit-transform-origin: 0 0 4.参照sell-app的1像素边框个人觉得最好，因为还做dpr的兼容性 123456789101112131415161718192021222324252627border-1px($color) position: relative &amp;:after display: block position: absolute left: 0 bottom: 0 width: 100% border-top: 1px solid $color content: ' ' /** * 最需要的元素加上 class ==&gt; border-1px */ @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) .border-1px &amp;::after -webkit-transform: scaleY(0.7) transform: scaleY(0.7)@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) .border-1px &amp;::after -webkit-transform: scaleY(0.5) transform: scaleY(0.5) 用CSS伪类写上下左右空心箭头123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css制作空心的上下左右的箭头&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *{ padding:0; margin:0; } .box{ width:100px; height:500px; margin:0 auto; border:1px solid red; background:white; } .arrow-box{ width:30px; height:30px; margin:20px auto; position:relative; } /*右箭头*/ .right{ width:20px; height:20px; position:absolute; left:0; top:0; border:1px solid blue; } .right-arrow1,.right-arrow2{ width:0; height:0; display:block; position:absolute; left:0; top:0; border-top:10px transparent dashed; border-right:10px transparent dashed; border-bottom:10px transparent dashed; border-left:10px white solid; overflow:hidden; } .right-arrow1{ left:1px;/*重要*/ border-left:10px blue solid; } .right-arrow2{ border-left:10px white solid; } /*左箭头*/ .left{ width:20px; height:20px; position:absolute; left:0; top:0; z-index: 2;/*兼容ie8-*/ border:1px solid blue; } .left-arrow1,.left-arrow2{ width:0; height:0; display:block; position:absolute; left:0; top:0; z-index:5;/*兼容ie8-*/ border-top:10px transparent dashed; border-left:10px transparent dashed; border-bottom:10px transparent dashed; border-right:10px white solid; overflow:hidden; } .left-arrow1{ border-right:10px blue solid; } .left-arrow2{ left:1px;/*重要*/ border-right:10px white solid; } /*上箭头*/ .top{ width:20px; height:20px; position:absolute; left:0; top:0; z-index: 2;/*兼容ie8-*/ border:1px solid blue; } .top-arrow1,.top-arrow2{ width:0; height:0; display:block; position:absolute; left:0; top:0; z-index: 5;/*兼容ie8-*/ border-top:10px transparent dashed; border-left:10px transparent dashed; border-right:10px transparent dashed; border-bottom:10px white solid; overflow:hidden; } .top-arrow1{ border-bottom:10px blue solid; } .top-arrow2{ top:1px;/*重要*/ border-bottom:10px white solid; } /*下箭头*/ .bottom{ width:20px; height:20px; position:absolute; left:0; top:0; z-index: 2;/*兼容ie8-*/ border:1px solid blue; } .bottom-arrow1,.bottom-arrow2{ width:0; height:0; display:block; position:absolute; left:0; top:0; z-index: 5;/*兼容ie8-*/ border-bottom:10px transparent dashed; border-left:10px transparent dashed; border-right:10px transparent dashed; border-top:10px white solid; overflow:hidden; } .bottom-arrow1{ top:1px;/*重要*/ border-top:10px blue solid; } .bottom-arrow2{ border-top:10px white solid; } &lt;/style&gt;&lt;body&gt;&lt;div class=&quot;box&quot;&gt; &lt;p&gt; 右箭头&lt;/p&gt; &lt;div class=&quot;arrow-right arrow-box&quot;&gt; &lt;b class=&quot;right&quot;&gt;&lt;i class=&quot;right-arrow1&quot;&gt;&lt;/i&gt;&lt;i class=&quot;right-arrow2&quot;&gt;&lt;/i&gt;&lt;/b&gt; &lt;/div&gt; &lt;p&gt; 左箭头&lt;/p&gt; &lt;div class=&quot;arrow-left arrow-box&quot; &gt; &lt;b class=&quot;left&quot;&gt;&lt;i class=&quot;left-arrow1&quot;&gt;&lt;/i&gt;&lt;i class=&quot;left-arrow2&quot;&gt;&lt;/i&gt;&lt;/b&gt; &lt;/div&gt; &lt;p&gt; 上箭头&lt;/p&gt; &lt;div class=&quot;arrow-top arrow-box&quot; &gt; &lt;b class=&quot;top&quot;&gt;&lt;i class=&quot;top-arrow1&quot;&gt;&lt;/i&gt;&lt;i class=&quot;top-arrow2&quot;&gt;&lt;/i&gt;&lt;/b&gt; &lt;/div&gt; &lt;p&gt; 下箭头&lt;/p&gt; &lt;div class=&quot;arrow-bottom arrow-box&quot; &gt; &lt;b class=&quot;bottom&quot;&gt;&lt;i class=&quot;bottom-arrow1&quot;&gt;&lt;/i&gt;&lt;i class=&quot;bottom-arrow2&quot;&gt;&lt;/i&gt;&lt;/b&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下: CSS写横线,中间可以添加任何元素12345678910111213141516171819&lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;text&quot;&gt;优惠信息&lt;/div&gt; &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;/div&gt;.title display: flex width: 80% margin: 28px auto 24px auto .line flex: 1 position: relative top: -6px border-bottom: 1px solid rgba(255,255,255,0.2) .text padding: 0 12px font-weight: 700 font-size: 14px 效果图如下:","link":"/2017/08/11/CSS/CSS%E9%BB%91%E9%AD%94%E6%B3%95/"},{"title":"常用的CSS通用属性","text":"移动端常用的body,html属性参考vue-music项目 12345body, html line-height: 1 font-family: 'PingFang SC', 'STHeitiSC-Light', 'Helvetica-Light', arial, sans-serif, 'Droid Sans Fallback' user-select: none -webkit-tap-highlight-color: transparent 移动端viewport1&lt;meta name =“viewport” content =“initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no”&gt; Internet Explorer 8 以及更早的版本支持HTML5和响应式。1234&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; // 支持HTML5新特性&lt;script src=&quot;https://oss.maxcdn.com/respond/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; // 支持响应式&lt;![endif]--&gt; 隐藏滚动条1234-webkit-scrollbar width: 0 height: 0 color: transparent","link":"/2018/01/04/CSS/%E5%B8%B8%E7%94%A8%E7%9A%84CSS%E9%80%9A%E7%94%A8%E5%B1%9E%E6%80%A7/"},{"title":"Mobile-Min-Font-Text","text":"See the Pen 移动端最小字体限制测试 by bamboo (@celverbamboo) on CodePen.","link":"/1995/01/21/Example/Mobile-Min-Font-Text/"},{"title":"PC-Min-Font-Text","text":"See the Pen PC端最小字体测试 by bamboo (@celverbamboo) on CodePen.","link":"/1995/01/21/Example/PC-Min-Font-Text/"},{"title":"Go语言Gin部署Docker、Nginx、Supervisor、Redis、Mysql完整详细流程","text":"记一次Go语言完整的上线部署流程，使用到了Docker、Nginx、Supervisor、Redis、MySQL 1、CentOS8 搭建Go环境在写这篇文章的时候，Go 的最新版为 1.16.5。在我们下载安装包时，请浏览Go 官方下载页面,并且检查一下是否有新的版本可用。 在 CentOS 8 上执行以下命令，下载安装 Go： 1wget https://dl.google.com/go/go1.16.5.linux-amd64.tar.gz 一旦压缩包下载完成，通过输入下面命令，验证压缩包的校验码： 1sha256sum go1.16.5.linux-amd64.tar.gz 请确保使用 sha256sum 命令输出的哈希值和下载页面的哈希值是一样的。 1d5446b46ef6f36fdffa852f73dfbbe78c1ddf010b99fa4964944b9ae8b4d6799 go1.16.5.linux-amd64.tar.gz 使用tar命令将压缩包解压缩到 /usr/local 目录： 1sudo tar -C /usr/local -xf go1.13.4.linux-amd64.tar.gz 通过调整 $PATH 环境变量来告诉用户到哪里去找 Go 的可执行程序。 你可以通过添加下面的行到 /etc/profile 文件（系统安装）或者 $HOME/.bash_profile 文件（当前用户安装）。 1export PATH=$PATH:/usr/local/go/bin 保存文件，并且使用 source 命令将新的PATH环境变量加载到当前 的 Shell 会话中。 1source ~/.bash_profile 就这些。此时，Go 已经被安装在你的 CentOS 系统上。 测试是否成功，输入图中命令，效果如下图，则表示成功 2、安装Docker使用官方安装脚本自动安装，安装命令如下： 1curl -fsSL https://get.docker.com | bash -s docker --mirror aliyun 也可以使用国内 daocloud 一键安装命令： 1curl -sSL https://get.daocloud.io/docker | sh 不太建议手动安装Docker 测试是否成功，输入 docker version，输出如下图则表示成功 3、Docker安装 MySQL、Redis3.1 MySql先查看可用的 mysql 版本123456789101112$ docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relati... 2529 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Crea... 161 [OK]centurylink/mysql Image containing mysql. Optimized to be li... 45 [OK]sameersbn/mysql 36 [OK]google/mysql MySQL server for Google Compute Engine 16 [OK]appcontainers/mysql Centos/Debian Based Customizable MySQL Con... 8 [OK]marvambass/mysql MySQL Server based on Ubuntu 14.04 6 [OK]drupaldocker/mysql MySQL for Drupal 2 [OK]azukiapp/mysql Docker image to run MySQL by Azuki - http:... 2 [OK] 通常使用官方提供的版本， PS: OFFICIAL 为 [OK] 表示是官方提供的 拉取 MySQL 镜像1$ docker pull mysql:latest 查看本地镜像使用以下命令来查看是否已安装了 mysql： 1$ docker images 运行容器安装完成后，我们可以使用以下命令来运行 mysql 容器： 1$ docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql 参数说明： -p 3306:3306 ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。 MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。 3.2 Redis其它步骤类似于刚才的MySQL，redis只演示如何设置密码,设置密码只需要加上–requirepass 1docker run -d --name myredis -p 6379:6379 redis --requirepass &quot;mypassword&quot; supervisorSupervisor 是业界流行的一个通用的进程管理程序，它能将一个普通的命令行进程变为后台守护进程，并监控该进程的运行状态，当该进程异常退出时能将其自动重启。 首先使用 yum 来安装 supervisor： 如果你还没有安装过 EPEL，可以通过运行下面的命令来完成安装，如果已安装则跳过此步骤： 1sudo yum install epel-release 安装 supervisor 1sudo yum install supervisor Supervisor 的配置文件为：**/etc/supervisord.conf** ，Supervisor 所管理的应用的配置文件放在 /etc/supervisord.d/ 目录中，这个目录可以在 supervisord.conf 中的include配置。 12[include]files = /etc/supervisord.d/*.conf 启动服务 12345# 设置开机启动$ systemctl enable supervisor.service# 启动服务$ systemctl start supervisor.service 我们在 /etc/supervisord.d 目录下创建一个名为 bluebell.conf 的配置文件，具体内容如下。PS: 注意 bluebell 是 执行 go build后的二进制文件 123456789[program:bluebell] ;程序名称user=root ;执行程序的用户command=/data/app/bluebell/bin/bluebell /data/app/bluebell/conf/config.yaml ;执行的命令directory=/data/app/bluebell/ ;命令执行的目录stopsignal=TERM ;重启时发送的信号autostart=true autorestart=true ;是否自动重启stdout_logfile=/var/log/bluebell-stdout.log ;标准输出日志位置stderr_logfile=/var/log/bluebell-stderr.log ;标准错误日志位置 创建好配置文件之后，重启supervisor服务 1sudo supervisorctl update # 更新配置文件并重启相关的程序 查看bluebell的运行状态： 1sudo supervisorctl status bluebell 输出： 1bluebell RUNNING pid 10918, uptime 0:05:46 最后补充一下常用的 supervisor 管理命令： 12345supervisorctl status # 查看所有任务状态supervisorctl shutdown # 关闭所有任务supervisorctl start 程序名 # 启动任务supervisorctl stop 程序名 # 关闭任务supervisorctl reload # 重启supervisor Nginx在需要静态文件分离、需要配置多个域名及证书、需要自建负载均衡层等稍复杂的场景下，我们一般需要搭配第三方的web服务器（Nginx、Apache）来部署我们的程序。 正向代理与反向代理正向代理可以简单理解为客户端的代理，你访问墙外的网站用的那个属于正向代理。 反向代理可以简单理解为服务器的代理，通常说的 Nginx 和 Apache 就属于反向代理。 Nginx 是一个免费的、开源的、高性能的 HTTP 和反向代理服务，主要负责负载一些访问量比较大的站点。Nginx 可以作为一个独立的 Web 服务，也可以用来给 Apache 或是其他的 Web 服务做反向代理。相比于 Apache，Nginx 可以处理更多的并发连接，而且每个连接的内存占用的非常小。 使用yum安装nginxEPEL 仓库中有 Nginx 的安装包。如果你还没有安装过 EPEL，可以通过运行下面的命令来完成安装： 1sudo yum install epel-release 安装nginx 1sudo yum install nginx 安装完成后，执行下面的命令设置Nginx开机启动： 1sudo systemctl enable nginx 启动Nginx 1sudo systemctl start nginx 查看Nginx运行状态： 1sudo systemctl status nginx Nginx配置文件通过上面的方法安装的 nginx，所有相关的配置文件都在 /etc/nginx/ 目录中。Nginx 的主配置文件是 /etc/nginx/nginx.conf。 默认还有一个 nginx.conf.default 的配置文件示例，可以作为参考。你可以为多个服务创建不同的配置文件（建议为每个服务（域名）创建一个单独的配置文件），每一个独立的 Nginx 服务配置文件都必须以 .conf结尾，并存储在 /etc/nginx/conf.d 目录中。 补充几个 Nginx 常用命令。 1234nginx -s stop # 停止 Nginx 服务nginx -s reload # 重新加载配置文件nginx -s quit # 平滑停止 Nginx 服务nginx -t # 测试配置文件是否正确 Nginx反向代理部署我们推荐使用 nginx 作为反向代理来部署我们的程序，按下面的内容修改 nginx 的配置文件。 1234567891011121314151617181920212223242526272829worker_processes 1;events {worker_connections 1024;}http {include mime.types;default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; access_log /var/log/bluebell-access.log; error_log /var/log/bluebell-error.log; location / { proxy_pass http://127.0.0.1:8084; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } }} 执行下面的命令检查配置文件语法： 1nginx -t 执行下面的命令重新加载配置文件： 1nginx -s reload 当然我们还可以使用 nginx 的 upstream 配置来添加多个服务器地址实现负载均衡。 123456789101112131415161718192021222324252627282930313233343536worker_processes 1;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; upstream backend { server 127.0.0.1:8084; # 这里需要填真实可用的地址，默认轮询 #server backend1.example.com; #server backend2.example.com; } server { listen 80; server_name localhost; access_log /var/log/bluebell-access.log; error_log /var/log/bluebell-error.log; location / { proxy_pass http://backend/; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } }} Nginx分离静态文件请求上面的配置是简单的使用 nginx 作为反向代理处理所有的请求并转发给我们的 Go 程序处理，其实我们还可以有选择的将静态文件部分的请求直接使用 nginx 处理，而将 API 接口类的动态处理请求转发给后端的 Go 程序来处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647下面继续修改我们的 nginx 的配置文件来实现上述功能。worker_processes 1;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name bluebell; access_log /var/log/bluebell-access.log; error_log /var/log/bluebell-error.log; # 静态文件请求 location ~ .*\\.(gif|jpg|jpeg|png|js|css|eot|ttf|woff|svg|otf)$ { access_log off; expires 1d; root /data/app/bluebell; } # index.html页面请求 # 因为是单页面应用这里使用 try_files 处理一下，避免刷新页面时出现404的问题 location / { root /data/app/bluebell/templates; index index.html; try_files $uri $uri/ /index.html; } # API请求 location /api { proxy_pass http://127.0.0.1:8084; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } }} 前后端分开部署前后端的代码没必要都部署到相同的服务器上，也可以分开部署到不同的服务器上，下图是前端服务将 API 请求转发至后端服务的方案。 上面的部署方案中，所有浏览器的请求都是直接访问前端服务，而如果是浏览器直接访问后端API服务的部署模式下，如下图。 此时前端和后端通常不在同一个域下，我们还需要在后端代码中添加跨域支持。 这里使用 github.com/gin-contrib/cors 库来支持跨域请求。 最简单的允许跨域的配置是使用cors.Default()，它默认允许所有跨域请求。 123456789func main() { router := gin.Default() // same as // config := cors.DefaultConfig() // config.AllowAllOrigins = true // router.Use(cors.New(config)) router.Use(cors.Default()) router.Run()} 此外，还可以使用 cors.Config 自定义具体的跨域请求相关配置项： 1234567891011121314151617181920212223242526272829package mainimport ( &quot;time&quot; &quot;github.com/gin-contrib/cors&quot; &quot;github.com/gin-gonic/gin&quot;)func main() { router := gin.Default() // CORS for https://foo.com and https://github.com origins, allowing: // - PUT and PATCH methods // - Origin header // - Credentials share // - Preflight requests cached for 12 hours router.Use(cors.New(cors.Config{ AllowOrigins: []string{&quot;https://foo.com&quot;}, AllowMethods: []string{&quot;PUT&quot;, &quot;PATCH&quot;}, AllowHeaders: []string{&quot;Origin&quot;}, ExposeHeaders: []string{&quot;Content-Length&quot;}, AllowCredentials: true, AllowOriginFunc: func(origin string) bool { return origin == &quot;https://github.com&quot; }, MaxAge: 12 * time.Hour, })) router.Run()}","link":"/2021/07/08/GO/Go%E8%AF%AD%E8%A8%80Gin%E9%83%A8%E7%BD%B2Docker%E3%80%81Nginx%E3%80%81Supervisor%E3%80%81Redis%E3%80%81Mysql%E5%AE%8C%E6%95%B4%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B/"},{"title":"Go语言工程结构详述","text":"Go语言是一门推崇软件工程理念的编程语言，它为开发周期的每个环节都提供了完备的工具和支持。Go语言高度强调代码和项目的规范和统一，这集中体现在工程结构或者说代码体制的细节之处。Go 也是一门开放的语言，它本身就是开源软件。 更重要的是，Go语言让开发人员很容易通过 go get 命令从各种公共代码库（比如 GitHub）中下载开源代码并使用。这除了得益于Go语言自带命令的强大之外，还应该归功于 Go 工程结构的严谨和完善。本节中，我们详述Go语言的工程结构。 工作区一般情况下，Go语言的源码文件必须放在工作区中。但是对于命令源码文件来说，这不是必需的。工作区其实就是一个对应于特定工程的目录，它应包含 3 个子目录：src 目录、pkg 目录和 bin 目录，下面逐一说明。 src 目录用于以代码包的形式组织并保存 Go 源码文件，这里的代码包与 src 下的子目录一一对应。例如，若一个源码文件被声明属于代码包 log，那么它就应当保存在 src/log 目录中。 当然，也可以把 Go 源码文件直接放在 src 目录下，但这样的 Go 源码文件就只能被声明属于 main 代码包了。除非用于临时测试或演示，一般还是建议把 Go 源码文件放入特定的代码包中。 pkg 目录用于存放通过 go install 命令安装后的代码包的归档文件。前提是代码包中必须包含 Go 库源码文件。归档文件是指那些名称以“.a”结尾的文件。该目录与 GOROOT 目录下的 pkg 目录功能类似。区别在于，工作区中的 pkg 目录专门用来存放用户代码的归档文件。 编译和安装用户代码的过程一般会以代码包为单位进行。比如 log 包被编译安装后，将生成一个名为 log.a 的归档文件，并存放在当前工作区的 pkg 目录下的平台相关目录中。 bin 目录与 pkg 目录类似，在通过 go install 命令完成安装后，保存由 Go 命令源码文件生成的可执行文件。在类 Unix 操作系统下，这个可执行文件一般来说名称与源码文件的主文件名相同。而在 Windows 操作系统下，这个可执行文件的名称则是源码文件主文件名加 .exe 后缀 注意：这里有必要明确一下Go语言的命令源码文件和库源码文件的区别。所谓命令源码文件，就是声明属于 main 代码包并且包含无参数声明和结果声明的 main 函数的源码文件。这类源码文件是程序的入口，它们可以独立运行（使用 go run 命令），也可以通过 go build 或 go install 命令得到相应的可执行文件。所谓库源码文件，则是指存在于某个代码包中的普通源码文件 GOPATH我们需要将工作区的目录路径添加到环境变量 GOPATH 中。否则，即使处于同一工作区，代码之间也无法通过绝对代码包路径调用。在实际开发环境中，工作区可以只有一个，也可以有多个，这些工作区的目录路径都需要添加到 GOPATH 中。与 GOROOT 一样，我们应该确保 GOPATH 一直有效。 需要注意一下两点： GOPATH 中不要包含Go语言的根目录，以便将Go语言本身的工作区同用户工作区严格分开。 通过 Go 工具中的代码获取命令 go get，可将指定项目的源码下载到我们在 GOPATH 中设定的第一个工作区中，并在其中完成编译和安装。 源码文件Go 的源码文件有 3 个种类，即命令源码文件、库源码文件和测试源码文件，下面详细说明这 3 类源码文件。 1) 命令源码文件如果一个源码文件被声明属于 main 代码包，且该文件代码中包含无参数声明和结果声明的 main 函数，则它就是命令源码文件。命令源码文件可通过 go run 命令直接启动运行。 同一个代码包中的所有源码文件，其所属代码包的名称必须一致。如果命令源码文件和库源码文件处于同一个代码包中，那么在该包中就无法正确执行 go build 和 go install 命令。换句话说，这些源码文件将无法通过常规方法编译和安装。 因此，命令源码文件通常会单独放在一个代码包中。这是合理且必要的，因为通常一个程序模块或软件的启动入口只有一个。 同一个代码包中可以有多个命令源码文件，可通过 go run 命令分别运行，但这会使 go build 和 go install 命令无法编译和安装该代码包。所以，我们也不应该把多个命令源码文件放在同一个代码包中。 12345678hc@ubt:~/golang/example.v2/src/gopcp.v2/helper/ds$ Isshowds.gohc@ubt:~/golang/example.v2/src/gopcp.v2/helper/ds$ go buildhc@ubt:~/golang/example.v2/src/gopcp.v2/helper/ds$ Isds showds.gohc@ubt: ~/golang/example.v2/src/gopcp.v2/helper/ds$ go installhc@ubt:~/golang/example.v2/src/gopcp・v2/helper/ds$ Is ../../../../binds 需要特别注意，只有当环境变量 GOPATH 中只包含一个工作区的目录路径时，go install 命令才会把命令源码文件安装到当前工作区的 bin 目录下；否则，像这样执行 go install 命令就会失败。此时必须设置环境变量 GOBIN，该环境变量的值是一个目录的路径，该目录用于存放所有因安装 Go 命令源码文件而生成的可执行文件。 2) 库源码文件通常，库源码文件声明的包名会与它直接所属的代码包（目录）名一致，且库源码文件中不包含无参数声明和无结果声明的 main 函数。下面来安装（其中包含编译）gopcp.v2/helper/log 包，其中含有若干库源码文件： 123456789hc@ubt:~/golang/example.v2/src/gopcp.v2/helper/log$ lsbase logger.go logger_test.go logrushc@ubt: ~/golang/example.v2/src/gopcp.v2/helper/log$ go installhc@ubt:~/golang/example.v2/src/gopcp.v2/helper/log$ ls ../../../pkglinux_amd64hc@ubt:~/golang/example.v2/src/gopcp.v2/helper/log$ ls ../../../pkg/linux_amd64/gopcp.v2/helperlog log.ahc@ubt:~/golang/example.v2/src/gopcp.v2/helper/log$ ls ../../../../pkg/linux_amd64/gopcp.v2/helper/logbase.a field.a logrus.a 这里，我们通过在 gopcp.v2/helper/log 代码包的目录下执行 go install 命令，成功安装了该包并生成了若干归档文件。这些归档文件的存放目录由以下规则产生。 安装库源码文件时所生成的归档文件会被存放到当前工作区的 pkg 目录中。example.v2 项目的 gopcp.v2/helper/log 包所属工作区的根目录是 ~/golang/example.v2。因此，上面所说的 pkg 目录即 ~/golang/example.v2/pkg。 根据被编译时的目标计算环境，归档文件会被放在该 pkg 目录下的平台相关目录中。例如，我是在 64 位的 Linux 计算环境下安装的，对应的平台相关目录就是 linux_amd64，那么归档文件一定会被存放到 ~/golang/example.v2/pkg/linux_amd64 目录中的某个地方。 存放归档文件的目录的相对路径与被安装的代码包的上一级代码包的相对路径一致。第一个相对路径是相对于工作区的 pkg 目录下的平台相关目录而言的，而第二个相对路径是相对于工作区的 src 目录而言的。如果被安装的代码包没有上一级代码包（也就是说，它的父目录就是工作区的 src 目录），那么它的归档文件就会被直接存放到当前工作区的 pkg 目录的平台相关目录下。 例如，gopcp.v2/helper/log 包的归档文件 log.a 一定会被存放到 ~/golang/example.v2/pkg/linux_amd64/gopcp.v2/helper 这个目录下。而它的子代码包 gopcp.v2/helper/log/base 的归档文件 base.a，则一定会被存放到 ~/golang/example.v2/pkg/linux_amd64/gopcp.v2/helper/log 目录下。 3) 测试源码文件测试源码文件是一种特殊的库文件，可以通过执行 go test 命令运行当前代码包下的所有测试源码文件。成为测试源码文件的充分条件有两个，如下。 文件名需要以”_test.go”结尾。 文件中需要至少包含一个名称以 Test 开头或 Benchmark 开头，且拥有一个类型为 *testing.T 或 *testing.B 的参数的函数。testing.T 和 testing.B 是两个结构体类型。而 *testing.T 和 *testing.B 则分别为前两者的指针类型。它们分别是功能测试和基准测试所需的。 当在一个代码包中执行 go test 命令时，该代码包中的所有测试源码文件会被找到并运行。我们依然以 gopcp.v2/helper/log 包为例： 123hc@ubt:~/golang/example.v2/src/gopcp.v2/helper/log$ go testPASSok gopcp.v2/helper/log 0.008s 这里使用 go test 命令在 gopcp.v2/helper/log 包中找到并运行了测试源码文件 logger_test.go，且调用其中所有的测试函数。命令行的回显信息表示我们通过了测试，并且运行测试源码文件中的测试程序共花费了 0.080 S。 最后插一句，Go 代码的文本文件需要以 UTF-8 编码存储。如果源码文件中出现了非 UTF-8 编码的字符，那么在运行、编译或安装的时候，Go 命令会抛出 illegal UTF-8 sequence 错误。","link":"/2019/11/01/GO/Go%E8%AF%AD%E8%A8%80%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84%E8%AF%A6%E8%BF%B0/"},{"title":"Go语言的环境变量和注意事项","text":"GOROOT环境变量 GOROOT 表示Go语言的安装目录。在Windows中，GOROOT 的默认值是C:/go，而在 Mac OS或Linux中GOROOT的默认值是usr/loca/go，如果将Go安装在其他目录中，而需要将 GOROOT 的值修改为对应的目录。 另外，GOROOT/bin则包含Go为我们提供的工具链，因此，应该将GOROOT/bin配置到环境变量PATH中，方便我们在全局中使用Go工具链。 12export GOROOT=~/go // GO的安装目录export PATH=$PATH:$GOROOT/bin GOPATH 注意，GOPATH的值不能与GOROOT相同 环境变量GOPATH用于指定我们的开发工作区(workspace),是存放源代码、测试文件、库静态文件、可执行文件的工作。 在类Unix(Mac OS或Linux)操作系统中GOPATH的默认值是$home/go。而在Windows中GOPATH的默认值则为%USERPROFILE%\\go(比如在Admin用户，其值为C:\\Users\\Admin\\go)。 当然，我们可以通过修改GOPATH来更换工作区，比如将工作设置opt/go方式如下： 1export GOPATH=/opt/go // 自定义的目录 还有，可以在GOPATH中设置多个工作区，如： 1export GOPATH=/opt/go;$home/go GOPATH的子目录上面的代码表示我们指定两个工作区，不过当我们使用go get命令去获取远程库的时候，一般会安装到第一个工作区当中。 按照Go开发规范，GOPATH目录下的每个工作一般分为三个子目录:src,pkg,bin，所以我们看到的每个工作区是这样子的： 12345678910111213141516171819bin/ hello # 可执行文件 outyet # 可执行文件src/ github.com/golang/example/ .git/ hello/ hello.go # 命令行代码 outyet/ main.go # 命令行代码 main_test.go # 测试代码 stringutil/ reverse.go # 库文件 reverse_test.go # 库文件 golang.org/x/image/ .git/ bmp/ reader.go # 库文件 writer.go # 库文件 src 目录放的是我们开发的源代码文件，其下面对应的目录称为包,pkg 放的是编译后的库静态文件，bin 放的是源代码编译后台的可执行文件。 GOBIN环境变量GOBIN表示我们开发程序编译后二进制命令的安装目录。 当我们使用go install命令编译和打包应用程序时，该命令会将编译后二进制程序打包GOBIN目录，一般我们将GOBIN设置为GOPATH/bin目录。 1export GOBIN=$GOPATH/bin 复制代码上面的代码中，我们都是使用export命令设置环境变量的，这样设置只能在当前shell中有效，如果想一直有效，如在Linux中，则应该将环境变量添加到/etc/profile等文件当中。 交叉编译什么是交叉编译？所谓的交叉编译，是指在一个平台上就能生成可以在另一个平台运行的代码，例如，我们可以32位的Windows操作系统开发环境上，生成可以在64位Linux操作系统上运行的二进制程序。 在其他编程语言中进行交叉编译可能要借助第三方工具，但在Go语言进行交叉编译非常简单，最简单只需要设置GOOS和GOARCH这两个环境变量就可以了。 GOOS与GOARCHGOOS的默认值是我们当前的操作系统， 如果windows，linux,注意mac os操作的上的值是darwin。 GOARCH则表示CPU架构，如386，amd64,arm等。 获取GOOS和GOARCH的值 我们可以使用go env命令获取当前GOOS和GOARCH的值。 1go env GOOS GOARCH GOOS和GOARCH的取值范围GOOS和GOARCH的值成对出现，而且只能是下面列表对应的值。 1234567891011121314151617181920212223242526272829303132$GOOS $GOARCHandroid armdarwin 386darwin amd64darwin armdarwin arm64dragonfly amd64freebsd 386freebsd amd64freebsd armlinux 386linux amd64linux armlinux arm64linux ppc64linux ppc64lelinux mipslinux mipslelinux mips64linux mips64lelinux s390xnetbsd 386netbsd amd64netbsd armopenbsd 386openbsd amd64openbsd armplan9 386plan9 amd64solaris amd64windows 386windows amd64 示例编译在64位Linux操作系统上运行的目标程序 1$ GOOS=linux GOARCH=amd64 go build main.go 复制代码编译arm架构Android操作上的目标程序 1$ GOOS=android GOARCH=arm GOARM=7 go build main.go 相关链接: Golang环境变量设置详解","link":"/2019/11/05/GO/Go%E8%AF%AD%E8%A8%80%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"},{"title":"Go语言：并发基础：Goroutines 和 Channels 的声明与使用","text":"2007年，Google设计Go，目的在于提高在多核、网络机器（networked machines）、大型代码库（codebases）的情况下的开发效率。当时在Google，设计师们想要解决其他语言使用中的缺点，但是仍保留他们的优点。 静态类型和运行时效率。（如：C++） 可读性和易用性。（如：Python 和 JavaScript） 高性能的网络和多进程。 什么是并发并发，在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行。 上面那句话可能会有点抽象，看图 进程和线程进程（process）和线程（thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。 最近，我读到一篇材料，发现有一个很好的类比，可以把它们解释地清晰易懂。 进程1、计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。 2、假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。 3、进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。 4、一个车间里，可以有很多工人。他们协同完成一个任务。 5、线程就好比车间里的工人。一个进程可以包括多个线程。 6、车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。 7、可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。 8、一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。 9、还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。 10、这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做”信号量”（Semaphore），用来保证多个线程不会互相冲突。 不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。 11、操作系统的设计，因此可以归结为三点： （1）以多进程形式，允许多个任务同时运行； （2）以多线程形式，允许单个任务分成不同的部分运行； （3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。 协程(Goroutine)Go 语言中没有线程的概念，只有协程，也称为 goroutine。相比线程来说，协程更加轻量，一个程序可以随意启动成千上万个 goroutine。 goroutine 被 Go runtime 所调度，这一点和线程不一样。也就是说，Go 语言的并发是由 Go 自己所调度的，自己决定同时执行多少个 goroutine，什么时候执行哪几个。这些对于我们开发者来说完全透明，只需要在编码的时候告诉 Go 语言要启动几个 goroutine，至于如何调度执行，我们不用关心。 要启动一个 goroutine 非常简单，Go 语言为我们提供了 go 关键字，相比其他编程语言简化了很多，如下面的代码所示： 12345func main() { go fmt.Println(&quot;聪明的竹子&quot;) fmt.Println(&quot;我是 main goroutine&quot;) time.Sleep(time.Second)} 这样就启动了一个 goroutine，用来调用 fmt.Println 函数，打印“聪明的竹子”。所以这段代码里有两个 goroutine，一个是 main 函数启动的 main goroutine，一个是我自己通过 go 关键字启动的 goroutine。 从示例中可以总结出 go 关键字的语法，如下所示： 1go function() go 关键字后跟一个方法或者函数的调用，就可以启动一个 goroutine，让方法在这个新启动的 goroutine 中运行。运行以上示例，可以看到如下输出： 12我是 main goroutine聪明的竹子 从输出结果也可以看出，程序是并发的，go 关键字启动的 goroutine 并不阻塞 main goroutine 的执行，所以我们才会看到如上打印结果。 小提示：示例中的 time.Sleep(time.Second) 表示等待一秒，这里是让 main goroutine 等一秒，不然 main goroutine 执行完毕程序就退出了，也就看不到启动的新 goroutine 中“飞雪无情”的打印结果了。 Channel那么如果启动了多个 goroutine，它们之间该如何通信呢？这就是 Go 语言提供的 channel（通道）要解决的问题。 声明一个 channel在 Go 语言中，声明一个 channel 非常简单，使用内置的 make 函数即可，如下所示： 1ch:=make(chan string) 其中 chan 是一个关键字，表示是 channel 类型。后面的 string 表示 channel 里的数据是 string 类型。通过 channel 的声明也可以看到，chan 是一个集合类型。 定义好 chan 后就可以使用了，一个 chan 的操作只有两种：发送和接收。 接收：获取 chan 中的值，操作符为 &lt;- chan。 发送：向 chan 发送值，把值放在 chan 中，操作符为 chan &lt;-。 小技巧：这里注意发送和接收的操作符，都是 &lt;- ，只不过位置不同。接收的 &lt;- 操作符在 chan 的左侧，发送的 &lt;- 操作符在 chan 的右侧。 现在我把上个示例改造下，使用 chan 来代替 time.Sleep 函数的等待工作，如下面的代码所示： 12345678910111213func main() { ch:=make(chan string) go func() { fmt.Println(&quot;飞雪无情&quot;) ch &lt;- &quot;goroutine 完成&quot; }() fmt.Println(&quot;我是 main goroutine&quot;) v:=&lt;-ch fmt.Println(&quot;接收到的chan中的值为：&quot;,v)} 运行这个示例，可以发现程序并没有退出，可以看到”聪明的竹子”的输出结果，达到了 time.Sleep 函数的效果，如下所示： 123我是 main goroutine聪明的竹子接收到的chan中的值为： goroutine 完成 可以这样理解：在上面的示例中，我们在新启动的 goroutine 中向 chan 类型的变量 ch 发送值；在 main goroutine 中，从变量 ch 接收值；如果 ch 中没有值，则阻塞等待到 ch 中有值可以接收为止。 相信你应该明白为什么程序不会在新的 goroutine 完成之前退出了，因为通过 make 创建的 chan 中没有值，而 main goroutine 又想从 chan 中获取值，获取不到就一直等待，等到另一个 goroutine 向 chan 发送值为止。 channel 有点像在两个 goroutine 之间架设的管道，一个 goroutine 可以往这个管道里发送数据，另外一个可以从这个管道里取数据，有点类似于我们说的队列。","link":"/2021/04/27/GO/Go%E8%AF%AD%E8%A8%80%EF%BC%9A%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%EF%BC%9AGoroutines-%E5%92%8C-Channels-%E7%9A%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"title":"Mac GO 环境配置","text":"环境变量Go语言也需要类似于，JAVA那样需要安装一个类似JDK的东西，然后配置环境变量。因为在国内需要稳定的翻墙工具，所以建议与Go语言中文网下载。地址: https://studygolang.com/dl, 如下图，点击对应的系统下载，然后安装软件，下一步下一步即可。这里以Mac为例 检查是否安装成功Mac安装完之后，会默认存储到这个目录 /usr/local/go 输入 go version,输入如下信息，即代表安装成功 环境变量配置在终端输入 vim ~/.bash_profile, 分别写入一下信息，保存并退出后，输入source ~/.bash_profile，使得可以生效 注意:GOPATH，官网建议酱紫做，方便管理。指定的目录是自己指定的GOROOT 则是对应安装go的目录 GoLand配置 go fmt、goimports、golangci-lint确保 File Watcherr 安装并是启动状态 因为 go get 获取第三方包需要，进行翻墙。最好的解决方案就是，买一个稳定的翻墙工具，不然会使用gopm也需要翻墙下载，也许才能下载成功。这个三个插件的作用: go fmt格式化代码 goimports 优化自动import golangci-lint 类似eslint可以运行命令检查代码 注意如果打开终端没有生效，就把上面添加go环境变量的语句追加到~/.zshrc中","link":"/2019/09/11/GO/Mac-GO-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"title":"微服务实战Go Micro v3 系列（一）- 基础篇","text":"最近完成了公司租房微服务项目，由于使用 go-micro v3遇到了不少的问题，在这里利用一个实战项目帮助大家融会贯通的使用 go-micro v3 另外，由于 Micro3.0直接放弃维护 go-micro，所以网上很多文章都是已经过时的了。 源码地址 源码地址 爱租房微服务综合项目 Go Micro 简介与设计理念Go Micro 是一个基于 Go 语言编写的、用于构建微服务的基础框架，提供了分布式开发所需的核心组件，包括 RPC 和事件驱动通信等。 它的设计哲学是「可插拔」的插件化架构，其核心专注于提供底层的接口定义和基础工具，这些底层接口可以兼容各种实现。例如 Go Micro 默认通过 consul 进行服务发现，通过 HTTP 协议进行通信，通过 protobuf 和 json 进行编解码，以便你可以基于这些开箱提供的组件快速启动，但是如果需要的话，你也可以通过符合底层接口定义的其他组件替换默认组件，比如通过 etcd 或 zookeeper 进行服务发现，这也是插件化架构的优势所在：不需要修改任何底层代码即可实现上层组件的替换。 Go Micro 基础架构介绍Go Micro 框架的基础架构如下，由 8 个核心接口组成，每个接口都有默认实现： 它的设计哲学是「可插拔」的插件化架构，其核心专注于提供底层的接口定义和基础工具，这些底层接口可以兼容各种实现。例如 Go Micro 默认通过 consul 进行服务发现，通过 HTTP 协议进行通信，通过 protobuf 和 json 进行编解码，以便你可以基于这些开箱提供的组件快速启动，但是如果需要的话，你也可以通过符合底层接口定义的其他组件替换默认组件，比如通过 etcd 或 zookeeper 进行服务发现，这也是插件化架构的优势所在：不需要修改任何底层代码即可实现上层组件的替换。 最顶层的 Service 接口是构建服务的主要组件，它把底层的各个包需要实现的接口，做了一次封装，包含了一系列用于初始化 Service 和 Client 的方法，使我们可以很简单的创建一个 RPC 服务； Client 是请求服务的接口，从 Registry 中获取 Server 信息，然后封装了 Transport 和 Codec 进行 RPC 调用，也封装了 Brocker 进行消息发布，默认通过 RPC 协议进行通信，也可以基于 HTTP 或 gRPC； Server 是监听服务调用的接口，也将以接收 Broker 推送过来的消息，需要向 Registry 注册自己的存在与否，以便客户端发起请求，和 Client 一样，默认基于 RPC 协议通信，也可以替换为 HTTP 或 gRPC； Broker 是消息发布和订阅的接口，默认实现是基于 HTTP，在生产环境可以替换为 Kafka、RabbitMQ 等其他组件实现； Codec 用于解决传输过程中的编码和解码，默认实现是 protobuf，也可以替换成 json、mercury 等； Registry 用于实现服务的注册和发现，当有新的 Service 发布时，需要向 Registry 注册，然后 Registry 通知客户端进行更新，Go Micro 默认基于 consul 实现服务注册与发现，当然，也可以替换成 etcd、zookeeper、kubernetes 等； Selector 是客户端级别的负载均衡，当有客户端向服务端发送请求时，Selector 根据不同的算法从 Registery 的主机列表中得到可用的 Service 节点进行通信。目前的实现有循环算法和随机算法，默认使用随机算法，另外，Selector 还有缓存机制，默认是本地缓存，还支持 label、blacklist 等方式； Transport 是服务之间通信的接口，也就是服务发送和接收的最终实现方式，默认使用 HTTP 同步通信，也可以支持 TCP、UDP、NATS、gRPC 等其他方式。 Go Micro 官方创建了一个 Plugins 仓库，用于维护 Go Micro 核心接口支持的可替换插件： 各个组件接口之间的关系可以通过下图串联： 小结通过上述介绍，可以看到，Go Micro 简单轻巧、易于上手、功能强大、扩展方便，是基于 Go 语言进行微服务架构时非常值得推荐的一个 RPC 框架，基于其核心功能及插件，我们可以轻松解决之前讨论的微服务架构引入的需要解决的问题： 服务接口定义：通过 Transport、Codec 定义通信协议及数据编码； 服务发布与调用：通过 Registry 实现服务注册与订阅，还可以基于 Selector 提高系统可用性； 服务监控、服务治理、故障定位：通过 Plugins Wrapper 中间件来实现。 接下来，我们将基于 Go Micro 微服务框架演示如何基于 Go 落地微服务架构。 参考链接 Micro 不能用了？关于 Go 语言微服务框架 Micro 的一些情况说明 go-micro 到底是个啥？","link":"/2021/04/27/GO/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98Go-Micro-v3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E7%AF%87/"},{"title":"微服务实战Go Micro v3 系列（三）-启动HTTP服务","text":"这篇就是使用 go-micro 的 http 创建一个可以调用接口的微服务HTTP 源码地址 源码地址 爱租房微服务综合项目 httpServer这里我们使用 gin 框架结合 go-micro 来进行编写 首先 创建一个 http 目录，并在该目录下创建 main.go，写入下面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( httpServer &quot;github.com/asim/go-micro/plugins/server/http/v3&quot; &quot;github.com/asim/go-micro/v3&quot; &quot;github.com/asim/go-micro/v3/logger&quot; &quot;github.com/asim/go-micro/v3/registry&quot; &quot;github.com/asim/go-micro/v3/server&quot; &quot;github.com/gin-gonic/gin&quot; &quot;go-micro-examples/http/handler&quot;)const ( ServerName = &quot;go.micro.web.DemoHTTP&quot; // server name)func main() { // Create service srv := httpServer.NewServer( server.Name(ServerName), server.Address(&quot;:8080&quot;), ) gin.SetMode(gin.ReleaseMode) router := gin.New() router.Use(gin.Recovery()) // register router demo := handler.NewDemo() demo.InitRouter(router) hd := srv.NewHandler(router) if err := srv.Handle(hd); err != nil { logger.Fatal(err) } // Create service service := micro.NewService( micro.Server(srv), micro.Registry(registry.NewRegistry()), ) service.Init() // Run service if err := service.Run(); err != nil { logger.Fatal(err) }} 使用 gin 进行初始化路由在 http 目录创建 handler\\handler.go 12345678910111213141516171819202122232425262728293031323334353637package handlerimport ( &quot;context&quot; &quot;github.com/asim/go-micro/v3&quot; &quot;github.com/gin-gonic/gin&quot; helloworld &quot;go-micro-examples/helloworld/proto&quot;)//demotype demo struct{}func NewDemo() *demo { return &amp;demo{}}func (a *demo) InitRouter(router *gin.Engine) { router.POST(&quot;/demo&quot;, a.demo)}func (a *demo) demo(c *gin.Context) { // create a service service := micro.NewService() service.Init() client := helloworld.NewHelloworldService(&quot;go.micro.srv.HelloWorld&quot;, service.Client()) rsp, err := client.Call(context.Background(), &amp;helloworld.Request{ Name: &quot;world!&quot;, }) if err != nil { c.JSON(200, gin.H{&quot;code&quot;: 500, &quot;msg&quot;: err.Error()}) return } c.JSON(200, gin.H{&quot;code&quot;: 200, &quot;msg&quot;: rsp.Msg})} postman测试在启动两个微服务之后，如下图: 使用 postman 进行测试，调用成功并返回 “hello world!”","link":"/2021/04/28/GO/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98Go-Micro-v3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89-%E5%90%AF%E5%8A%A8HTTP%E6%9C%8D%E5%8A%A1/"},{"title":"微服务实战Go Micro v3 系列（二）- HelloWorld","text":"首先从我们最最熟悉的 helloworld 例子在入手，对 go-micro 有一个初步的了解 源码地址 源码地址 爱租房微服务综合项目 ProtoBuf简介protocol buffers （ProtoBuf）是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。 Protocol Buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。 json\\xml都是基于文本格式，protobuf是二进制格式。 你可以通过 ProtoBuf 定义数据结构，然后通过 ProtoBuf 工具生成各种语言版本的数据结构类库，用于操作 ProtoBuf 协议数据 本教程介绍的是最新的protobuf proto3版本的语法。 使用ProtoBuf的例子创建 .proto 文件，定义数据结构 使用 ProtoBuf ，首先需要通过 ProtoBuf 语法定义数据结构(消息)，这些定义好的数据结构保存在.proto为后缀的文件中。 例子: 文件名: response.proto 12345678// 指定protobuf的版本，proto3是最新的语法版本syntax = &quot;proto3&quot;;// 定义数据结构，message 你可以想象成java的class，c语言中的structmessage Response { string data = 1; // 定义一个string类型的字段，字段名字为data, 序号为1 int32 status = 2; // 定义一个int32类型的字段，字段名字为status, 序号为2} 说明：proto文件中，字段后面的序号，不能重复，定义了就不能修改，可以理解成字段的唯一ID。 安装ProtoBuf编译器protobuf的github发布地址： https://github.com/protocolbuffers/protobuf/releases protobuf的编译器叫protoc，在上面的网址中找到最新版本的安装包，下载安装。 这里下载的是：protoc-3.9.1-win64.zip ， windows 64位系统版本的编译器，下载后，解压到你想要的安装目录即可。 提示：安装完成后，将 [protoc安装目录]/bin 路径添加到PATH环境变量中 打开cmd，命令窗口执行protoc命令，没有报错的话，就已经安装成功。 更多protoc的教程请点击这里 grpcgRPC 是一个高性能、跨平台、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C/C++、Java、Python、Ruby、C#、PHP、Node.js、Go 语言等版本，几乎你想到的语言都支持了. gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。 下面先介绍grpc相关概念 grpc是什么？在 gRPC 里客户端应用可以像调用本地方法一样直接调用另一台机器上服务端应用的方法，这样我们就很容易创建分布式应用和服务。跟其他 RPC 系统类似，gRPC 也是基于以下理念：首先定义一个服务，定义能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个方法，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根，这个存根就是长得像服务端一样的方法（但是没有具体实现），客户端通过这个存根调用服务端的方法。 grpc工作原理，如下图： grpc使用的协议gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据的序列化机制，当然也可以使用其他数据格式如 JSON，不过通常都使用protocol buffers这种灵活、高效的数据格式，如果不了解protobuf语法，点击这里学习 protocol buffers入门教程。 服务定义使用gprc，首先需要定义服务， 指定其可以被远程调用的方法及其参数和返回类型。 服务，你可以理解成服务端api接口的集合，对外提供一些功能。 通过protobuf定义服务的例子： 123456789101112131415// 定义一个叫HelloService的服务service HelloService { // 定义一个叫SayHello的方法，这个方法接受HelloRequest消息作为参数，返回HelloResponse消息 rpc SayHello (HelloRequest) returns (HelloResponse);}// 定义HelloRequest消息message HelloRequest { string greeting = 1;}// 定义HelloResponse消息message HelloResponse { string reply = 1;} 如果你把service和message关键词当成class，是不是跟类定义很像！ gRPC 允许你定义四类服务方法，下面分别介绍如何定义，以及客户端和服务端的交互方式。 单向RPC即客户端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。 12rpc SayHello(HelloRequest) returns (HelloResponse){} 服务端流式 RPC即客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。 通俗的讲就是客户端请求一次，服务端就可以源源不断的给客户端发送消息。 123// 注意stream关键词在什么地方rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse){} 客户端流式 RPC即客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。 通俗的讲就是请求一次，客户端就可以源源不断的往服务端发送消息。 123// 注意stream关键词在什么地方rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) {} 双向流式 RPC即两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。 类似tcp通信，客户端和服务端可以互相发消息。 123// 注意stream关键词在什么地方rpc BidiHello(stream HelloRequest) returns (stream HelloResponse){} 更多关于grpc教程请点击这里 编写 go-micro HTTP服务安装 gofast插件12//gofastgo get -u -v github.com/gogo/protobuf/protoc-gen-gofast 开始编写 go-micro HTTP服务创建 go-micro-examples 目录，然后在该目录下创建 helloworld目录 在 helloworld 目录下，创建 proto 和 handler，并创建 main.go 和使用 go mod init 初始化项目，如下图所示 其它文件暂时忽略，后面会解释 在 proto 目录创建 helloworld.proto，并写入下面代码 123456789101112131415161718192021222324252627282930313233343536373839syntax = &quot;proto3&quot;;package helloworld;option go_package = &quot;proto;helloworld&quot;;service Helloworld { rpc Call(Request) returns (Response) {} rpc Stream(StreamingRequest) returns (stream StreamingResponse) {} rpc PingPong(stream Ping) returns (stream Pong) {}}message Message { string say = 1;}message Request { string name = 1;}message Response { string msg = 1;}message StreamingRequest { int64 count = 1;}message StreamingResponse { int64 count = 1;}message Ping { int64 stroke = 1;}message Pong { int64 stroke = 1;} 进入该目录并输入以下命令 并生成 helloworld.pb.go、helloworld.pb.micro.go 在 main.go，创建服务并注册一下 handler，运行服务 123456789101112131415161718192021222324252627282930package mainimport ( &quot;github.com/asim/go-micro/v3&quot; &quot;github.com/asim/go-micro/v3/logger&quot; &quot;go-micro-examples/helloworld/handler&quot; pb &quot;go-micro-examples/helloworld/proto&quot;)const ( ServerName = &quot;go.micro.srv.HelloWorld&quot; // server name)func main() { // Create service service := micro.NewService( micro.Name(ServerName), micro.Version(&quot;latest&quot;), ) // Register handler if err := pb.RegisterHelloworldHandler(service.Server(), new(handler.Helloworld)); err != nil { logger.Fatal(err) } // Run service if err := service.Run(); err != nil { logger.Fatal(err) }} client 调用 service创建 client 目录并创建client.go，写入一下代码 1234567891011121314151617181920212223242526272829package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;github.com/asim/go-micro/v3&quot; helloworld &quot;go-micro-examples/helloworld/proto&quot;)func main() { // create a new service service := micro.NewService() // parse command line flags service.Init() // Use the generated client stub cl := helloworld.NewHelloworldService(&quot;go.micro.srv.HelloWorld&quot;, service.Client()) // Make request rsp, err := cl.Call(context.Background(), &amp;helloworld.Request{ Name: &quot;John&quot;, }) if err != nil { fmt.Println(err) return } fmt.Println(rsp.Msg)} 效果先启用 go.micro.srv.HelloWorld 服务，然后再启动 client 调用，效果如下 启动 client 之后，输出 Hello World! 参考链接 ProtoBuf 入门教程 grpc 框架教程","link":"/2021/04/27/GO/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98Go-Micro-v3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89-HelloWorld/"},{"title":"微服务实战Go Micro v3 系列（五）- 注册和配置中心","text":"这一篇就来讲讲，go-micro v3 如何进行配置consul注册中心和操作配置中心 源码地址 源码地址 爱租房微服务综合项目 前言go-micro框架为服务注册发现提供了标准的接口Registry。只要实现这个接口就可以定制自己的服务注册和发现。不过官方已经为主流注册中心提供了官方的接口实现，大多数时候我们不需要从头写起。 代码仓库示例代码 Docker 安装 Consul这里使用 consul 演示，因为consul自带UI界面，方便操作 1docker pull consul # 默认拉取latest 运行单机版consul 1docker run -d -p 8500:8500 --restart=always --name=consul consul:latest agent -server -bootstrap -ui -node=1 -client='0.0.0.0' 参数解释如下： agent: 表示启动 Agent 进程。 server：表示启动 Consul Server 模式 client：表示启动 Consul Client 模式。 bootstrap：表示这个节点是 Server-Leader ，每个数据中心只能运行一台服务器。技术角度上讲 Leader 是通过 Raft 算法选举的，但是集群第一次启动时需要一个引导 Leader，在引导群集后，建议不要使用此标志。 ui：表示启动 Web UI 管理器，默认开放端口 8500，所以上面使用 Docker 命令把 8500 端口对外开放。 node：节点的名称，集群中必须是唯一的，默认是该节点的主机名。 client：consul服务侦听地址，这个地址提供HTTP、DNS、RPC等服务，默认是127.0.0.1所以不对外提供服务，如果你要对外提供服务改成0.0.0.0 join：表示加入到某一个集群中去。 如：-json=192.168.0.11。 运行成功后，访问 http://localhost:8500就可以到consul自带的UI界面了，如图： 关键代码1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;github.com/asim/go-micro/plugins/registry/consul/v3&quot; &quot;github.com/asim/go-micro/v3&quot; &quot;github.com/asim/go-micro/v3/logger&quot; &quot;github.com/asim/go-micro/v3/registry&quot; &quot;go-micro-examples/registerConfiguration/handler&quot; pb &quot;go-micro-examples/registerConfiguration/proto&quot;)func main() { // Register consul reg := consul.NewRegistry(func(options *registry.Options) { options.Addrs =[]string{&quot;127.0.0.1:8500&quot;} }) // Create service srv := micro.NewService( micro.Name(&quot;go.micro.srv.registerconfiguration&quot;), micro.Version(&quot;latest&quot;), // 注册consul中心 micro.Registry(reg), ) // Register handler if err := pb.RegisterRegisterConfigurationHandler(srv.Server(), new(handler.RegisterConfiguration)); err != nil { logger.Fatal(err) } // Run service if err := srv.Run(); err != nil { logger.Fatal(err) }} go-micro v3 提供 plugins，只需要引入并创建实例之后，使用 micro.Registry 注册即可 运行后效果图如下： 配置中心点击 Key/Value 创建目录 micro/config，然后在config目录分别创建 mysql、redis、logger、server 四个目录，如下图所示： 以其中mysql为例，输入一下信息： 1234567{ &quot;host&quot;: &quot;192.168.0.65&quot;, // 主机地址 &quot;user&quot;: &quot;root&quot;, // 用户名 &quot;pwd&quot;: &quot;123456&quot;, // 密码 &quot;database&quot;: &quot;go-shop-b2b2c&quot;, // 数据库 &quot;port&quot;: 3306 // 端口} 然后在 registerConfiguration 创建 config 目录，并创建 config.go、mysql.go文件，分别编写其中代码 config.go1234567891011121314151617181920212223242526272829303132333435package configimport ( &quot;github.com/asim/go-micro/plugins/config/source/consul/v3&quot; &quot;github.com/asim/go-micro/v3/config&quot; &quot;strconv&quot;)const ( Host = &quot;192.168.0.65&quot; Port = 8500 Prefix = &quot;/micro/config&quot;)// GetConsulConfig 设置配置中心func GetConsulConfig() (config.Config, error) { //添加配置中心 //配置中心使用consul key/value 模式 consulSource := consul.NewSource( //设置配置中心地址 consul.WithAddress(Host+&quot;:&quot;+strconv.FormatInt(Port, 10)), //设置前缀，不设置默认为 /micro/config consul.WithPrefix(Prefix), //是否移除前缀，这里设置为true 表示可以不带前缀直接获取对应配置 consul.StripPrefix(true), ) //配置初始化 conf, err := config.NewConfig() if err != nil { return conf, err } //加载配置 err = conf.Load(consulSource) return conf, err} mysql.go1234567891011121314151617181920212223package configimport &quot;github.com/asim/go-micro/v3/config&quot;// MysqlConfig 创建结构体type MysqlConfig struct { Host string `json:&quot;host&quot;` User string `json:&quot;user&quot;` Pwd string `json:&quot;pwd&quot;` Database string `json:&quot;database&quot;` Port int64 `json:&quot;port&quot;`}// GetMysqlFromConsul 获取mysql的配置func GetMysqlFromConsul(config config.Config, path ...string) (*MysqlConfig, error) { mysqlConfig := &amp;MysqlConfig{} //获取配置 err := config.Get(path...).Scan(mysqlConfig) if err != nil { return nil, err } return mysqlConfig, nil} main.go在启动服务之前就可以获取配置中心的配置信息，代码如下： 12345678910111213// 配置中心consulConfig, err := config.GetConsulConfig(&quot;127.0.0.1&quot;, 8500, &quot;/micro/config&quot;)if err != nil { logger.Fatal(err)}// Mysql配置信息mysqlInfo, err := config.GetMysqlFromConsul(consulConfig, &quot;mysql&quot;)if err != nil { logger.Fatal(err)}logger.Info(&quot;Mysql配置信息:&quot;, mysqlInfo) 运行后入如下图，可以看到，已经成功获取刚才输入的配置信息：","link":"/2021/06/02/GO/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98Go-Micro-v3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89-%E6%B3%A8%E5%86%8C%E5%92%8C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"},{"title":"微服务实战Go Micro v3 系列（六）- 综合篇（爱租房项目）","text":"经过前五篇的学习，综合篇结合前面的，用一个项目在进行融会贯通。 源码地址 源码地址 爱租房微服务综合项目 项目介绍此项目，是我fork github一个开源项目而来的，由于刚好它是go-micro-v2，我进行升级改造到v3用来做综合篇。 技术栈golang + docker + consul + grpc + protobuf + beego + mysql + redis + fastDFS + nginx 目录介绍├── DeleteSession│ ├── 退出登录时清除session├── GetArea│ ├── 获取地区信息服务├── GetImageCd│ ├── 获取验证码图片服务├── GetSession│ ├── 获取Session信息服务├── GetSmscd│ ├── 获取短信信息服务├── GetUserHouses│ ├── 获取用户已发布房屋的服务├── GetUserInfo│ ├── 获取用户详细信息的服务├── web│ ├── conf 项目配置文件│ │ ├── app.conf│ │ ├── data.sql│ │ └── redis.conf│ ├── handler│ │ └── handler.go 配置路由│ ├── html 项目静态文件│ ├── main.go 主函数│ ├── model 数据库模型│ │ └── models.go│ ├── plugin.go│ ├── server.sh│ └── utils 项目中用到的工具函数│ ├── config.go│ ├── error.go│ └── misc.go├── PostAvatar│ ├── 发送（上传）用户头像服务├── PostHouses│ ├── 发送（发布）房源信息服务├── PostHousesImage│ ├── 发送（上传）房屋图片服务├── PostLogin│ ├── 发送登录服务消息├── PostRet│ ├── 发现注册信息服务├── PostUserAuth│ ├── 发送用户实名认证信息服务├── PutUserInfo│ ├── 发送用户信息├── GetUserAuth│ ├── 获取（检查）用户实名信息服务├── PostHousesImage│ ├── 发送（上传）房屋图片服务├── GetHouseInfo│ ├── 获取房屋详细信息服务├── GetIndex│ ├── 获取首页轮播图片服务├── GetHouses│ ├── 获取（搜索）房源服务├── PostOrders│ ├── 发送（发布）订单服务├── GetUserOrder│ ├── 获取房东/租户订单信息服务├── PutOrders│ ├── 更新房东同意/拒绝订单├── PutComments│ ├── 更新用户评价订单信息└── README.md 部分效果图 参考链接 参考项目的源代码","link":"/2021/06/08/GO/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98Go-Micro-v3-%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89-%E7%BB%BC%E5%90%88%E7%AF%87%EF%BC%88%E7%88%B1%E7%A7%9F%E6%88%BF%E9%A1%B9%E7%9B%AE%EF%BC%89/"},{"title":"微服务实战Go Micro v3 系列（四）- 事件驱动(Pub&#x2F;Sub)","text":"事件驱动架构 理解起来比较简单，普遍认为好的软件架构都是解耦的，微服务之间不应该相互耦合或依赖。举个例子，我们在代码中调用微服务 go.srv.user-service 的函数，会先通过服务发现找到微服务的地址再调用，我们的代码与该微服务有了直接性的调用交互，并不算是完全的解耦。 源码地址 源码地址 爱租房微服务综合项目 发布与订阅模式为了理解事件驱动架构为何能使代码完全解耦，先了解事件的发布、订阅流程。微服务 X 完成任务 x 后通知消息系统说 “x 已完成”，它并不关心有哪些微服务正在监听这个事件、事件发生后会产生哪些影响。如果系统发生了某个事件，随之其他微服务都要做出动作是很容易的。 举个例子，user-service 创建了一个新用户，email-service 要给该用户发一封注册成功的邮件，message-service 要给网站管理员发一条用户注册的通知短信。 一般实现在 user-service 的代码中实例化另两个微服务 Client 后，调用函数发邮件和短信，代码耦合度很高。如下图： 事件驱动在事件驱动的架构下，user-service 只需向消息系统发布一条 topic 为 “user.created” 的消息，其他两个订阅了此 topic 的 service 能知道有用户注册了，拿到用户信息后他们自行发邮件、发短信。如下图： 代码实现Publish 事件发布1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( &quot;context&quot; &quot;github.com/asim/go-micro/v3&quot; &quot;github.com/asim/go-micro/v3/metadata&quot; &quot;github.com/asim/go-micro/v3/server&quot; &quot;github.com/asim/go-micro/v3/util/log&quot; proto &quot;go-micro-examples/pubsub/proto&quot;)// Sub All methods of Sub will be executed when// a message is receivedtype Sub struct{}// Process Method can be of any namefunc (s *Sub) Process(ctx context.Context, event *proto.Event) error { md, _ := metadata.FromContext(ctx) log.Logf(&quot;[pubsub.1] Received event %+v with metadata %+v\\n&quot;, event, md) // do something with event return nil}// Alternatively a function can be usedfunc subEv(ctx context.Context, event *proto.Event) error { md, _ := metadata.FromContext(ctx) log.Logf(&quot;[pubsub.2] Received event %+v with metadata %+v\\n&quot;, event, md) // do something with event return nil}func main() { // create a service service := micro.NewService( micro.Name(&quot;go.micro.srv.pubsub&quot;), ) // parse command line service.Init() // register subscriber if err := micro.RegisterSubscriber(&quot;example.topic,pubsub.1&quot;, service.Server(), new(Sub)); err != nil { log.Fatal(err) } // register subscriber with queue, each message is delivered to a unique subscriber if err := micro.RegisterSubscriber(&quot;example.topic.pubsub.2&quot;, service.Server(), subEv, server.SubscriberQueue(&quot;queue.pubsub&quot;)); err != nil { log.Fatal(err) } if err := service.Run(); err != nil { log.Fatal(err) }} 运行效果如下： 可以看到，直接使用 go-micro 的 NewEvent 订阅即可，成功订阅 example.topic.pubsub.1、example.topic.pubsub.2 Subscribe 事件订阅事件既然有订阅，那么当然会有订阅 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( &quot;context&quot; &quot;fmt&quot; &quot;github.com/asim/go-micro/v3&quot; &quot;github.com/asim/go-micro/v3/util/log&quot; &quot;github.com/pborman/uuid&quot; proto &quot;go-micro-examples/pubsub/proto&quot; &quot;time&quot;)// send events using the publisherfunc sendEv(topic string, p micro.Publisher) { t := time.NewTimer(time.Second) for _ = range t.C { // crate new event ev := &amp;proto.Event{ Id: uuid.NewUUID().String(), Timestamp: time.Now().Unix(), Message: fmt.Sprintf(&quot;Messaging you all day on %s&quot;, topic), } log.Logf(&quot;publishing %+v\\n&quot;, ev) // publish an event if err := p.Publish(context.Background(), ev); err != nil { log.Logf(&quot;error publishing %v&quot;, err) } }}func main() { // create a service service := micro.NewService( micro.Name(&quot;go.micro.cli.pubsub&quot;), ) // parse command line service.Init() // create publisher pub1 := micro.NewEvent(&quot;example.topic.pubsub.1&quot;, service.Client()) pub2 := micro.NewEvent(&quot;example.topic.pubsub.2&quot;, service.Client()) // pub to topic 1 go sendEv(&quot;example.topic.pubsub.1&quot;, pub1) // pub to topic 2 go sendEv(&quot;example.topic.pubsub.2&quot;, pub2) // block forever select {}} 运行效果如下： 从图中可以看出，成功订阅事件并调用成功","link":"/2021/05/12/GO/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98Go-Micro-v3-%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-Pub-Sub/"},{"title":"手摸手，带你用Beego撸商城系列一（基础篇）","text":"完整项目地址： go-shop-b2c 前言这里不会讲解太多的基础知识，主要介绍关于从零开始使用 Beego 框架撸一个商城思路 目录结构1234567891011121314151617├── common // 公共函数├── conf // 配置相关├── controllers // API请求│ ├── admin // 后台管理 API│ ├── web // 移动web商城 API├── helpers // 工具函数├── model_views // 前端展示 Struct├── models // Model层├── routers // RESTful 路由├── setting // 系统配置├── sysinit // 应用启动前初始化├── .gitignore // git 忽略项├── go.mod // Go Module依赖├── go-shop-b2c // SQL文件├── go-shop-b2c.xml // 系统配置XML├── main.go // 入口 main.go├── xxx.p12 // API证书(微信支付) 下面简单介绍目录代码 controllers简单截取一下 controller/admin 的 controller 这里着重介绍一下 json_controller.go、base_controller.go json_controller.go 继承 beego.Controller，增加返回前端 JOSN 数据处理函数、服务报错误处理等公共函数等 base_controller.go 继承 json_controller.go，重载 Prepare 函数，并做登录有效信息校验等 关键代码示例： models使用 Beego 提供的 Bee 工具 api 命令生成的 Model层，主要包含增、删、改、查数据库的函数 截图某个片段示例： routersbeego 的 RESTful Controller 路由 关键代码示例： setting商城后台管理系统的系统设置模快，存储于 xml 文件, setting/setting.go 是封装 对 go-shop-b2c.xml的操作 对应商城管理系统的系统设置模快，前端展示： sysintbeego 执行 RUN 之前，各种初始化操作，比如 日志打印、数据库连接、CORS配置等 关键代码示例：","link":"/2021/03/30/GO/%E6%89%8B%E6%91%B8%E6%89%8B%EF%BC%8C%E5%B8%A6%E4%BD%A0%E7%94%A8Beego%E6%92%B8%E5%95%86%E5%9F%8E%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%88%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/"},{"title":"手摸手，带你用Beego撸商城系列三（系统配置篇）","text":"完整项目地址： go-shop-b2c 前言这篇就来讲解，一下要启动项目的一些基础配置，比如通过 bee 工具生成 model 层，CORS配置，router配置，日志配置等 Bee 工具生成 model 层bee 工具简介bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署。 bee 工具的安装1go get -u github.com/beego/bee/v2 输入 1bee version 如下图所示: 这里只能介绍 bee 根据 MySql 反向生成 api 应用 api 命令script1bee api [appname] [-tables=&quot;&quot;] [-driver=mysql] [-conn=&quot;root:&lt;password&gt;@tcp(127.0.0.1:3306)/test&quot;] 可选命令介绍 appname，生成 api 应用的名称 -tables，顾名思义生成的表名，””表示反射全部表，如果输入固定表名，只反射输入的表名 -driver，数据库驱动，支持Mysql、Oracle、Mongodb等 -conn，连接地址，root:@tcp(127.0.0.1:3306)/test 输入如下命令: script1bee api appname -tables=&quot;&quot; -driver=mysql -conn=&quot;root:123456@tcp(127.0.0.1:3306)/go-shop-b2c&quot; 目录结构如下: 项目和SQL文件 点击跳转 项目路由设置前面我们已经创建了 beego 项目，而且我们也看到它已经运行起来了，那么是如何运行起来的呢？让我们从入口文件先分析起来吧： 12345678910package mainimport ( _ &quot;quickstart/routers&quot; &quot;github.com/beego/beego/v2/server/web&quot;)func main() { web.Run()} 我们看到 main 函数是入口函数，但是我们知道 Go 的执行过程是如下图所示的方式： 这里我们就看到了我们引入了一个包 _ “quickstart/routers”,这个包只引入执行了里面的 init 函数，那么让我们看看这个里面做了什么事情： 12345678910111213141516171819package routersimport ( &quot;appname/controllers&quot; beego &quot;github.com/beego/beego/v2/server/web&quot;)func init() { ns := beego.NewNamespace(&quot;/v1&quot;, beego.NSNamespace(&quot;/ad&quot;, beego.NSInclude( &amp;controllers.AdController{}, ), ), ) beego.AddNamespace(ns)} CORS 配置api 项目通常都需要进行跨域配置，因为要方便前端本地调试，配置如下： 12345678910111213141516func corsInit() { beego.InsertFilter(&quot;*&quot;, beego.BeforeRouter, cors.Allow(&amp;cors.Options{ // 可选参数&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot; (*为所有) // 其中Options跨域复杂请求预检 AllowMethods: []string{&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;}, // 指的是允许的Header的种类 AllowHeaders: []string{&quot;Origin&quot;, &quot;Authorization&quot;, &quot;Access-Control-Allow-Origin&quot;, &quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;}, // 公开的HTTP标头列表 ExposeHeaders: []string{&quot;Content-Length&quot;, &quot;Access-Control-Allow-Origin&quot;, &quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;}, // 如果设置，则允许共享身份验证凭据，例如cookie AllowCredentials: true, // 指定可访问域名AllowOrigins AllowOrigins: []string{&quot;*&quot;}, }))} 日志配置12_ = logs.SetLogger(&quot;console&quot;)logs.EnableFuncCallDepth(true)","link":"/2021/04/09/GO/%E6%89%8B%E6%91%B8%E6%89%8B%EF%BC%8C%E5%B8%A6%E4%BD%A0%E7%94%A8Beego%E6%92%B8%E5%95%86%E5%9F%8E%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%88%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE%E7%AF%87%EF%BC%89/"},{"title":"手摸手，带你用Beego撸商城系列二（登录篇）","text":"完整项目地址： go-shop-b2c 前言一个商城后端系统，登录尤其重要，首先用户下单，需要登录，后台管理系统，需要登录。我们需要做的是，除了登录以及注册，其余的接口需要进行登录校验。 base_controller 封装由于我们需要进行登录校验和不进行登录校验的 Controller，又由于 base_controller 需要进行登录检验，同时，不需要登录校验的 Controller 和 base_controller有共同的函数需要调用 综上所述，我们应该额外增加一个 Controller 分别用于 base_controller 继承 和 不需要登录检验的 Controller 用于继承 下面就简单地介绍一下 json_controller json_controller123type JsonController struct { beego.Controller} JsonResult 返回给前端JSON数据，公共调用函数123456789101112131415/** * Ajax接口返回Json */func (c *JsonController) JsonResult(status int, errCode int, errMsg string, data ...interface{}) { jsonData := make(map[string]interface{}, 3) jsonData[&quot;err_code&quot;] = errCode jsonData[&quot;message&quot;] = errMsg if len(data) &gt; 0 &amp;&amp; data[0] != nil { jsonData[&quot;data&quot;] = data[0] } c.Ctx.Output.SetStatus(status) c.Data[&quot;json&quot;] = jsonData c.ServeJSON()} ServerError 服务器通用报错1234567/** * 服务器报错 */func (c *JsonController) ServerError(err error) { c.Ctx.Output.SetStatus(http.GetHttpStatusByAlias(&quot;internalServerError&quot;)) logs.Error(err)} SetSessionUser 封装保存session的函数12345678910111213/** * 设置登录登录用户session信息 */func (c *JsonController) SetSessionUser(member models.Member) { if member.Id &lt;= 0 { c.DelSession(common.SessionName) c.DelSession(&quot;uid&quot;) c.DestroySession() } else { c.SetSession(common.SessionName, member) c.SetSession(&quot;uid&quot;, member.Id) }} 登录检验在 beego 的 Prepare 函数调用简单说一下Prepare函数的作用，这个函数主要是为了用户扩展用的，这个函数会在下面定义的这些 Method 方法之前执行，用户可以重写这个函数实现类似用户验证之类。点击跳转文档查看方法 主要做三件事 gob 序列化保存用户信息ps: 序列化某个对象,必须在 encoding/gob 编码解码前进行注册 从 session 中获取用户信息 如果 Cookie 中存在登录信息，从 cookie 中获取用户信息 在其它 Controller 基本写法主要分类，需要登录检验和不需要登录检验的 Controller，不需要登录校验通常是包含登录和注册的 Controller 需要登录检验的 Controller编写 以 address_controller 为例 截取部分代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 需要登录校验就需要继承 BaseController，这样该 Controller下的函数都在调用执行之前到 执行Prepare函数进行登录检验type AddressController struct { BaseController}// URLMapping ...func (c *AddressController) URLMapping() { c.Mapping(&quot;AddAddress&quot;, c.AddAddress) c.Mapping(&quot;DeleteAddress&quot;, c.DeleteAddress) c.Mapping(&quot;UpdateAddress&quot;, c.UpdateAddress) c.Mapping(&quot;GetAllAddress&quot;, c.GetAllAddress)}// @Title 新增地址// @router /add [post]func (c *AddressController) AddAddress() { var address model_views.Receiver if v := c.GetString(&quot;address&quot;); v != &quot;&quot; { _ = json.Unmarshal([]byte(v), &amp;address) } var receiver models.Receiver receiver.Id = address.Id receiver.Consignee = address.Consignee receiver.AreaName = address.AreaName receiver.AreaId = address.AreaId receiver.Address = address.Address receiver.IsDefault = address.IsDefault receiver.Phone = address.Phone receiver.ZipCode = address.ZipCode receiver.MemberId = int64(c.Member.Id) receiver.LastUpdatedBy = c.Member.Username _, err := models.AddReceiver(&amp;receiver) if err != nil { // 服务通用报错函数调用 c.ServerError(err) return } c.JsonResult(http.GetHttpStatusByAlias(&quot;created&quot;), http.ErrOK, http.Success, nil)} 就是这么简单，其它 Controller 基本都是如此 不需要登录检验的 Controller 编写截取部分代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 继承 JsonController，不会调用 BaseController 的Prepare函数进行登录校验type UserController struct { JsonController}// @Title 登录// @router /login [post]func (c *UserController) Login() { var mobile string var sms string // mobile if v := c.GetString(&quot;mobile&quot;); v != &quot;&quot; { mobile = v } // sms if v := c.GetString(&quot;sms&quot;); v != &quot;&quot; { sms = v } smsModel, err := models.GetSmsByCodeAndMobile(sms, mobile) if err != nil { c.JsonResult(http.GetHttpStatusByAlias(&quot;ok&quot;), http.ErrError, http.Fail, &quot;手机和验证码不匹配&quot;) return } if smsModel.ExpireDate != nil { c.JsonResult(http.GetHttpStatusByAlias(&quot;ok&quot;), http.ErrError, http.Fail, &quot;验证码已过期&quot;) return } if smsModel.IsUsed == 1 { c.JsonResult(http.GetHttpStatusByAlias(&quot;ok&quot;), http.ErrError, http.Fail, &quot;验证码已使用&quot;) return } member, _ := models.GetMemberByUsername(mobile) if member == nil { member = &amp;models.Member{} } if member.Id &gt; 0 { // 最后登录IP member.LoginIp = c.Ctx.Input.IP() member.LoginDate = time.Now() err = models.UpdateMemberById(member) if err != nil { c.ServerError(err) return } } else { member.Username = mobile member.Mobile = mobile member.MemberRankId = 1 // 普通会员 _, err := models.AddMember(member) if err != nil { c.ServerError(err) return } } /** * 更新短信使用 */ now := time.Now() smsModel.UsedDate = &amp;now smsModel.IsUsed = 1 err = models.UpdateSmsById(smsModel) if err != nil { c.ServerError(err) return } /** * 设置Cookie */ c.SetSessionUser(*member) var cookieMember CookieMember cookieMember.MemberId = member.Id cookieMember.Username = member.Username cookieMember.Time = time.Now() v, err := helpers.Encode(cookieMember) if err == nil { c.SetSecureCookie(common.AppKey(), &quot;web_login&quot;, v, 24*3600) } commonController := &amp;CommonController{} memberView := commonController.setMemberByMemberModel(*member) c.JsonResult(http.GetHttpStatusByAlias(&quot;ok&quot;), http.ErrOK, http.Success, memberView)} 总结最后，写完这两个基础的 Controller 后，基本就是根据业务判断是否需要登录校验，然后就行CRUD（增删改查）的业务编写就好了，没错就是这么简单","link":"/2021/04/01/GO/%E6%89%8B%E6%91%B8%E6%89%8B%EF%BC%8C%E5%B8%A6%E4%BD%A0%E7%94%A8Beego%E6%92%B8%E5%95%86%E5%9F%8E%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%88%E7%99%BB%E5%BD%95%E7%AF%87%EF%BC%89/"},{"title":"video和audio","text":"video poster 铺满给video添加obect-fill: fill 即可 1&lt;video style=&quot;object-fill: fill&quot;&gt;&lt;/video&gt;","link":"/2018/06/28/HTML/video%E5%92%8Caudio/"},{"title":"彻底理解 innerWidth、outerWidth、screen.width、vw 和 getBoundingClientRect的区别","text":"起因说实话，撸了接近三年的前端。每次要用到innerWidth、outerWidth、screen.width 、vw、clientWidth和 getBoundingClientRect，都很可耻地点击谷歌浏览器，然后…你懂的。才能知道我应该用那个。在此之前，我草草写了一篇极短的文章，天真地以为自己理解了，谁知不然，每次都是很熟练地…,哦不。 贴上图片，引以为戒: 说实话，至今没看懂这张图片，并且不知道为什么当初会吧这张图片放上去。手动狗头 在某一天，看到张鑫旭大神的文章里面写的这段话 如果还是大神牛逼啊！几句话就将得清楚明白了。这里少了getBoundingClientRect、clientWidth,所以我自己打算补充，并且以此吃透。 一个demo + 一篇文章 就可以理解 innerWidth、outerWidth、screen.width、vw附上张鑫旭大神的文章，写得非常可以有趣通俗易懂地理解 vw。视区相关单位vw, vh..简介以及可实际应用场景。是的，你没看错，人家大神2012已经开始了解vw了，并且还尝试考虑了vw的使用场景 请狠狠点击这里，张鑫旭写的demo。 理解 getBoundingClientRect, clientWidth前提条件由张鑫旭大神的文章 可知，“视区” 所指为浏览器内部的可视区域大小，即window.innerWidth/window.innerHeight大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。 从而得出 vw, 则是 window.innerWidth 不包含任务标题栏以及底部工具栏的浏览器区域大小。也就是说整个网页内容的大小，不受其它因素的影响。 如下图所示： 图片红色矩形部分，包括滚动条都属于 vw 的内容,而椭圆形的标题栏则不包括 请狠狠看这里 See the Pen innerWidth、outerWidth、screen.width、getBoundingClientRect、clientWidth by bamboo (@celverbamboo) on CodePen. 不断切换 select 里面的 vw的基础值，观察 图片的 width 、 getBoundingClientRect的width即可 clientWidth宽度,如下图所示 当为 10vw时，width : 101.9px, getBoundingClientRect: 101.890625 px, clientWidth: 102 px 当为 20vw时，width : 203.8px, getBoundingClientRect: 203.796875 px, clientWidth: 204 px 当为 30vw时，width : 305.7px, getBoundingClientRect: 305.6875 px, clientWidth: 306 px… 由此我们可以得出以下结论： width 获取图片元素保留一位小数的宽度 getBoundingClientRect 获取的元素宽度可以准确获取到小数值 clientWidth 只能获取元素宽度的整数，则会对元素进行四舍五入的计算 同时可以看出，width以及 clientWidth是基于 getBoundingClientRect进行换算的 应用场景既然我们知道了 width、getBoundingClientRect以及clientWidth异同和关系。下面来说说，它们在实际写项目的时候应用场景 width看下面一张图 该图商品列表中，用户可以横向滚动商品。横向滚动的效果实现，需要明确知道所有商品元素的宽度加起来的总宽度，然后设置为包裹该父元素的宽度。那么问题来了？是该用非常准确的 getBoundingClientRect 的 width 还是用 width , 还是 取整的 clientWidth呢？ 我当时是用了 width这个属性，因为考虑到这里只是简单的横向布局，没必要获取太详细的值，并没什么太大的意义。当然了，取 getBoundingClientRect 的 width 也是可以的。 getBoundingClientRect首先我们知道，getBoundingClientRect 获取的最精确的值。也就说，你需要获取分毫不差的值，进行某些操作，这时候往往是你的实现动画的时候。如下下图所示: 如果使用了不是很准确的值呢？结果获取的值误差越大，动画的效果和你想要的误差则越大。 clientWidth这个的话，暂时没想到以后想到再补充吧！ 相关链接文章 MDN: getBoundingClientRect MDN: clientWidth MDN: innerWidth 视区相关单位vw, vh..简介以及可实际应用场景","link":"/2019/12/12/HTML/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%20innerWidth%E3%80%81outerWidth%E3%80%81screen.width%E3%80%81vw%20%E5%92%8C%20getBoundingClientRect%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"title":"原始类型和栈类型的工具函数","text":"Array1、arrFlatten 数组去维 123456789101112131415function arrFlatten(arr) { return flat(arr, []);};function flat(arr, res) { var cur; var len = arr.length; for (var i = 0; i &lt; len; i++) { cur = arr[i]; Array.isArray(cur) ? flat(cur, res) : res.push(cur); } return res;}console.log(arrFlatten(['a', ['b', ['c']], 'd', ['e']])); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;] 2、dedupe 数组和对象去重 1234567891011121314151617181920212223242526function dedupe (client, hasher) { hasher = hasher || JSON.stringify const clone = [] const lookup = {} for (let i = 0; i &lt; client.length; i++) { let elem = client[i] let hashed = hasher(elem) if (!lookup[hashed]) { clone.push(elem) lookup[hashed] = true } } return clone}var aa = [{a: 2}, {a: 1}, {a: 1}, {a: 1}]var bb = dedupe(aa) console.log(bb) // result: [{a: 2}, {a: 1}]var a = [1, 2, 2, 3]var b = dedupe(a)console.log(b) // result: [1, 2, 3] 3、精准判断对象的类型 1Object.prototype.toString.call(xxx); // exp: [Object Array]、[Object Object] 4、url参数转对象 1234567891011121314151617181920212223242526/** * * @desc url参数转对象 * @param {String} url default: window.location.href * @return {Object} */function parseQueryString(url) { url = !url ? window.location.href : url; if(url.indexOf('?') === -1) { return {}; } var search = url[0] === '?' ? url.substr(1) : url.substring(url.lastIndexOf('?') + 1); if (search === '') { return {}; } search = search.split('&amp;'); var query = {}; for (var i = 0; i &lt; search.length; i++) { var pair = search[i].split('='); query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || ''); } return query;}module.exports = parseQueryString 5、URL 对象序列化 123456789101112131415161718192021222324252627/** * * @desc 对象序列化 * @param {Object} obj * @return {String} */function stringfyQueryString(obj) { if (!obj) return ''; var pairs = []; for (var key in obj) { var value = obj[key]; if (value instanceof Array) { for (var i = 0; i &lt; value.length; ++i) { pairs.push(encodeURIComponent(key + '[' + i + ']') + '=' + encodeURIComponent(value[i])); } continue; } pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key])); } return pairs.join('&amp;');}module.exports = stringfyQueryString 6、函数防抖 1234567891011121314151617181920var throttle = require('./throttle');/** * @desc 函数防抖 * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次， * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。 * @example 适用场景：如在线编辑的自动存储防抖。 * @param {Number} delay 0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。 * @param {Boolean} atBegin 可选，默认为false。 * 如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。 如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行 * @param {Function} callback 延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的， * 执行去抖动功能时，，调用`callback`。 * * @return {Function} 新的防抖函数。 */function debounce(delay, atBegin, callback) { return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);};module.exports = debounce; 7、函数节流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * @desc 函数节流。 * 适用于限制`resize`和`scroll`等函数的调用频率 * * @param {Number} delay 0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。 * @param {Boolean} noTrailing 可选，默认为false。 * 如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。 * 如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次. * （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位） * @param {Function} callback 延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的， * 执行去节流功能时，调用`callback`。 * @param {Boolean} debounceMode 如果`debounceMode`为true，`clear`在`delay`ms后执行。 * 如果debounceMode是false，`callback`在`delay` ms之后执行。 * * @return {Function} 新的节流函数 */module.exports = function throttle(delay, noTrailing, callback, debounceMode) { // After wrapper has stopped being called, this timeout ensures that // `callback` is executed at the proper times in `throttle` and `end` // debounce modes. var timeoutID; // Keep track of the last time `callback` was executed. var lastExec = 0; // `noTrailing` defaults to falsy. if (typeof noTrailing !== 'boolean') { debounceMode = callback; callback = noTrailing; noTrailing = undefined; } // The `wrapper` function encapsulates all of the throttling / debouncing // functionality and when executed will limit the rate at which `callback` // is executed. function wrapper() { var self = this; var elapsed = Number(new Date()) - lastExec; var args = arguments; // Execute `callback` and update the `lastExec` timestamp. function exec() { lastExec = Number(new Date()); callback.apply(self, args); } // If `debounceMode` is true (at begin) this is used to clear the flag // to allow future `callback` executions. function clear() { timeoutID = undefined; } if (debounceMode &amp;&amp; !timeoutID) { // Since `wrapper` is being called for the first time and // `debounceMode` is true (at begin), execute `callback`. exec(); } // Clear any existing timeout. if (timeoutID) { clearTimeout(timeoutID); } if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) { // In throttle mode, if `delay` time has been exceeded, execute // `callback`. exec(); } else if (noTrailing !== true) { // In trailing throttle mode, since `delay` time has not been // exceeded, schedule `callback` to execute `delay` ms after most // recent execution. // // If `debounceMode` is true (at begin), schedule `clear` to execute // after `delay` ms. // // If `debounceMode` is false (at end), schedule `callback` to // execute after `delay` ms. timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay); } } // Return the wrapper function. return wrapper;}; 8、根据keycode获得键名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124var keyCodeMap = { 8: 'Backspace', 9: 'Tab', 13: 'Enter', 16: 'Shift', 17: 'Ctrl', 18: 'Alt', 19: 'Pause', 20: 'Caps Lock', 27: 'Escape', 32: 'Space', 33: 'Page Up', 34: 'Page Down', 35: 'End', 36: 'Home', 37: 'Left', 38: 'Up', 39: 'Right', 40: 'Down', 42: 'Print Screen', 45: 'Insert', 46: 'Delete', 48: '0', 49: '1', 50: '2', 51: '3', 52: '4', 53: '5', 54: '6', 55: '7', 56: '8', 57: '9', 65: 'A', 66: 'B', 67: 'C', 68: 'D', 69: 'E', 70: 'F', 71: 'G', 72: 'H', 73: 'I', 74: 'J', 75: 'K', 76: 'L', 77: 'M', 78: 'N', 79: 'O', 80: 'P', 81: 'Q', 82: 'R', 83: 'S', 84: 'T', 85: 'U', 86: 'V', 87: 'W', 88: 'X', 89: 'Y', 90: 'Z', 91: 'Windows', 93: 'Right Click', 96: 'Numpad 0', 97: 'Numpad 1', 98: 'Numpad 2', 99: 'Numpad 3', 100: 'Numpad 4', 101: 'Numpad 5', 102: 'Numpad 6', 103: 'Numpad 7', 104: 'Numpad 8', 105: 'Numpad 9', 106: 'Numpad *', 107: 'Numpad +', 109: 'Numpad -', 110: 'Numpad .', 111: 'Numpad /', 112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6', 118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12', 144: 'Num Lock', 145: 'Scroll Lock', 182: 'My Computer', 183: 'My Calculator', 186: ';', 187: '=', 188: ',', 189: '-', 190: '.', 191: '/', 192: '`', 219: '[', 220: '\\\\', 221: ']', 222: '\\''};/** * @desc 根据keycode获得键名 * @param {Number} keycode * @return {String} */function getKeyName(keycode) { if (keyCodeMap[keycode]) { return keyCodeMap[keycode]; } else { console.log('Unknow Key(Key Code:' + keycode + ')'); return ''; }};module.exports = getKeyName; 9、各种类型判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349function bind(fn, thisArg) { return function wrap() { var args = new Array(arguments.length); for (var i = 0; i &lt; args.length; i++) { args[i] = arguments[i]; } return fn.apply(thisArg, args); };};/*global toString:true*/// utils is a library of generic helper functions non-specific to axiosvar toString = Object.prototype.toString;/** * Determine if a value is an Array * * @param {Object} val The value to test * @returns {boolean} True if value is an Array, otherwise false */function isArray(val) { return toString.call(val) === '[object Array]';}/** * Determine if a value is an ArrayBuffer * * @param {Object} val The value to test * @returns {boolean} True if value is an ArrayBuffer, otherwise false */function isArrayBuffer(val) { return toString.call(val) === '[object ArrayBuffer]';}/** * Determine if a value is a FormData * * @param {Object} val The value to test * @returns {boolean} True if value is an FormData, otherwise false */function isFormData(val) { return (typeof FormData !== 'undefined') &amp;&amp; (val instanceof FormData);}/** * Determine if a value is a view on an ArrayBuffer * * @param {Object} val The value to test * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false */function isArrayBufferView(val) { var result; if ((typeof ArrayBuffer !== 'undefined') &amp;&amp; (ArrayBuffer.isView)) { result = ArrayBuffer.isView(val); } else { result = (val) &amp;&amp; (val.buffer) &amp;&amp; (val.buffer instanceof ArrayBuffer); } return result;}/** * Determine if an object is a Buffer * * @author Feross Aboukhadijeh &lt;https://feross.org&gt; * @license MIT */function isBuffer (obj) { return obj != null &amp;&amp; obj.constructor != null &amp;&amp; typeof obj.constructor.isBuffer === 'function' &amp;&amp; obj.constructor.isBuffer(obj)}/** * Determine if a value is a String * * @param {Object} val The value to test * @returns {boolean} True if value is a String, otherwise false */function isString(val) { return typeof val === 'string';}/** * Determine if a value is a Number * * @param {Object} val The value to test * @returns {boolean} True if value is a Number, otherwise false */function isNumber(val) { return typeof val === 'number';}/** * Determine if a value is undefined * * @param {Object} val The value to test * @returns {boolean} True if the value is undefined, otherwise false */function isUndefined(val) { return typeof val === 'undefined';}/** * Determine if a value is an Object * * @param {Object} val The value to test * @returns {boolean} True if value is an Object, otherwise false */function isObject(val) { return val !== null &amp;&amp; typeof val === 'object';}/** * Determine if a value is a Date * * @param {Object} val The value to test * @returns {boolean} True if value is a Date, otherwise false */function isDate(val) { return toString.call(val) === '[object Date]';}/** * Determine if a value is a File * * @param {Object} val The value to test * @returns {boolean} True if value is a File, otherwise false */function isFile(val) { return toString.call(val) === '[object File]';}/** * Determine if a value is a Blob * * @param {Object} val The value to test * @returns {boolean} True if value is a Blob, otherwise false */function isBlob(val) { return toString.call(val) === '[object Blob]';}/** * Determine if a value is a Function * * @param {Object} val The value to test * @returns {boolean} True if value is a Function, otherwise false */function isFunction(val) { return toString.call(val) === '[object Function]';}/** * Determine if a value is a Stream * * @param {Object} val The value to test * @returns {boolean} True if value is a Stream, otherwise false */function isStream(val) { return isObject(val) &amp;&amp; isFunction(val.pipe);}/** * Determine if a value is a URLSearchParams object * * @param {Object} val The value to test * @returns {boolean} True if value is a URLSearchParams object, otherwise false */function isURLSearchParams(val) { return typeof URLSearchParams !== 'undefined' &amp;&amp; val instanceof URLSearchParams;}/** * Trim excess whitespace off the beginning and end of a string * * @param {String} str The String to trim * @returns {String} The String freed of excess whitespace */function trim(str) { return str.replace(/^\\s*/, '').replace(/\\s*$/, '');}/** * Determine if we're running in a standard browser environment * * This allows axios to run in a web worker, and react-native. * Both environments support XMLHttpRequest, but not fully standard globals. * * web workers: * typeof window -&gt; undefined * typeof document -&gt; undefined * * react-native: * navigator.product -&gt; 'ReactNative' * nativescript * navigator.product -&gt; 'NativeScript' or 'NS' */function isStandardBrowserEnv() { if (typeof navigator !== 'undefined' &amp;&amp; (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) { return false; } return ( typeof window !== 'undefined' &amp;&amp; typeof document !== 'undefined' );}/** * Iterate over an Array or an Object invoking a function for each item. * * If `obj` is an Array callback will be called passing * the value, index, and complete array for each item. * * If 'obj' is an Object callback will be called passing * the value, key, and complete object for each property. * * @param {Object|Array} obj The object to iterate * @param {Function} fn The callback to invoke for each item */function forEach(obj, fn) { // Don't bother if no value provided if (obj === null || typeof obj === 'undefined') { return; } // Force an array if not already something iterable if (typeof obj !== 'object') { /*eslint no-param-reassign:0*/ obj = [obj]; } if (isArray(obj)) { // Iterate over array values for (var i = 0, l = obj.length; i &lt; l; i++) { fn.call(null, obj[i], i, obj); } } else { // Iterate over object keys for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { fn.call(null, obj[key], key, obj); } } }}/** * Accepts varargs expecting each argument to be an object, then * immutably merges the properties of each object and returns result. * * When multiple objects contain the same key the later object in * the arguments list will take precedence. * * Example: * * var result = merge({foo: 123}, {foo: 456}); * console.log(result.foo); // outputs 456 * * @param {Object} obj1 Object to merge * @returns {Object} Result of all merge properties */function merge(/* obj1, obj2, obj3, ... */) { var result = {}; function assignValue(val, key) { if (typeof result[key] === 'object' &amp;&amp; typeof val === 'object') { result[key] = merge(result[key], val); } else { result[key] = val; } } for (var i = 0, l = arguments.length; i &lt; l; i++) { forEach(arguments[i], assignValue); } return result;}/** * Function equal to merge with the difference being that no reference * to original objects is kept. * * @see merge * @param {Object} obj1 Object to merge * @returns {Object} Result of all merge properties */function deepMerge(/* obj1, obj2, obj3, ... */) { var result = {}; function assignValue(val, key) { if (typeof result[key] === 'object' &amp;&amp; typeof val === 'object') { result[key] = deepMerge(result[key], val); } else if (typeof val === 'object') { result[key] = deepMerge({}, val); } else { result[key] = val; } } for (var i = 0, l = arguments.length; i &lt; l; i++) { forEach(arguments[i], assignValue); } return result;}/** * Extends object a by mutably adding to it the properties of object b. * * @param {Object} a The object to be extended * @param {Object} b The object to copy properties from * @param {Object} thisArg The object to bind function to * @return {Object} The resulting value of object a */function extend(a, b, thisArg) { forEach(b, function assignValue(val, key) { if (thisArg &amp;&amp; typeof val === 'function') { a[key] = bind(val, thisArg); } else { a[key] = val; } }); return a;}module.exports = { isArray: isArray, isArrayBuffer: isArrayBuffer, isBuffer: isBuffer, isFormData: isFormData, isArrayBufferView: isArrayBufferView, isString: isString, isNumber: isNumber, isObject: isObject, isUndefined: isUndefined, isDate: isDate, isFile: isFile, isBlob: isBlob, isFunction: isFunction, isStream: isStream, isURLSearchParams: isURLSearchParams, isStandardBrowserEnv: isStandardBrowserEnv, forEach: forEach, merge: merge, deepMerge: deepMerge, extend: extend, trim: trim};","link":"/2019/08/08/JAVASCRIPT/JS%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/"},{"title":"JS的数据类型和判断","text":"JS是弱类型语言JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据： 123var foo = 42; // foo is a Number nowfoo = &quot;bar&quot;; // foo is a String nowfoo = true; // foo is a Boolean now 数据类型JavaScript的数据类型分为两类：原始类型（primitive type）和对象类型（object type）。tip：对象类型也称之为引用类型 最新的 ECMAScript 标准定义了 8 种数据类型: 7种原始类型： Boolean Null Undefined Number Bigint String Symbol 和 Object 原始类型除 Object 以外的所有类型都是不可变的（值本身无法被改变）。例如，与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）。我们称这些类型的值为“原始值”。 布尔类型布尔类型表示一个逻辑实体，可以有两个值：true 或 false Null类型Null 类型只有一个值：null,更多详情可查看 null Undefined类型一个没有被赋值的变量会有个变量undefined,更多详情可查看 undefined 数字类型根据 ECMAScript标准,JavaScript中只有一种数字类型：基于 IEEE 754标准的双精度64位二进制格式的（-(2^63 -1) 到 2^63 -1）。它并没有为整数给出一种特定的类型。 除了能够表示浮点数外，还有一些带符号的值: +Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。 要检查是否大于或小于 +/-Infinity，你可以使用常量 Number.MAX_VALUE 和 Number.MIN_VALUE。另外在 ECMAScript 6中，你可以通过 Number.isSafeInteger() 方法还有 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 来检查值是否在双精度浮点数的取值范围。超出这个范围，JavaScript 中的数字不再安全了，也就是只有 second mathematical interger 可以在 JavaScript 数字类型中正确表现。 BigInt类型BigInt类型是JavaScript中的一个基础的数值类型，可以用任意精度表示整数。使用BigInt，您可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。BigInt是通过整数末尾附加 n 或调用构造函数来实现的。 通过使用常量Number.MAX_VALUE，您可以获得可以用数字递增的最安全的值。通过引入 BigInt，您可以操作超过Number.MAX_VALUE的数字。您可以在下面的示例中观察到这一点，其中递增Number.MAX_VALUE会返回预期的结果: 1234&gt; const x = 2n ** 53n;9007199254740992n&gt; const y = x + 1n; 9007199254740993n 可以对BigInt使用运算符+、*、-、**和%，就像对数字一样。BigInt 严格来说并不等于一个数字，但它是松散的。 在将BigInt转换为Boolean时，它的行为类似于一个数字：if、||、&amp;&amp;、Boolean 和!。 BigInt不能与数字互换操作。否则，将抛出TypeError。 字符串类型JavaScript的字符串类型用于文本数据。它是一组16位的无符号整数值的”元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个索引是1，以此类推。字符串的长度是它的元素数量。 不同于类 C 语言，JavaScript 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对原始字符串的操作来创建新的字符串。例如： 获取一个字符串的子串可通过选择个别字母或者使用 String.substr(). 两个字符串的连接使用连接操作符 (+) 或者 String.concat(). 符号类型(Symbol)符号(Symbols)是ECMAScript 第6版新定义的。符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值(如下). 在某些语言当中也有类似的原子类型(Atoms). 你也可以认为为它们是C里面的枚举类型.更多细节请看Symbol 。 类型判断函数 typeof、instanceof、constructor、Object.prototype.toStringtypeof 操作符返回一个字符串，表示未经计算的操作数的类型。语法 12typeof operandtypeof(operand) 下面通过大量栗子来说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 数值typeof 37 === 'number';typeof 3.14 === 'number';typeof(42) === 'number';typeof Math.LN2 === 'number';typeof Infinity === 'number';typeof NaN === 'number'; // 尽管它是 &quot;Not-A-Number&quot; (非数值) 的缩写typeof Number(1) === 'number'; // Number 会尝试把参数解析成数值typeof 42n === 'bigint';// 字符串typeof '' === 'string';typeof 'bla' === 'string';typeof `template literal` === 'string';typeof '1' === 'string'; // 注意内容为数字的字符串仍是字符串typeof (typeof 1) === 'string'; // typeof 总是返回一个字符串typeof String(1) === 'string'; // String 将任意值转换为字符串，比 toString 更安全// 布尔值typeof true === 'boolean';typeof false === 'boolean';typeof Boolean(1) === 'boolean'; // Boolean() 会基于参数是真值还是虚值进行转换typeof !!(1) === 'boolean'; // 两次调用 ! (逻辑非) 操作符相当于 Boolean()// Symbolstypeof Symbol() === 'symbol';typeof Symbol('foo') === 'symbol';typeof Symbol.iterator === 'symbol';// Undefinedtypeof undefined === 'undefined';typeof declaredButUndefinedVariable === 'undefined';typeof undeclaredVariable === 'undefined'; // 对象typeof {a: 1} === 'object';// 使用 Array.isArray 或者 Object.prototype.toString.call// 区分数组和普通对象typeof [1, 2, 4] === 'object';typeof new Date() === 'object';typeof /regex/ === 'object'; // 历史结果请参阅正则表达式部分// 下面的例子令人迷惑，非常危险，没有用处。避免使用它们。typeof new Boolean(true) === 'object';typeof new Number(1) === 'object';typeof new String('abc') === 'object';// 函数typeof function() {} === 'function';typeof class C {} === 'function'typeof Math.sin === 'function'; 特殊情况 null 12// JavaScript 诞生以来便如此typeof null === 'object'; 用 new 操作符 12345678910// 除 Function 外的所有构造函数的类型都是 'object'var str = new String('String');var num = new Number(100);typeof str; // 返回 'object'typeof num; // 返回 'object'var func = new Function();typeof func; // 返回 'function' 语法中的括号 12345// 括号有无将决定表达式的类型。var iData = 99;typeof iData + ' Wisen'; // 'number Wisen'typeof (iData + ' Wisen'); // 'string' 正则表达式对正则表达式字面量的类型判断在某些浏览器中不符合标准： 12typeof /s/ === 'function'; // Chrome 1-12 , 不符合 ECMAScript 5.1typeof /s/ === 'object'; // Firefox 5+ , 符合 ECMAScript 5.1 es6的let、constECMAScript 2015 之前，typeof 总能保证对任何所给的操作数返回一个字符串。即便是没有声明的标识符，typeof 也能返回 ‘undefined’。使用 typeof 永远不会抛出错误。 但在加入了块级作用域的 let 和 const 之后，在其被声明之前对块中的 let 和 const 变量使用 typeof 会抛出一个 ReferenceError。块作用域变量在块的头部处于“暂存死区”，直至其被初始化，在这期间，访问变量将会引发错误。 123456789typeof undeclaredVariable === 'undefined';typeof newLetVariable; // ReferenceErrortypeof newConstVariable; // ReferenceErrortypeof newClass; // ReferenceErrorlet newLetVariable;const newConstVariable = 'hello';class newClass{}; 例外当前所有的浏览器都暴露了一个类型为 undefined 的非标准宿主对象 document.all。 1typeof document.all === 'undefined'; 尽管规范允许为非标准的外来对象自定义类型标签，但它要求这些类型标签与已有的不同。document.all 的类型标签为 ‘undefined’ 的例子在 Web 领域中被归类为对原 ECMA JavaScript 标准的“故意侵犯”。 instanceofinstanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 语法 1object instanceof constructor 123456789101112function Car(make, model, year) { this.make = make; this.model = model; this.year = year;}var auto = new Car('Honda', 'Accord', 1998);console.log(auto instanceof Car);// expected output: trueconsole.log(auto instanceof Object);// expected output: true 1234567[] instanceof Array; //true[] instanceof Object; //truenew Date() instanceof Date;//truenew Date() instanceof Object;//truefunction Person(){};new Person() instanceof Person;//truenew Person() instanceof Object;//true 我们发现，虽然 instanceof 能够判断出 [] 是Array的实例，但它认为 [] 也是Object的实例，为什么呢？我们来分析一下[]、Array、Object 三者之间的关系: 从instanceof 能够判断出 [].proto 指向 Array.prototype，而 Array.prototype.proto 又指向了Object.prototype，Object.prototype.proto 指向了null,标志着原型链的结束。因此，[]、Array、Object就形成了如下图所示的一条原型链： 从原型链可以看出，[] 的 proto 直接指向Array.prototype, 间接指向Object.prototype, 所以按照 instanceof 的判断规则，[] 就是Object的实例。 注意:instanceof运算符只能用于对象，不适用原始类型的值。 123'hello' instanceof String // falsenull instanceof Object // falseundefined instanceof Object // false 字符串、null和undefined不是对象，所以返回false。 constructorconstructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。 12var f = new F();f.constructor === F;// true 但是 constructor 属性易变，不可信赖，这个主要体现在自定义对象上，当开发者重写prototype后，原有的constructor会丢失。 123456function F() {}F.prototype = { _name: 'Eric',};var f = new F();f.constructor === F; // false 因此，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写。 1234567function F() {}F.prototype = { constructor: F, // 重新赋值 _name: 'Eric',};var f = new F();f.constructor === F; // true Object.prototype.toStringtoString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object,xxx],xxx是具体的数据类型，其中包括：String,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument,…基本上所有对象的类型都可以通过这个方法获取到。 123456789101112Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object Window] 需要注意的是，必须通过Object.prototype.toString.call来获取，而不能直接 new Date().toString(), 从原型链的角度讲，所有对象的原型链最终都指向了Object, 按照JS变量查找规则，其他对象应该也可以直接访问到Object的toString方法，而事实上，大部分的对象都实现了自身的toString方法，这样就可能会导致Object的toString被终止查找，因此要用call来强制执行Object的toString方法。 总结 typeof可以准确地判断出基本类型，但是对于引用类型除 function 之外返回的都是 object； 已知是引用类型的情况可以选用 instanceof 或 constructor 方法进行具体类型的判断： instanceof 是基于原型链的； constructor 属性易变，不可信赖，为了规范，在重写对象原型时一般都需要重新给constructor赋值，以保证实例对象的类型不被改写； Object.prototype.toString.call() 简单粗暴","link":"/2019/10/24/JAVASCRIPT/JS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%A4%E6%96%AD/"},{"title":"用 javascript 实现一个函数 parseUrl(url)，将一段 url字符串解析为 Object","text":"非常巧妙地利用了 a 标签的属性12345678910111213141516171819202122232425262728293031/** * 将 url转换为 Object对象 * @param {*} url */function parseUrl(url) { var a = document.createElement('a'); a.href = url; return { source: url, protocol: a.protocol.replace(':', ''), host: a.hostname, port: a.port, query: a.search, params: (() =&gt; { var ret = {}, querys = []; var searchQuery = a.search.replace(/^\\?/, '').split('&amp;'); for (var i = 0; i &lt; searchQuery.length; i++) { if (searchQuery[i]) { querys = searchQuery[i].split('='); ret[querys[0]] = querys[1]; } } return ret; })(), file: (a.pathname.match(/\\/([^\\/?#]+)$/i) || [, ''])[1], hash: a.hash.replace('#', ''), path: a.pathname.replace(/^([^\\/])/, '/$1'), relative: (a.href.match(/tps?:\\/\\/[^\\/]+(.+)/) || [, ''])[1], segments: a.pathname.replace(/^\\//, '').split('/') };} 通过console.dir()打印结果出来可得 疑问，为什么创建 a 标签设置href 可以解析URL呢？简单逻辑：URL解析器自动解析获得对应的URL属性 这里涉及到浏览器解析页面的过程：浏览器在解析HTML文档时无论按照什么顺序，主要有三个过程： HTML解析 JS解析 URL解析每个解析器负责HTML文档中各自对应部分的解析工作。下面以一篇HTML文档解析来简单的讨论下解析器如何协同工作的。 首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。每个解析过程中也有许多细节，下面再做具体讨论。 各个解析器的基本概念HTML字符实体：在呈现HTML页面时，针对某些特殊字符如“&lt;”或”&gt;”直接使用，浏览器会误以为它们标签的开始或结束，若想正确的在HTML页面呈现特殊字符就需要用到其对应的字符实体。 字符实体是一个预先定义好的转义序列，它定义了一些无法在文本内容中输入的字符或符号。字符实体以&amp;开头+预先定义的实体名称，以分号结束，如“&lt;”的实体名称为&lt; 或以&amp;开头+#符号以及字符的十进制数字，如”&lt;”的实体编号为<，字符都是有实体编号的但有些字符没有实体名称。 JavaScript编码：最常用的如“\\uXXXX”这种写法为Unicode转义序列，表示一个字符，其中xxxx表示一个16进制数字，如”&lt;” Unicode编码为“\\u003c”。 URL编码：%加字符的ASCII编码对于的2位16进制数字，如”/”对应的URL编码为%2f。 URL解析器: 不能对协议类型进行任何的编码操作&lt;a href=&quot;javascript: alert(1)&quot;&gt;&lt;/a&gt;href 里面的 javascript: xxx中的 javascript： 表示协议类型 解答URL 解析器会对a标签中的href的属性进行解析，获取对应URL的属性，不需要自己手动进行解析了。 重要参考链接，具体详细的例子和原理参考链接: 浅谈XSS—字符编码和浏览器解析原理参考链接: 深入浅出浏览器渲染原理","link":"/2019/10/29/JAVASCRIPT/%E7%94%A8-javascript-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0-parseUrl-url-%EF%BC%8C%E5%B0%86%E4%B8%80%E6%AE%B5-url%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E4%B8%BA-Object/"},{"title":"谈谈自己对JS事件循环(Event Loop)的认识","text":"前言JavaScript 从设计之初，就是一门单线程非阻塞脚本语言。这是由其最初的用途来决定的：与浏览器交互。 单线程是必须的，试想一下，如果JavaScript的多线程的。那么如果有两个线程同时操作了相同的DOM，一个线程是进行动态添加样式class，而另一个线程则是要进行删除DOM。那么此时该如何处理？所以，JavaScript的单线程是必须的，也是必要的。 单线程的执行原理单线程，意味着JavaScript代码在执行的任何时候，都只有一个主线程来处理所有任务。 所有同步任务都在主线程上执行，形成一个执行栈 当代码执行异步的代码的时候，会有一个任务队列进行接收。当异步任务有了结果，在任务队列放置一个事件 当执行栈所有任务跑完之后，就JS就会读取任务队列，看看里面有哪些事件。然后先执行”宏任务(macro task)”之后，在执行”微任务(micro task)” 在浏览器环境中，常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate；常见的 micro task 有 MutationObsever 和 Promise.then","link":"/2019/08/12/JAVASCRIPT/%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop-%E7%9A%84%E8%AE%A4%E8%AF%86/"},{"title":"小程序填坑之路","text":"不久前,因为BOSS端的要求,跑去写小程序,然后边学边做,其中遇到不少的坑,记录下来方便以后查询并分享,碰更多会同步更新 路由巨坑请大家认认真真并理解小程序的路由官方文档: https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html 1、wx.navigateTo(OBJECT) 效果: 保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。 ** 注意 ** :因为小程序路由限制,这个方法最多可以跳转五个页面,超过五个不能跳转,并且不会给任何错误提示。不问为什么我会知道 所以,在项目开始进行设计UI和交互的时候,必须考虑到这方面,这也是为什么市面上很多的小程序的交互都会太多复杂的原因。2、官方Tips 这些Tips都使用路由的时候都会有用,在相应文档的下面会有。这里贴出来增加记忆 navigateTo, redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 调用页面路由带的参数可以在目标页面的onLoad中获取。 组件1、scroll-view 理论上如果你想做滚动的效果,最好都使用scroll-view来进行操作 点击跳转scroll-view文档 竖向滚动小程序的竖向滚动,会有一个巨丑巨大的黑色滚动条,需要在app.wxss里面添加(app.wxss是小程序的公共样式文件)一个样式 123456/*app.wxss*/::-webkit-scrollbar { width: 0; height: 0; color: transparent;} 下面是效果对比图:2、横向滚动看到有人将scroll-top属性用在了 scroll-x=true 的 scroll-view 组件上，问题显而易见scroll-top=”10”设置竖向滚动条位置scroll-x=”true” 设置组件横向滚动自己写了一个横向滚动的scroll-view scroll-x=true的组件，但是死活不滚动（我顶你个肺啊） 123456789101112131415161718&lt;scroll-view scroll-x=&quot;true&quot; style=&quot;background:black;height:110px; white-space: nowrap;&quot;&gt; &lt;view style=&quot;background: red; width: 200px; height: 100px; display: inline-block;&quot;&gt;&lt;/view&gt; &lt;view style=&quot;background: green; width: 200px; height: 100px; display: inline-block;&quot;&gt;&lt;/view&gt; &lt;view style=&quot;background: blue; width: 200px; height: 100px; display: inline-block;&quot;&gt;&lt;/view&gt; &lt;view style=&quot;background: yellow; width: 200px; height: 100px; display: inline-block;&quot;&gt;&lt;/view&gt;&lt;/scroll-view&gt;* height:110px;：scroll-view 容器高度要设置，不然你的view无论设置多高，都只有一点点高度* width: 200px; height: 100px; 内部的view必须要设置宽高，不然是不现实的哦* white-space: nowrap; white-space 属性设置如何处理元素内的空白 normal 默认。规定段落中的文本不进行换行,空白会被浏览器忽略。 pre 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到br 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 inherit 规定应该从父元素继承 white-space 属性的值。* display: inline-block;:应用此特性的元素呈现为内联对象，周围元素保持在同一行 效果图: 关于this的作用域很多小程序的API都一个success和fail的回调,类似于这种 123456789wx.showActionSheet({ itemList: ['A', 'B', 'C'], success: function(res) { console.log(this.data.show); // this.data is undfined }, fail: function(res) { console.log(res.errMsg) }}); 如果你直接回调里面直接调用this作用域已经改变了,属于wx这个对象的作用,所以想要调用组件的this,在外面声明一个变量保存即可，所以在调用小程序所有有关的这些API,都需要注意个问题。 123456789101112const that = this;wx.showActionSheet({ itemList: ['A', 'B', 'C'], success: function(res) { // console.log(this.data.show); // this.data is undfined console.log(that.data.show); }, fail: function(res) { console.log(res.errMsg) }}); 事件参数的获取小程序的事件绑定函数不能传递参数,如果需要传递参数,则需要在绑定事件的标签里面添加data-xxx自定义属性example: 1234&lt;view bindtap=&quot;getDataParam&quot; data-sn=&quot;201801020304&quot;&gt; 绑定函数&lt;/view&gt; 1234getDataParam: function(e) { const sn = e.currentTarget.dataset; console.log(sn);} 自定义组件Component的样式如何继承全局的样式小程序新增了自定义组件,极大增强了组件开发,但是每个人自定义组件有单独的作用域。因此,wxss的样式不受全局的控制。但是,在某些的场景还是有很有必须要继承全局某一个样式的。可以利用Compnen的texternalClasses来实现 Component自定义组件为 customSize 123&lt;view class=&quot;text-wrapper text-size&quot;&gt; 样式会外部的text-size的影响&lt;/view&gt; 123Component({ externalClasses:['text-size']}); app.wxss 1234567891011.small { font-size: 12px;}.meduim { font-size: 18px;}.large { font-size: 26px;} 在你需要的组件引用 12345{ &quot;usingComponents&quot;: { &quot;customSize&quot;: &quot;对应的路径&quot; }} 123&lt;customSize text-size=&quot;small&quot;&gt;&lt;/customSize&gt;&lt;customSize text-size=&quot;meduim&quot;&gt;&lt;/customSize&gt;&lt;customSize text-size=&quot;large&quot;&gt;&lt;/customSize&gt; 组件如何实现传递数据截止我在2018.4.12开完小程序位置,我都没有发现有类似redux,vuex等像这种能清晰控制共享数据的传递和保存的。所以,我个人利用路由和localStroage完成一步,虽然不够优雅。 1.第一种情况,只需要传递少数参数 这种适合需要传递1~3个的参数,另一个组件接受参数并调用API获取的时候,可以路由API来进行传递example: 123456789101112传递参数的组件wx.navigateTo({ url: 'test?id=1'});wx.redirectTo({ url: 'test?id=1'});wx.reLaunch({ url: 'test?id=1'}) 然后再跳转的组件onLoad钩子里面获取即可 12345678910onLoad: function(options) { console.log(options); // AJXA请求 wx.request({ url: url. data: { } });} 会每次都请求数据 注意: 如果在onLoad钩子里面初始化数据,只会调用一次,但是如果是通过路由传递参数,options会实时更新并起作用。 2.需要传递大量的数据这种时候,我也想不出更好的办法了,只能存到本地,并优化一下了。 12345678910111213141516171819// 存储数据的组件wx.setStorage({ key: yourkey, data: yourdata});// 获取数据的组件wx.getStroage({ key: yourkey, success: function(res) { console.log(res); }});onUnload: function() { // 生命周期函数--监听页面卸载// 在组件卸载remove掉,防止数据存储过多导致混乱wx.removeStorage({ key: yourkey, data: yourdata});","link":"/2018/04/10/Mini/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A1%AB%E5%9D%91%E4%B9%8B%E8%B7%AF/"},{"title":"微信小程序左滑效果","text":"html1234567&lt;view class=&quot;container&quot;&gt; &lt;view class=&quot;touch-item {{item.isTouchMove ? 'touch-move-active' : ''}}&quot; data-index=&quot;{{index}}&quot; bindtouchstart=&quot;touchstart&quot; bindtouchmove=&quot;touchmove&quot; wx:for=&quot;{{items}}&quot; wx:key=&quot;{{index}}&quot;&gt; &lt;view class=&quot;content&quot;&gt;{{item.content}}&lt;/view&gt; &lt;view class=&quot;del&quot; catchtap=&quot;del&quot; data-index=&quot;{{index}}&quot;&gt;删除&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; CSS12345678910111213141516171819202122232425262728293031323334353637.touch-item { font-size: 14px; display: flex; justify-content: space-between; border-bottom:1px solid #ccc; width: 100%; overflow: hidden}.content { width: 100%; padding: 10px; line-height: 22px; margin-right:0; -webkit-transition: all 0.4s; transition: all 0.4s; -webkit-transform: translateX(90px); transform: translateX(90px); margin-left: -90px}.del { background-color: orangered; width: 90px; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #fff; -webkit-transform: translateX(90px); transform: translateX(90px); -webkit-transition: all 0.4s; transition: all 0.4s;}.touch-move-active .content,.touch-move-active .del { -webkit-transform: translateX(0); transform: translateX(0);} JS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var app = getApp()Page({ data: { items: [], startX: 0, //开始坐标 startY: 0 }, onLoad: function () { for (var i = 0; i &lt; 10; i++) { this.data.items.push({ content: i + &quot; 向左滑动删除哦,向左滑动删除哦,向左滑动删除哦,向左滑动删除哦,向左滑动删除哦&quot;, isTouchMove: false //默认全隐藏删除 }) } this.setData({ items: this.data.items }) }, //手指触摸动作开始 记录起点X坐标 touchstart: function (e) { //开始触摸时 重置所有删除 this.data.items.forEach(function (v, i) { if (v.isTouchMove)//只操作为true的 v.isTouchMove = false; }) this.setData({ startX: e.changedTouches[0].clientX, startY: e.changedTouches[0].clientY, items: this.data.items }) }, //滑动事件处理 touchmove: function (e) { var that = this, index = e.currentTarget.dataset.index,//当前索引 startX = that.data.startX,//开始X坐标 startY = that.data.startY,//开始Y坐标 touchMoveX = e.changedTouches[0].clientX,//滑动变化坐标 touchMoveY = e.changedTouches[0].clientY,//滑动变化坐标 //获取滑动角度 angle = that.angle({ X: startX, Y: startY }, { X: touchMoveX, Y: touchMoveY }); that.data.items.forEach(function (v, i) { v.isTouchMove = false //滑动超过30度角 return if (Math.abs(angle) &gt; 30) return; if (i == index) { if (touchMoveX &gt; startX) //右滑 v.isTouchMove = false else //左滑 v.isTouchMove = true } }) //更新数据 that.setData({ items: that.data.items }) }, /** * 计算滑动角度 * @param {Object} start 起点坐标 * @param {Object} end 终点坐标 */ angle: function (start, end) { var _X = end.X - start.X, _Y = end.Y - start.Y //返回角度 /Math.atan()返回数字的反正切值 return 360 * Math.atan(_Y / _X) / (2 * Math.PI); }, //删除事件 del: function (e) { this.data.items.splice(e.currentTarget.dataset.index, 1) this.setData({ items: this.data.items }) }})","link":"/2018/03/28/Mini/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B7%A6%E6%BB%91%E6%95%88%E6%9E%9C/"},{"title":"微信小程序跨页面通信解决思路 (转载)","text":"宏观上，微信小程序是由一个个 Page 组成的。有时候我们会遇到一些业务存在耦合的 Page，一个 Page 里某个状态改变后，相关 Page 的状态需要进行更新。而在小程序里，每个 Page 都是一个模块，有着独立的作用域，因此 Page 间需要有一种通信策略。 想象一个业务场景，用户首先进入订单列表页。然后点击其中一个订单，进入到订单详情页。当用户在订单详情页对订单进行操作，例如支付、确认收货等时，该订单的状态就会发生改变。此时需要对上一级的订单列表页中该订单的状态进行更新： 要想更新订单列表页的视图层，就需要调用该 Page 对象的 setData 方法。这里为大家列举三种比较常用的方案： 设置标志位最简单的方法，在订单详情页对订单的操作成功回调中，把一些标志位设置为 true，并设置好参数（标志位和参数可以存在 localStorage 或挂在全局 App 对象下）。然后每次在订单列表页的 onShow 生命周期中，根据这些标志位去判断是否进行更新、更新的参数是什么。 这种处理在业务逻辑比较简单、页面间的耦合度很小时还能凑合，一旦逻辑复杂起来，就需要写很多冗余的代码，并且维护成本会非常高。 流程图： 利用页面栈获取 Page 对象如果订单详情页里能拿到订单列表页的 Page 对象，就能去调用它的 setData 方法。小程序提供了一个方法 getCurrentPages，执行它可以得到当前页面栈的实例，然后再根据页面进栈的顺序我们就能拿到订单列表页的 Page 对象。 然而这种做法的缺点还是耦合度太大，过度依赖页面进栈顺序。一旦在以后的产品迭代中页面顺序发生变化，将很难去维护。 流程图：上述两种方法都存在着耦合度大、维护困难的问题，而利用发布／订阅模式能很好的实现解耦，下面我们先来了解一下这种设计模式。 发布／订阅模式（最优方案）发布／订阅模式由一个发布者、多个订阅者以及一个调度中心所组成。订阅者们先在调度中心订阅某一事件并注册相应的回调函数，当某一时刻发布者发布了一个事件，调度中心会取出订阅了该事件的订阅者们所注册的回调函数来执行。 在发布／订阅模式中，订阅者和发布者并不需要关心对方的状态，订阅者只管订阅事件并注册回调、发布者只管发布事件，其余一切交给调度中心来调度，从而能实现解耦。 在 app 跨页面通信这个问题上，iOS 端的 Notification Center、安卓端的 EventBus，也是通过这样一种设计模式去解决的，不过微信小程序内部并没有提供这种事件通知机制，所以我们需要手动去实现一个。 我们首先要实现一个 Event 类，它应该含有一个收集回调函数的对象，和提供三个基础方法：on（订阅）、 emit（发布）、 off（注销）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//event.jsclass Event { on (event, fn, ctx) { if (typeof fn != &quot;function&quot;) { console.error('fn must be a function') return } this._stores = this._stores || {} ;(this._stores[event] = this._stores[event] || []).push({cb: fn, ctx: ctx}) } emit (event) { this._stores = this._stores || {} var store = this._stores[event], args if (store) { store = store.slice(0) args = [].slice.call(arguments, 1) for (var i = 0, len = store.length; i &lt; len; i++) { store[i].cb.apply(store[i].ctx, args) } } } off (event, fn) { this._stores = this._stores || {} // all if (!arguments.length) { this._stores = {} return } // specific event var store = this._stores[event] if (!store) return // remove all handlers if (arguments.length === 1) { delete this._stores[event] return } // remove specific handler var cb for (var i = 0, len = store.length; i &lt; len; i++) { cb = store[i].cb if (cb === fn) { store.splice(i, 1) break } } return } } 具体调用方法App 是小程序的实例，在每个 Page 里都能通过执行 getApp 函数获取到它。我们可以把 Event 类的实例挂载在 App 中，方便每个 Page 去调用。 1234567// app.jsconst Event = require('./libs/event')App({ event: new Event()}) 订单列表页在 onLoad 生命周期中订阅 “afterPaySuccess” 事件。 123456789101112//order_list.jsvar app = getApp()Page({ onLoad: function(){ app.event.on('afterPaySuccess', this.afterPaySuccess, this) }, afterPaySuccess: function(orderId) { },}) 在订单详情页支付成功的回调中，发布 “afterPaySuccess” 事件,同时带上订单 id 参数 123456789//order_detail.jsvar app = getApp()Page({ raisePayment: function() { app.event.emit('afterPaySuccess', orderId) }}) 所有 Page 的 onUnload 生命周期，必须注销掉之前订阅的事件。注销方法 off 的调用姿势有三种，不过还是建议注销当前 Page 所订阅的事件，而不是注销所有的。 123456789101112var app = getApp()Page({ onUnload: function(){ // remove all app.event.off() // remove all callbacks app.event.off('afterPaySuccess') // remove specific callbacks app.event.off('afterPaySuccess', this.afterPaySuccess) }})","link":"/2019/07/22/Mini/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B7%A8%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF/"},{"title":"React Native 编译两套代码的原理","text":"渲染UI 如果我们在程序中调用了 React Native 提供的 API，那么 React Native 框架就通过 Bridge 调用原生框架中的方法。 因为 React Native 的底层为 React 框架，所以如果是 UI 层的变更，那么就映射为虚拟 DOM 后进行 diff 算法，diff 算法计算出变动后的 JSON 映射文件， 由 Native 层将此 JSON 文件映射渲染到原生 App 的页面元素上，实现了在项目中只需要控制 state 以及 props 的变更来引起 iOS 与 Android 平台的 UI 变更。 编写的 React Native代码最终会打包生成一个 main.bundle.js 文件供 App 加载，此文件可以在 App 设备本地，也可以存放于服务器上供 App 下载更新 React Native 与原生平台通信在与原生框架通信中，React Native 采用了 JavaScriptCore 作为 JS VM，中间通过 JSON 文件与 Bridge 进行通信。而如果在使用 Chrome 浏览器进行调试时，那么所有的 JavaScript 代码都将运行在 Chrome 的 V8 引擎中，与原生代码通过 WebSocket 进行通信。","link":"/2019/08/15/REACT/React-Native-%E7%BC%96%E8%AF%91%E4%B8%A4%E5%A5%97%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86/"},{"title":"论React-Native如何搭建以离线APP优先的项目","text":"![React Native] (http://ww2.sinaimg.cn/large/006tNc79gy1g5tkjro6ibj30zk0k00ue.jpg) 前言 长久以来，在开发移动端应用（包括 Web 应用，以下简称「应用」）时，我们习惯性地将「离线」当作一种错误来对待。作为应用的创建者，我们在越来越稳定和快速的办公网络下设计和开发着这些应用，渐渐地对那些做不到时刻在线的用户们失掉了同理心。实际上这些「掉了线」的用户离我们并不远，他们也许是通勤路上不得不挤进没有信号的地铁中的上班族，也许是喜欢拿着手机跑进 Wi-Fi 鞭长莫及的厕所蹲马桶的游戏玩家。他们在我们身边，他们就是我们。来自 《Redis 入门指南》作者 李子骅 luin 拥抱离线优先 公司的产品的因为地区，在某种情况下，无法连接网络。必须使用APP的某功能，为保证一线业务人员的工作能正常运行。提供离线的功能，对我司的产品来说意义重大。为了满足这些复杂而又琐碎的离线需求。我们最终确定了 离线优先 的开发模式。 离线不是一种错误，在线则是一种特性 离线优先指的是开发应用时以离线为目标场景，同时针对联网的情况增加额外的功能。就我司的产品而言，我们会预设用户始终处于没有网络连接的状态，并让用户能够在这个状态下可以正常地使用大部分功能。同时，当联网后，我们额外为用户提供离线同步等功能。 数据先修改后同步无论是否在线，我们都默认用户处于离线的状态。用户对数据的所有修改都是直接写入到本地数据中（即使当前是联网状态）并实时得到反馈，应用会在后台通过独立的组件定时将这些修改和服务器进行同步。所以,我们应该同一个地方进行数据的保存和维护。所以，我们在决定引入react-redux。 每个对应的模块，都封住单独封装一个 reducer 和 action,并引入 redux-logger 插件,方便检测和调试数据的变化 需要进行离线的功能，通过react-redux来进行 actions来进行操作，酱紫就能进行统一在一个地方进行操作，在后期维护时，也能够快速进行定位和排查问题。 Redux Offline对于项目使用了 redux 数据管理的项目而言，最快捷的办法，就是使用 redux-offline，其基本思路是通过 redux middleware 监听每次 acton 数据变化，然后将需要离线的数据序列化到本地，等下一次刷新页面时，优先从本地还原数据还原到 store 中。这种方案的好处是快速配置需要缓存的 API 接口到中间件即可，充分结合了 redux 特性，对于想要达到简单优先展示离线数据的应用而言，是非常不错的。 统一数据格式, normalizr所有数据都存储Redux的Store，那么我们不能随随便便的把离线需要更新的数据进行粗暴的存储到Store里面，从API，获取数据的时候的 通过 normalizr 进行统一个规范序列化，酱紫大大方便了，可以很清晰地了解数据的结构了。 未 normalizr 1234567891011121314151617{ &quot;id&quot;: &quot;123&quot;, &quot;author&quot;: { &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;Paul&quot; }, &quot;title&quot;: &quot;My awesome blog post&quot;, &quot;comments&quot;: [ { &quot;id&quot;: &quot;324&quot;, &quot;commenter&quot;: { &quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;Nicole&quot; } } ]} 1234567891011121314151617import { normalize, schema } from 'normalizr';// Define a users schemaconst user = new schema.Entity('users');// Define your comments schemaconst comment = new schema.Entity('comments', { commenter: user});// Define your articleconst article = new schema.Entity('articles', { author: user, comments: [comment]});const normalizedData = normalize(originalData, article); normalizr 后 1234567891011121314151617181920{ result: &quot;123&quot;, entities: { &quot;articles&quot;: { &quot;123&quot;: { id: &quot;123&quot;, author: &quot;1&quot;, title: &quot;My awesome blog post&quot;, comments: [ &quot;324&quot; ] } }, &quot;users&quot;: { &quot;1&quot;: { &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;Paul&quot; }, &quot;2&quot;: { &quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;Nicole&quot; } }, &quot;comments&quot;: { &quot;324&quot;: { id: &quot;324&quot;, &quot;commenter&quot;: &quot;2&quot; } } }} 获取清晰结构化，如何进行保存到本地和如何更新到视图，和发送数据给后端更新，简直易如反掌了。 结语总结，离线只是一种特性，并不是一种错误 参考文章构建离线优先的 React 应用前端离线化探索","link":"/2019/08/04/REACT/%E8%AE%BAReact-Native%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%BB%A5%E7%A6%BB%E7%BA%BFAPP%E4%BC%98%E5%85%88%E7%9A%84%E9%A1%B9%E7%9B%AE/"},{"title":"Vue源码学习感悟 - 不谈源码细节，只说说方法论","text":"发现很多人，都是为了面试去学习Vue的源码，而这次我只想谈谈学习源码的方法论。 了解背景和为什么首先学习一个框架的源码，你得了解它用来解决什么问题的，比如，Vue是一个MVVM框架，就是为了解决jQuery时代，要通过一大堆API去操作视图，项目一旦达到一定的程序，只会越来越发复杂，而Vue则是为这样的问题解决而诞生的。 举一个简单的例子 jQuery1234&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt;$('#app').html = 'Hello World!'&lt;/script&gt; Vue12345678910111213&lt;div id=&quot;app&quot;&gt;{{ message }}&lt;/div&gt;&lt;script&gt;export default { data() { return { message: 'Hello World!' } }}&lt;/script&gt; 可以明显地看出，如果用jQuery，则需要通过特定的API去操作视图，才能使视图发生变化。Vue，则统一在 data函数 赋值变量，然后用两个大括号在视图绑定即可。 这里两个例子可能太简单，同学们感受不到。下面放两张稍微复杂的Demo，一个是jQuery，一个是Vue，不用太在意图中的细节，只需要了解到，jQuery在处理操作视图需要调用大量的API，然后随着项目的增加，里面逻辑越来越复杂即可，Vue则相反。 好了，搞清楚了目的，接下就是了解它的核心思想和功能了，这样子，无论在通过视频学习源码，还是自己打开代码自己琢磨的时候，这个框架是用来干什么的，解决什么问题我们都很清楚了，这样子我们就能有的放矢地去学习和研究。 了解核心功能既然，Vue是为了解决上述jQuery带来的问题，那么它肯定会有相应的解决方案，而 Vue 的解决方案就是 数据驱动、响应式、组件化 所谓数据驱动，是指视图是由数据驱动生成的，我们对视图的修改，不会直接操作 DOM，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM，大大简化了代码量。特别是当交互复杂的时候，只关心数据的修改会让代码的逻辑变的非常清晰，因为 DOM 变成了数据的映射，我们所有的逻辑都是对数据的修改，而不用碰触 DOM，这样的代码非常利于维护。 在 Vue.js 中我们可以采用简洁的模板语法来声明式的将数据渲染为 DOM： 123456789101112&lt;div id=&quot;app&quot;&gt; {{ message }}&lt;/div&gt;&lt;script&gt;var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }})&lt;/script&gt; 最终它会在页面上渲染出 Hello Vue Vue.js 另一个核心思想是组件化。所谓组件化，就是把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。 我们在用 Vue.js 开发实际项目的时候，就是像搭积木一样，编写一堆组件拼装生成页面。在 Vue.js 的官网中，也是花了大篇幅来介绍什么是组件，如何编写组件以及组件拥有的属性和特性。 其实前端开发最重要的 2 个工作，一个是把数据渲染到页面，另一个是处理用户交互。Vue 把数据渲染到页面的能力我们已经通过源码分析出其中的原理了，但是由于一些用户交互或者是其它方面导致数据发生变化重新对页面渲染的原理我们还未分析。 123456789101112131415161718&lt;div id=&quot;app&quot; @click=&quot;changeMsg&quot;&gt; {{ message }}&lt;/div&gt;&lt;script&gt;var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, methods: { changeMsg() { this.message = 'Hello World!' } }})&lt;/script&gt; 当我们去修改 this.message 的时候，模板对应的插值也会渲染成新的数据 出处 老黄源码分析链接 周边和社区最后，判断一个框架能不能发展起来，有一个很简单的标准，就是看它是否有周边和社区。因为只有社区不断地完善，以及周边的支持，维护它的团队才有动力去不断增加便利的功能，以及修复Bug。 总结我自己的感悟是，学习一样东西，不但学习里面的细节和熟练运行就行了，更重要的是要通过这次学习得到一个方法论。比如，我就从学习老黄的源码视频里面学到，首先你得了解一个框架解决什么问题，它解决问题的方案什么，然后才是有的放矢了解核心功能和思想，最后了解一下周边和社区，判断这个框架是否能发展起来。","link":"/2020/08/10/Vue/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F%20-%20%E4%B8%8D%E8%B0%88%E6%BA%90%E7%A0%81%E7%BB%86%E8%8A%82%EF%BC%8C%E5%8F%AA%E8%AF%B4%E8%AF%B4%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"title":"vue-cli3.0 以及 vue2.6.1，从零开始搭建一个移动UI库","text":"一直以来，我们都是长期使用 vue 的组件，反而对如何编写一个组件库的原理不懂。虽然不懂用的也很爽，但鲁迅说过：“知其然，也要知其所以然”，技术的深度就决定的薪资深度 前期准备说实话一开始并不知道如何搭建一个组件库，毫无头绪。但图突然想起，牛顿曾说过：站在巨人的肩膀上，能看得更远。作为全球最大的同性交流网站github上面，应该有许多非常优秀的组件库（巨人），为什么不进行研究参考一波呢？在观看了 vant、mint-ui、element等开源组件库后，最终决定参考 cube-ui 的项目，因为发现这个开源项目，目录结构清晰，webapck 简单，测试用例完善优雅，组件库代码简单易懂。 vue-cli3.0初始化项目在我准备搭建的创建vue组件的时候，vue-cli已经从2.0升级到3.0，但是很多开源组件库目前都是使用2.0，那么就让我试试吧！ 安装vue-cli3.0全局变量 1npm install -g @vue/cli-service-global 使用 vue serve 创建项目 1vue create hello-world 我是手动选择创建的项目的插件，Babel、Router、Vuex、CSS Pre-processors、 Linter / Formatter、Unit Testing 上面配置的作用 Babel: 可以开发的时候使用ES6等新特性，编译后可以兼容ES5 Router: 用来编写文档的路由 CSS: 支持 CSS 预处理器, 比如说：Sass（SCSS）、LESS、Stylus Linter / Formatter: 支持代码风格检查和格式化 Unit Testing: 支持单元测试 目录结构创建以及介绍 docs编写文档的目录,这里使用 vuepress example在线的例子的目录 src/common公共目录，存放 重复使用的 CSS、helpers JS(共用或者多次使用的JS函数)、mixins JS、icon 文件 src/components核心目录，各种vue组件 src/modules辅助实现全局组件以及局部的使用功能 src/index.js进行注册组件和其它操作 src/module.js在这里统一管理 modules 引入的组件 关键API搭建组件库，主要就是利用 Vue 提供的两个 API，Vue.Component 以及 Vue.use Vue.component Vue.use 有人应该会想明明已经有了 Vue.Component 注册组件，为什么还需要使用 Vue.use 呢？先让我们了解他们的使用场景 应用场景何时用 Vue.component一般用来进行全局注册组件的使用。不需要进行扩展API以及一些骚操作的时候使用，简单来说就是组件仅仅是组件。比如进行下面的操作，只需要在入口文件进行注册一次就可以在全局使用该组件了 12import HelloWorld from './components/HelloWorld'Vue.component(HelloWorld.name, HelloWorld) 在某组件上使用 12345&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;HelloWorld/&gt; &lt;/div&gt;&lt;/template&gt; 效果如下: 何时用 Vue.use插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种： (官方的介绍) 添加全局方法或者属性。如: vue-custom-element 添加全局资源：指令/过滤器/过渡等。如 vue-touch 通过全局混入来添加一些组件选项。如 vue-router 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router 简单总结一下就是：Vue.use是 Vue.component 的增强版。打个比方，Vue.use 是 Vue.component 吃了伟哥时候的状态，更强大以及… UI组件库应该具有的功能个人认为一个好的组件库，必须具备以下功能 全局注册以及局部引入 完善的单元测试和覆盖率测试 组件的简单易用的API 详细的文档以及例子 测试是一道非常重要的过程，我认为是必不可少的。在写组件库的时候，有时候写测试用例的时间，远远超过了写代码的时间。但，这些都是值得的，因为越是完善的测试用例保证项目出现Bug的可能性最少 全局注册以及局部引入思路在 modules 目录创建对应每个组件的目录，在里面进行 全局注册 以及添加 install 方法, module.js 负责容易管理所有组件的引入，index.js 则调用 Vue.use 进行插件注册 代码实现 modules 目录 某一组件全局注册以及 添加 Install 方法 1234567import ActionSheet from '../../components/action-sheet/action-sheet'ActionSheet.install = function(Vue) { Vue.component(ActionSheet.name, ActionSheet)}export default ActionSheet module.js 统一管理 总结 和 参考例子最后，为什么明明 使用 Vue.component 全局注册组件就行了，为什么还要使用 添加 install 方法以及 调用 Vue.use 呢？这个疑问曾经困扰了我很久，但后来从开源作者的角度考虑，我本身是一个组件库，肯定需要提供许多功能，所以需要“吃了伟哥”的 Vue.component也就是 Vue.use。既然最终都要 Vue.use 所以一开始在搭建组件库的时候，就用上Vue.use，方便以后扩展需要 例子在这里，请狠狠点击这里 单元测试：BDD和TDD了解BDD以及TDD，请狠狠点击这里，观看这篇文章 覆盖率测试vuepress搭建文档这个的话，貌似没什么好说的。参考vuepress即可，请狠狠点击这里 总结其实最终发现，原来一个组件其实很简单，主要是 Vue.component 以及 Vue.use 两个API在捣腾，然后像编写普通项目那样编写组件，只不过你需要考虑对外的使用性以及对内的 维护问题而已。","link":"/2020/01/14/Vue/vue-cli3-0-%E4%BB%A5%E5%8F%8A-vue2-6-1%EF%BC%8C%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%A7%BB%E5%8A%A8UI%E5%BA%93/"},{"title":"vue项目接入微信JSSDK的坑","text":"前言用于记录接入微信JS-SDK的坑，以后方便查询第一次接入公众号微信支付、分享、定位等等的坑的时候，心里是迷茫而又恐惧。因为，听说坑特别多，后来发现自己的亲身体验到了这一点。 支付的坑1、当前URL未注册 问题: 微信公众号H5调起支付时，点击支付按钮出现“当前页面的URL未注册”的提示。 解决办法:由于2017年8月1日微信官方把关于支付的信息转移到了商户平台：公众平台微信支付公众号支付授权目录、扫码支付回调URL配置入口已于8月1日迁移至商户平台（pay.weixin.qq.com ） 所以进入以下位置： 登录微信商户平台-产品中心-开发配置，配置支付授权路径。如果掉起支付的页面在 域名/pay.html中，那么就在此添加授权路径，如我的掉起支付的页面在www.weixinPay.com/pay.html 中，那么授权目录就配置为htt://www.weixinPay.com/ tip: 注意：后面的 / 一定要加上，表示该路径下的页面都可以调起微信的支付接口。 2、如果按照以上还是弹出当前URL未注册因为微信支付对spa项目的hash路由兼容还是不很好。需要加上一个 “?”如图:代码如下: 1234567891011121314watch: { $route() { this.directRightUrl() }},methods: { directRightUrl() { let { href, protocol, host, pathname, search, hash } = window.location search = search || '?' let newHref = `${protocol}//${host}${pathname}${search}${hash}` if (newHref !== href) { window.location.replace(newHref) }} 我这里是根据App.vue文件，进行路由监控。然后给每个页面都加上问号，虽然会些许性能消耗。但是方便省事，具体可以根据自己的页面适当修改。 微信JS-SDK说明文档 分享的坑根据JS-SDK的文档，很多人都是在初始化的wx配置的时候，传入的当前的URL地址不正确。然后就导致如下结果: 解决办法: 请在保证后台能正确返回初始化需要的配置参数的情况下 1234修改前:// let currentUrl = window.location.href修改后let currentUrl = window.location.href.split('#')[0] 神奇成功了开心 需要注意的几点: jsApList: [] 需要加入对应参数。比如，分享加入’onMenuShareTimeline’, ‘onMenuShareAppMessage’。具体的对应接口的参数可以参考文档 所有接口的调用，请保证在wx.ready()执行后，才调用。文档里面是这么建议的。 定位的坑刚开始定位的，内心是有点小激动的。因为觉得这个功能很高大尚，当然了这只是我个人的想法。好了~，不扯了。 同样的，给微信初始化的jsApList加入对应的参数。然后在wx.ready()函数执行，但是，发现无论如何第一次进入页面都无法成功弹出授权弹框。 后来发现，在页面完成之后。延迟一秒再进行获取定位，即可 百分百成功！坑爹有木有。代码如下 目前遇到这个三个坑，后期遇到再写上吧。痛苦的经历需要不要再有了","link":"/2018/12/13/Vue/vue%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1JSSDK%E7%9A%84%E5%9D%91/"},{"title":"什么时候该用vuex?","text":"Vuex是什么Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化官方是这么介绍的 为什么要判断什么时候使用Vuex很简单的道理，你总不能什么时候都使用Vuex吧。鲁迅说: –当你无法很好进行数据管理的时候，你才需要用Vuex 但是,使用应用场景该如何判断？我已经用vue+vuex进行起码四五个项目的编写和上线了。以下是我一些个人的判断使用场景的心得 1、当一个组件需要多次派发事件时为什么说？多次派发事件需要用到vuex?原因很简单,如果它多次派发事件,必然有其它组件进行接收并调用。如果是一个组件进行接收和调用还好,但是如果两个？三个？甚至四个呢？如果派发事件的组件只是派发一个事件,那还比较好管理,一旦进行多次派发那么维护的难度会以乘法增加 栗子: 此处的购物车的数量需要用vuex。我想很多人有疑问,what?这么简单的东西都需要vuex,来管理？容我介绍触发的场景1、在首页、分类、商品详情页添加商品需要触发一次2、在购物车进入编辑状态,删除购物车项,需要触发一次3、在结算订单时,需要触发一次在首页、分类、商品详情页、删除购物车项、结算订单总共就触发了6次用vuex的mutations的触发,控制状态的就很清晰明了,并可以维护性很高 反之,如果每次都调用获取购物车数量的接口(前提得有),效果是实现了,但是每一次的HTTP请求,都是对浏览器性能消耗。对比下来,用vuex的mutations进行触发,就显得更加有优势 以下对应触发的场景图 归根结底: 是为了以后的方便维护，你想想啊。万一你那天要改，其它四五个地方需要改动。等项目越来越大，加入购车的地方就会越来越多。保持一个设置购物车数量，那么再多的情况，你都可以清晰地那里是设置购物车数量并且需要修改去哪里修改 2、跨组件共享数据、跨页面共享数据在开发Vue项目的时候，已经发现很多次。存在这种情况封装了一个基础组件(即很多地方会用到),根据不用的业务派发不同的事件。但是发现，有时想派发事件都不行，因为父组件根本就没有引用。没有引用父组件跟获取当前派发事件，并更新数据呢？当然了，是用Vuex 栗子: 1、当前是订单列表页，订单列表也点击取消订单，然后更新对应的订单列表2、订单详情点击取消按钮，怎么更新对应的订单列表？不要说每次进入订单列表页面都重新数据，那太浪费性能这种情况也是用Vuex，state储存一个状态，监听这个状态，变化时更新对应的列表 栗子: 1、从订单结算页，进入选择优惠券的页面2、选择优惠券的页面如何保存选择的优惠券信息？3、保存到本地？也行，但不建议保存到本地，如果有人使坏就很麻烦。当然了，肯定会有那么无聊的，你不要说肯定没有。不要问为什么我会知道state保存优惠券信息，选择优惠券时，mutations提交，在订单结算页，获取选择的优惠券，并更新订单优惠信息 当然了，使用并不只有两个。但大多数情况的时候。为什么，其它情况不写下来。只是因为一时半会想不起来，而且，我也不想写了。等你把这两种之后，我觉得，是个人都能举一反三。","link":"/2018/08/10/Vue/%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E7%94%A8vuex/"},{"title":"从时间复杂度分析，为什么vue使用v-for的时候要加key","text":"面试遇到过这个问题，也没有答上来。做此记录，加深算法的时间复杂度量级上的差别。 先了解时间复杂度算法一个很重要的概念就是时间复杂度，判断算法快不快很多时候都基于这个标准去判断的。 那么时间复杂度是什么意思呢？首先看下面一道很简答的数学题 现在要求你从1加到100，算出他们的和，结果是多少呢？相信读过小学的人都算过这道题。 这里有两种解法，第一个种很简单粗暴，就是从1开始算起，1+2=3,3+3=6,6+4=10,10+5=15….以此类推，就是简单地把1和2相加的和每一个需要相加算出后的和，然后继续相加。 第二种，以首项加末项乘以项数除以2用来计算 “1+2+3+4+5+···+（n-1）+n” 的结果, 简化为 n（1+n）/2, 这样的算法被称为高斯算法。 (项数的计算方法是末项减去首项除以项差) 以从1加到100为例，就是 (1+100) * 100 / 2 = 100 + 10000 / 2 = 50 + 5000 = 5050; 这样可以非常简单算出，任何类似 从1加到100的这种等差数列了。 其中第一种方法的时间复杂度为O(n), 因为从算1和2的和开始之后，都要和每一项相加，如果需要加的数为n，那么就算了n次。 第二种方法，则是O(1), 很简单你只要判断能使用高斯算法，直接套用公式就算出结果，这里只运算了一次。 JavaScript代码例子123456789101112131415161718192021222324252627&lt;input type=&quot;number&quot; step=&quot;1000&quot; min=&quot;0&quot; id=&quot;input&quot;&gt;&lt;button id=&quot;start&quot;&gt;运行&lt;/button&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.5.0/jquery.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var $input = $('#input'); var $start = $('#start'); var endNum; $start.click(function () { endNum = parseInt($input.val()); // 简单求和 var firstNum = 1; var count = 0; console.time() for (var i = firstNum; i &lt;= endNum; i++) { count = count + i; } console.timeEnd(); // 高斯算法 console.time() count = (endNum + firstNum) * endNum / 2 console.timeEnd(); console.log('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 计算' + endNum); console.log(' '); });&lt;/script&gt; 效果如下 ： 从这里就可以看出，随着计算量的增加，简单求和的算法是运行时间是以指数级增加的，相比使用了高斯算法的运行时间相对简单求和的算法来说，是微乎其微的。 为什么vue使用v-for的时候要加key同样的vue一定要在 v-for 的时候加上 key 呢？道理也和上面想类似，因为加上key可以减少运行时间。因为vue使用了diff算法来判断那个DOM需要更新。 使用了key，变化的DOM只有一个，时间复杂度O(1)~O(n),之所以有区间是因为最坏的情况则所有数据都改变，不过在某些情况，比如只需要改变某几个DOM的时候，这种变化就很快的了，比如3个DOM需要改变，就改变DOM就行；不像用index作为key，如果变化的DOM在第一个，则所有的DOM都进行重新diff，时间复杂度为O(n)。 具体了解可以点击这里为什么使用v-for时必须添加唯一的key? 和 Virtual DOM 算法。 下面为什么使用v-for时必须添加唯一的key的关键 同样的，这也说明了为什么如果想在IT行业混得好，必须学习算法和数据结构。如果你的程序运行起来是类似于“简单求和”的程序，而别人的程序运行起来是类似于“高斯算法”的程序，结果是显而易见的。 参考链接 为什么使用v-for时必须添加唯一的key? 深度剖析：如何实现一个 Virtual DOM 算法 高斯算法 v-for为什么要加key，能用index作为key么","link":"/2020/04/15/Vue/%E4%BB%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88vue%E4%BD%BF%E7%94%A8v-for%E7%9A%84%E6%97%B6%E5%80%99%E8%A6%81%E5%8A%A0key/"},{"title":"Vue","text":"什么时候在data填写参数？created钩子同上 data 需要在观测或者在dom渲染的数据 created 创建的参数主要作用于methods,不作用于渲染 import ‘babel-polyfill’ 的作用是？ vue-cli ==&gt; Babel默认只转换新的JavaScript句法（syntax），而不转换新的API， 比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 如何处理使用vuex时候刷新后，数据消失页面的空白的现象？ 第一种情况是使用vuex共享了一个组件的某一数据或者说某一个对象的字段12345if (!this.singer.id) { this.$router.push('/singer') return } 利用router的查询字符串来传递少量的数据 localstorage 和 sessionstorage 可以存储一些关键性的数据，exp: 登陆的token 重复利用很多次的组件可以在APP.vue里面渲染邻檬圈: login.vue组件在 个人中心,我常买,购物车,我的订单等一些东西都有用到,所以应该在APP.vue渲染出来,这样子就不用每次都improt一次 不要重复利用业务的组件，可以利用创建一个base组件，然后在创建几个业务组件即可因为，如果共用一个组件，会很难进行重复利用。前期已一两个业务混合在一次还好。但，一旦多起来。exp: 线下收银系统的报表就是，因为进行这样的重复利用。所以，出现非常复杂的业务，和非常复杂的代码。 base目录的组件base 的组件，不应该处理业务逻辑，派发出去即可，让业务用业务组件来处理。基础组件，应该保持统一性，不受其它组件的影响。 如何只单独阻止子元素的事件冒泡有一些必要场景,子元素绑定了点击事件。想在父元素上组件事件的冒泡,貌似vue没有具体的说明。想要在父元素下阻止事件的冒泡,代码如下 1234567891011 &lt;div class=&quot;confirm&quot; v-show=&quot;showFlag&quot; @click.stop&gt; &lt;div class=&quot;confirm-wrapper&quot;&gt; &lt;div class=&quot;confirm-content&quot;&gt; &lt;p class=&quot;text&quot;&gt;{{text}}&lt;/p&gt; &lt;div class=&quot;operate&quot;&gt; &lt;div @click=&quot;cancel&quot; class=&quot;operate-btn left&quot;&gt;{{cancelBtnText}}&lt;/div&gt; &lt;div @click=&quot;confirm&quot; class=&quot;operate-btn&quot;&gt;{{confirmBtnText}}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 如果碰到不同组件,却有相同逻辑的代码,甚至包括vuex的数据共享的代码,如何进行代码的复用?这是从官网里面粘贴的概念:混合 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。用法如下: 123456789101112131415161718192021222324var mixin = { methods: { foo: function () { console.log('foo') }, conflicting: function () { console.log('from mixin') } }}var vm = new Vue({ mixins: [mixin], methods: { bar: function () { console.log('bar') }, conflicting: function () { console.log('from self') } }})vm.foo() // =&gt; &quot;foo&quot;vm.bar() // =&gt; &quot;bar&quot;vm.conflicting() // =&gt; &quot;from self&quot; 使用Object.assign 添加新的响应式对象属性有时候利用,Vue.set(vm.userProfile, ‘age’, 27); 或 this.$set(this.userProfile, ‘age’, 27);只添加单一的响应式属性,如果需要多次添加，则需要多次编写。这样子，代码就显得过于冗余。有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样： 1234Object.assign(this.userProfile, { age: 27, favoriteColor: 'Vue Green'}); 你应该这样做： 1234this.userProfile = Object.assign({}, this.userProfile, { age: 27, favoriteColor: 'Vue Green'}); 容易忽略的input好用的修饰符 .lazy在默认情况下，v-model 在 input 事件中同步输入框的值与数据 (除了 上述 IME 部分)，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步： 12&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt; .number如果想自动将用户的输入值转为 Number 类型 (如果原值的转换结果为 NaN 则返回原值)，可以添加一个修饰符 number 给 v-model 来处理输入值： 1&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; 这通常很有用，因为在 type=”number” 时 HTML 中输入的值也总是会返回字符串类型。 .trim如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入： 1&lt;input v-model.trim=&quot;msg&quot;&gt; props 也可以传递一个对象如果你想要用一个对象作为 props 传递所有的属性，你可以使用不带任何参数的 v-bind (即用 v-bind 替换掉 v-bind:prop-name)。例如，已知一个 todo 对象： 1234todo: { text: 'Learn Vue', isComplete: false} 然后: 1&lt;todo-item v-bind=&quot;todo&quot;&gt;&lt;/todo-item&gt; 将等价于： 1234&lt;todo-item v-bind:text=&quot;todo.text&quot; v-bind:is-complete=&quot;todo.isComplete&quot;&gt;&lt;/todo-item&gt; props .synv修饰符在一些情况下，我们可能会需要对一个 prop 进行『双向绑定』。事实上，这正是 Vue 1.x 中的 .sync修饰符所提供的功能。当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定的值。这很方便，但也会导致问题，因为它破坏了『单向数据流』的假设。由于子组件改变 prop 的代码和普通的状态改动代码毫无区别，当光看子组件的代码时，你完全不知道它何时悄悄地改变了父组件的状态。这在 debug 复杂结构的应用时会带来很高的维护成本。上面所说的正是我们在 2.0 中移除 .sync 的理由。但是在 2.0 发布之后的实际应用中，我们发现 .sync 还是有其适用之处，比如在开发可复用的组件库时。我们需要做的只是让子组件改变父组件状态的代码更容易被区分。从 2.3.0 起我们重新引入了 .sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。如下代码: 123&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;``` 会被扩展为: &lt;comp :foo=”bar” @update:foo=”val =&gt; bar = val”&gt; 1当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件： this.$emit(‘update:foo’, newValue) 12345### transition 组件还有过度模式可以使用in-out：新元素先进行过渡，完成之后当前元素过渡离开。out-in：当前元素先进行过渡，完成之后新元素过渡进入。 ```","link":"/2017/07/13/Vue/%E5%88%9D%E5%AD%A6Vue%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"},{"title":"19年尾的我有了对项目优化的重新认识，从两个维度出发","text":"前言杂谈记得某一次面试的时候，面试官问我：说说你如何进行项目优化的吧；然后，我：雪碧图、合并请求啊、CSS引入放在头部…，一顿灌水式自我以为回答得很完美。面试官面无表情，你的思路主要是减少请求是么…,还有别的思路么。擦咧，我…竟无言以对。再有一次，我做的一个商城项目已经上线并且运行了一段时间，雄心壮志并且信心满满地准备动手一波优化，刚准备动手的时候，我疑惑了？应该从那方面进行优化呢，难道只能优化XHR请求的相关，如果只按照整个思路进行优化，优化的效果会不会不明显？… 一次客观人为的打击和一次自我菜逼的表现，引发了我长时间的思考？我明明看了很多优化相关的文章，雅虎军规啊，各种前端优化指南或总结啊。在看的时候明明就觉得自己看懂了并懂得如何进行项目优化了，但为什么在需要动手，却偏偏疑惑了呢？没有思路了呢？直到今天，我才明白，除了自己本身菜的原因，（那就没有原因啦），开个玩笑。其实，我个人认为，项目优化需要遵循两个维度的思路。第一，技术的维度；第二，业务的维度 技术维度遵循雅虎军规35条 首先，把雅虎军规的每一条都根据自己的项目进行优化。至于利用什么webpack工具，其实原理都差不多，雅虎军规提供的是思路，而且webpack仅仅是一个工具，仅仅是一个工具而已。 当我们根据雅虎军规进行优化之后，会发现明显感觉到首页加载时间减少，项目运行速度明显快了。本来想帖个图，但又懒得…，额，你懂的。以后再补上吧 业务的角度首页一个项目最重要是的首页，有人会问为什么？ 调查表明，人们对于软件或者 APP 的运行效率有极高的要求，例如对于网页打开的忍耐极限是 6 秒甚至更短，如果你设计的网页打开的时间超过 6 秒，多数人会在 4 秒甚至 3 秒的时候毫不犹豫地关掉而去浏览其他网页。在这个大背景下，一个好的“算法”更注重的是时间复杂度，而空间复杂度只要在一个合理的范围内就可以。 至于结论是否正确，大家可以去看看国内大厂项目的首页加载速度，基本保持在1~2秒这个区间。这里也DOMContentLoaded为基准 下面是淘宝和狗东的首页加载时间 淘宝 狗东（京东）,为什么叫狗东，因为logo就是条狗 懒加载 + 骨架屏以狗东的首页为例，（因为我开了狗东Plus会员）。首页可以明显看出，首页不是一次性加载全部页面，目测是加载浏览器的加载浏览器全屏的元素。下面可以很明显看出 思路：首先，首页仅浏览器默认全屏宽度元素加载，监听浏览器滚动事件，滚动到某一固定的值，加载事前规定的元素。其次，异步加载事情规定的元素，未加载成功，使用骨架屏元素进行显示，代替传统的 loading 加载方式，最后，元素显示出来。 同样的思路，可以应用各个页面上去 缓存利用为什么要缓存利用项目本身，有一些公共的库，以vue技术栈为例，axios、vue、vuex以及公有的组件库。虽然，浏览本身会缓存一些文件，但是每次升级项目的时候，因为hash值改变了，所有文件缓存失效。所以，这个缓存的控制，必须由我们控制。要它缓存的时候，就缓存，要它更新的时候就更新。就像古时候，”君要臣死，臣不得不死”，对，就是这种感觉 思路流程 方法1、利用版本号就是在xx.js后加个?v=xxx。例如 a.js?v=20191213，版本号是自定义的。 适用于：随业务更新而更新的文件 2、利用HTTP协议以 Cache-Control 为例 request1234Cache-Control: no-cache // 浏览器不缓存, 返回的结果要看其他参数的情况Cache-Control: max-age=600 // 数字，秒，表示浏览器缓存10分钟，这段时间内即使服务器资源有修改，浏览器也不会改变。 // 这段时间内请求，http status是200 from cache 用来控制不经常更细的公共文件，但是在需要更新就可以更新的文件 还有一些其它HTTP属性可以控制，狠狠点击这里一篇文章理解前端缓存 3、条件允许的情况，大图片使用cdn，小图片制作成svg，上传到iconfont 或者其他第三方生成 iconfont的形式 CDN，我的理解是，用户请求该图片的时候，通过一个代理，然后请求最近的服务器，减少HTTP请求的时间，然后获取资源。 iconfont 是 把小图片生成 CSS class 的形式，减少对HTTP的请求。 相关链接 前端优化实践总结 前端优化不完全指南 前端性能优化—-yahoo前端性能团队总结的35条黄金定律 大公司里怎样开发和部署前端代码？ 前端工程与性能优化","link":"/2019/12/11/Web/19%E5%B9%B4%E5%B0%BE%E7%9A%84%E6%88%91%E6%9C%89%E4%BA%86%E5%AF%B9%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E7%9A%84%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%EF%BC%8C%E4%BB%8E%E4%B8%A4%E4%B8%AA%E7%BB%B4%E5%BA%A6%E5%87%BA%E5%8F%91/"},{"title":"2019年我总结的面试题","text":"说一下PromisePromise是什么？ Promise是一种用于解决异步问题的思路、方案或者对象方式。 Promise怎么用？ Promise是一个对象，所以先用new的方式创建一个，然后给它传一个函数作为参数，这个函数有两个参数，一个叫reolve,另一个叫reject、紧接着，就用then来进行调用 Promise原理 在Promise内部，有一个状态管理器的存在，有三种状态: pending、fulfilled、rejected (1) promise初始化状态为pending (2) 当前调用resolve(成功), 会由pending =&gt; fulfilled (3) 当调用reject(失败), 会由pending =&gt; rejected 跨域什么是跨域协议、端口和域名不一致导致的跨域跨域是因为浏览器需要遵守同源策略，发出的请求即使相应成功，也被浏览器拦截下来 同源策略同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互、这是一个用于隔离潜在恶意文件的重要安全机制、 为什么如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。转送门1、 防御 XSS 攻击XSS，即 Cross Site Script，中译是跨站脚本攻击。 HttpOnly Cookie。 输入过滤。 服务器输出编码。 WAF(Web Application Firewall) 2、防御 CSRF 攻击CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。 关键操作只接口POST请求，服务器拒绝GET请求 验证码 Referer Check Token验证 跨域的解决方案1、通过jsonp跨域2、document.domain + iframe跨域3、location.hash + iframe4、window.name + iframe跨域5、postMessage跨域6、跨域资源共享(CORS)7、nginx代理跨域8、nodejs中间代理跨域9、WebSocket协议跨域 jsonp原理jsonp的核心则是动态添加 script 标签调用服务器提供的js脚本，允许用户传递一个callback参数给服务器，然后服务器返回数据时会将这个callback参数作为函数名老包裹JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了 仅支持GET方法 如何进行网站性能优化1、Content方面 减少HTTP请求：合并文件、CSS精灵、inline image 减少DNS查询： DNS查询完之前浏览器不能从这个主机下载任何文件、方法：DNS缓存、讲资源分布到恰当的数量的主机名，平衡并行下载和DNS查询 避免重定向 ： 多余的中间访问 使用AJAX缓存，真相跟 HTTP缓存没有什么区别。相关链接 非必须组件延迟加载 未来所需组件预加载 减少DOM元素数量 将资源放到不同的域下面：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 2、Server方面 使用CDN 添加Expires或者Cache-Control： 当Cache-Control和Expires同时存在时，Cache-Control会覆盖Expires。相关链接 使用Gzip压缩 配置Etag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 3、Cookie方面 减小Cookie 引入资源的域名不要包含cookie 4、CSS方面 将样式表放到顶部 不要使用CSS表达式 不使用@import 不使用IE的Filter 5、JavaScript 将脚本放到页面的底部 将JavaScript和CSS从外部引入 压缩JavaScript和CSS 删除不需要的脚本 减少DOM的查询 合理设计事件监听器 6、图片方面 优化图片： 根据实际颜色需要选择色深、压缩 优化CSS精灵 不要在HTML中拉伸图片 保证favicon、ico小并且可缓存 7、移动方面 保证组件小于25K Pack Components into a Multipart Document 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例)大概流程 URL输入 DNS解析 TCP连接 发送HTTP请求 服务器处理请求 服务器响应请求 浏览器解析渲染页面 连接结束 1、在浏览器数地址栏输入URL 2、浏览器查看缓存，如果请求资源在缓存中并且新鲜(即是有没有过期的意思)，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制 Expires 和 Cache-Control HTTP1.0提供Expires，值为一个绝对值表示 HTTP1.1增加了Cache-Control : max-age=，值为以秒为单位的最大新鲜时间 3、浏览器解析URL获取协议，主机，端口，path 4、浏览器组装一个HTTP(GET)请求报文 5、浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询(可能存在负载均衡导致每次IP不一样) 6、打开一个sokcet与目标地址端口建立TCP链接， 三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发送SYN=1，ACK=X+1，Seq=Y的响应包 客户端发送ACK=Y+1，Seq=Z 7、TCP链接建立后发送HTTP请求 8、服务器接受请求并解析，将请求转发到服务程序，如虚拟机使用HTTP Host头部判断请求的服务程序 9、服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 10、处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 11、服务器将响应报文通过TCP链接发送回浏览器 12、浏览器接受HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动发送Fin=1，Ack=Z，Seq=X报文 被动发送ACK=X+1，Seq=Z报文 被动发送Fin=1，ACK=X，Seq=Y报文 主动发送ACK=Y，Seq=X报文 13、浏览器检查响应状态码：是否为1XX、3XX、4XX、5XX，这些情况处理与2XX不同 14、如果资源可缓存，进行缓存 15、对响应进行解码(例如gzip压缩) 16、根据资源类型决定如何处理(假设资源为HTML文档) 17、解析HTML文档、构件DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 18、构建DOM树： Tokenizing： 根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction： 根据HTML标记关系将对象组成DOM树 19、解析过程中遇到图片、样式表、js文件，启动下载 20、构建CSSOM树 Tokenizing： 字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 21、根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script，meta这样本身不可见的标签。2)被CSS隐藏的节点，入display:none 对每一个可节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 22、js解析如下 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或者外部脚本。这些脚本同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常定义为函数和注册事件处理事件，他们可以遍历和操作script和他们之前的文档内容。 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本在它下载完成后尽快执行，但是解析器不会停下来等它下载。**异步脚本禁止使用document.write()**，它们可以访问自己script和之前的文档元素 所有deter脚本会按照在文档上出现的顺序执行，延迟脚本能访问完整文档时，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完成解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成和执行，document.readState变为complete,window触发load事件 23、显示页面(HTML解析过程中会逐步显示页面) 移动端开发自适应页面如何做？1、通过meta标签设置viewport，移动端的理想适口。 &lt;meta name=&quot;viewport&quot; content=&quot;width=width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; 2、设置rem单位来进行适配、加上Flex布局、百分比布局 3、其它方案，响应式适配、vw+rem rem原理 rem是是指相对于根元素的字体大小的单位 比如设置html font-size=100px;那么1rem=100px;之后的所有元素都可以用这个基准值来设置大小； rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小——MDN 说一下this。 相关链接与我们常见的很多语言不同，JavaScript 函数中的 this 指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。 直接调用直接调用，就是通过 函数名(…) 这种方式调用 方法调用方法调用是指通过对象来调用其方法函数，它是 对象.方法函数(…) 这样的调用形式 new关键字调用 通过 bind() 将函数绑定到对象之后再进行调用 通过 call()、apply() 进行调用 箭头函数的特点?官方解释：箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。 引用箭头函数有两个方面的作用：更简短函数和并且不绑定this 箭头函数不会创建this，它只会从自己的作用域链上一层继承this。 简而言之，箭头函数，永远指向当前调用的对象 == 和 === 的区别？ == 会进行隐式转换，比较前将两个被比较的值转换为相同类型。然后比较两个值是否相等 === 不进行隐式转换，会比较类型和值 CSS选择器优先级 每个选择器都有权值，权值越大越优先 继承的样式优先级低于自身制定样式 !important优先级最高，js也无法修改 权值相同的时候，靠近元素的样式优先级搞，顺序为内联样式 &gt; 内部样式表 &gt; 外部样式表 BFC什么是BFCBFC就是”块级格式化上下文”的意思，创建了BFC的元素就是一个独立的盒子，不过只有Block-level Box 可以参与创建BFC，它规定了内部的Block-level Box如何布局，并且与这个独立盒子里的布局不受外部影响，当然它不会影响到外面的元素。 BFC特性： 内部的Box会在垂直方向，从顶部开始一个接一个地放置 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加 每个元素的margin box的左边，与包含的 border box 的左边相接触（对于从左往右的格式化，否则相反）。即使存在浮动也是如此。 BFC的区域不会与float box叠加 BFC就是页面的一个隔离的独立容器，容器里面的子元素不会受影响到外面的元素，反之亦然。 计算BFC的高度时，浮动元素也参与计算 如何触发BFC 根元素或包含根元素的元素 浮动元素,float 除了 none 以外 绝对定位元素, position 为 absolute、fixed display 为 inline-block、table-cell、table-caption、flow-root overflow 值不为 visible 的元素 弹性元素（display 为 flex 或 inline-flex 元素的直接子元素） 网格元素 (display 为 grid 或 inline-grid 元素的直接子元素) 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug） EventBus如何实现？相关链接利用发布/订阅模式，发布/订阅模式由一个发布者、多个订阅者以及一个调度中心所组成。订阅者们先在调度中心订阅某一事件并注册相应的回调函数，当某一个时刻发布者发布了一个事件,调度中心取出订阅了该事件的订阅者们所注册的回调函数来执行。 在发布/订阅模式中，订阅者和发布者并不需要关心对方的状态，订阅者只管订阅事件并注册回调、发布者只管发布事件，其余一切交给调度中心来调度，从而实现解耦。 Vue组件之间的通信 父传子: props、attr、ref调用函数 子传父: emit、listeners 兄弟组件通信: vuex、eventBus Vue双向绑定的原理Vue是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发响应的监听回调。 具体步骤： 第一步：需要 Observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到数据变化。 第二步：Compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 第三步：Watcher 订阅者是 Observe 和 Compile 之间通信的桥梁，主要的事情是： 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update() 3、待属性变动dep.notify()通知时，调用自身的 update() 方法，并触发 Compile 中绑定回调，则功成身退。 总结：MVVM作为数据绑定的入口，整合 Observe、Compile 和 Watcher 三者，通过 Observe 来监听自己的 Model 数据变化。通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observe 和 Compile 之间的通信桥梁；达到数据变化 -&gt; 视图更新; 视图交互(input) -&gt; 数据 Model 变更的双向绑定效果。 Vue Computed的实现原理和缓存原理实现原理：遍历computed对象的key，调用defineComputed函数，给对应的key添加getter和setter。同时给每个对象添加一个watcher，通过这个watch来进行派发通知，更新视图 缓存原理：缓存就是在获取 getter 数据的，判断是否值相等，相等的话就直接返回，不再进行更新视图 Vue watch 和 computed的区别watch 主要监控数据的变化，根据变化自定义执行相应的操作computed 在计算获得数据，在getter之后会进行缓存，只有依赖的属性值变化后，才会发生变化，否则从缓存获取数据 MVVM框架是什么？它和其它框架（Jquery）的区别是什么？哪些场景适合？MVVM分为Model、View、ViewModel三者 Model 代表数据模型，数据和业务逻辑都在Model层中定义 View 代表UI视图，负责数据展示 ViewModel 负责监听 Model 中数据的改变并且控制视图更新，处理用户交互操作： Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的， Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步 区别：这种模式实现了 Model 和 View的数据自动同步，因此开发时这需要要专注对数据的维护操作即可，而不需要自己操作dom场景：数据操作比较多的场景，更加便捷 面试回答: jQuery主要简化了DOM的操作，是一个JS函数库。Vue，主要实现了MVVM的模式框架，通过数据驱动视图的变化，不需要自己操作DOM，增加了开发效率，并实现了组件化的思想，增加项目的可维护性。 Vue mixin 的原理主要思路合并对象，遍历循环mixin对象，然后找到对应的钩子函数进行合并。 nextTick 实现原理概念补充:JS，是单线程的，利用JS的事件循环 事件循环大致分为以下几个步骤: (1) 所有同步任务都在主线程上执行，形成一个执行栈(execution context stack) (2) 主线程之外，还存在一个”任务队列”(task queue)。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 (3) 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。哪些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 (4) 主线程不断重复上面的第三步 宏任务(macro task) 和 微任务(micro task) 先执行宏观任务，再执行微观任务(是对异步 处理的 优先级) 宏观任务：setTimeout、MessageChannel、postMessage、setImmediate… 微观任务：MutationObsever、Promise.then 123456789for (macroTask of macroTaskQueue) { // 1. Handle current MACRO-TASK handleMacroTask(); // 2. Handle all MICRO-TASK for (microTask of microTaskQueue) { handleMicroTask(microTask); }} nextTick原理： 会有一个callbacks数组，接受nextTick的回调函数,push进去 首先判断是否支持Promise，支持则利用的Promise.then进行调用遍历调用callbacks数组 判断是否支持 MutationObserver，支持则利用 MutationObserver 遍历调用callbacks数组 判断是否支持 setImmediate，支持则利用 setImmediate 遍历调用callbacks数组 都不支持，则利用setTimeout进行遍历调用 callbacks数组 面试回答: 把传入的回调函数压入 一个 callbacks 数组，判断当前浏览器支持宏任务还是微任务函数，在对应的函数里面进行回调 遍历callbacks 数组，然后执行相应的函数。 什么是虚拟 dom ？VNode是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展VNode的灵活性以及实现一些特殊 feature的。 Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode的 create、diff、 patch等过程。 说一下Vuexvuex有哪几种属性？vuex具有五种属性: state、getter、mutation、action、module vuex的state特性是？ vuex就是一个仓库，仓库里面放很多对象。state就是数据存放地，对应于一般vue对象里面的data state里面存放的数据是响应式的 vuex的getter特性是？ getters可以对state进行计算操作 可以在多组件之间复用 vuex的mutation特性是？ action类似于mutation action提价的是mutation，而是不是直接变更状态 action可以包含任何异步操作 不用vuex会带来什么问题？ 可维护性会下降，你要想修改数据，你得维护三个地方 可读性下降，因为一个组件里的数据，你根本看不出来是从哪来的 增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。 请详细说下你对vue生命周期的理解？总共分为8个阶段创建前/后,载入前/后,更新前/后,销毁前/后 创建前/后: 在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。 载入前/后: 在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后: 当data变化时，会触发beforeUpdate和updated方法。 销毁前/后: 在执行destroy方法后，对data的改变不会触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 请说下封装 vue 组件的过程？首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模快，解决了我们传统项目开发：效率低、难维护、复用性等问题。 然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据递给父组件。可以采用emit方法。 说一下keep-live组件的原理keep-alive是什么keep-alive是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中；使用keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。 keep-alive运行原理 获取keep-alive包裹的第一个子组件对象以其组件名 根据设定的黑白名单(如果有)进行条件匹配，决定是否缓存。不匹配，直接返回组件实例(VNode) 根据组件ID和tag生成缓存Key，并在缓存对象中查找是否已缓存过该组件实例。如果存在，直接取出缓存值并更新该 key 在 this.keys 中的位置（更新key的位置是实现LRU置换策略的关键），否则执行第四步 在 this.cache 对象中存储该组件实例并保存 key 值，之后检查缓存的实例数量是否超过 max 的设置值，超过则根据LRU置换策略删除最近最久未使用的实例（即是下标为0的那个key）。 最后并且很重要，将该组件实例的 keepAlive 属性值设置为 true 面试回答: 根据设定的黑白名单(如果有)进行条件匹配，决定是否缓存。不匹配，直接返回组件实例(VNode)，如果匹配的话，存储到一个对象里面，并根据组件ID和生成缓存key，并且标识该组件已缓存。然后如果下次再匹配的话，就会通过对应的缓存Key从内存里面获取对应的Vue实例。 Proxy 和 Object.defineProperty 的优劣？ Proxy有多达13种拦截方法，不限于apply、ownKeys、deleteProperty、has等等是 *Object.defineProperty()**不具备的 Proxy返回的是一个新对象，我们可以只操作新的对象达到目的，而 Object.defineProperty 只能遍历对象属性直接修改 Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利 当然,Proxy的劣势就是兼容性问题,而且无法用polyfill磨平,因此Vue的作者才声明需要等到下个大版本(3.0)才能用Proxy重写。 聊一聊常见的浏览器端数据存储方案数据存储方案： Cookie Web存储(localStorage和sessionStorage) IndexedDB 大概说一下Cookie和localStorage、sessionStorage的功能特性。问到的话，Cookie的缺点就是，存储量少、数据大影响性能、只能储存字符串、安全性问题、需要检查Cookie能否使用 Flexible布局方案的原理 获取document的适口宽度 除以 10 得出 1rem = viewWidth / 10 然后设置 html的font-size为 rem + ‘px’ 为什么会有深拷贝和浅拷贝？日常开发中如何使用？，如何实现一个深拷贝？1234567891011121314151617181920212223242526272829303132333435363738/** * @desc 深拷贝，支持常见类型 * @param {Any} values * @return {Any} */function deepClone(values) { var copy; // Handle the 3 simple types, and null or undefined if (null == values || &quot;object&quot; != typeof values) return values; // Handle Date if (values instanceof Date) { copy = new Date(); copy.setTime(values.getTime()); return copy; } // Handle Array if (values instanceof Array) { copy = []; for (var i = 0, len = values.length; i &lt; len; i++) { copy[i] = deepClone(values[i]); } return copy; } // Handle Object if (values instanceof Object) { copy = {}; for (var attr in values) { if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]); } return copy; } throw new Error(&quot;Unable to copy values! Its type isn't supported.&quot;);} 如果是一个数组，就声明一个数据组，然后循环遍历，递归赋值。如果是一个对象，就声明一个对象，然后判断是否子元素,递归赋值 除了递归，我们还可以借用JSON对象的parse和stringify 12345function deepClone(obj){ let _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone} 后台管理系统权限路由实现?权限控制的主体思路，前端会有一份路由表，它表示了每个路由的访问权限。当用户登录之后，通过token获取用户的role，动态根据用户的role算出其对应有的权限的路由，通过router.addRoutes动态挂载路由。 vue 组件 data 为什么必须是函数？如果是对象的话，每一个vue组件都是一个vue实例，通过new Vue()实例化，引用同一个对象，如果data直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同数据就会被改变。而data是函数的话，每个vue组件的data都因为函数有了自己的作用域，互不干扰。 webpack 是什么？为什么使用webpack? WebPack和Grunt以及Gulp相比有什么特性WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 因为通过webpack把一些繁琐的操作的，比如CSS添加对应的前缀，通过引入模快的方式来进行操作。 现在开发如何解决浏览器兼容问题？ 样式兼容性（css）方面,通过 Normalize.css 抹平差异 利用webpack或者其它工具，给CSS添加浏览器前缀 交互兼容性（javascript，exp: 事件兼容的问题、new Date()构造函数使用、获取 scrollTop 通过 document.documentElement.scrollTop 兼容非chrome浏览器相关链接 前端如何指定浏览器使用最新内核?123&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;/&gt; // 强制Chromium内核，作用于360浏览器、QQ浏览器等国产双核浏览器&lt;meta name=&quot;force-rendering&quot; content=&quot;webkit&quot;/&gt; // 强制Chromium内核，作用于其他双核浏览器&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;/&gt; // 如果有安装 Google Chrome Frame 插件则强制为Chromium内核，否则强制本机支持的最高版本IE内核，作用于IE浏览器","link":"/2019/05/11/Web/2019%E5%B9%B4%E6%88%91%E6%80%BB%E7%BB%93%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"“源于一场冲突” - PC浏览器最小字体限制测试(上)","text":"源于这个人的“坚持”，我个人认为实践是检验真理的唯一标准，加上前端发展到2020年了，各种浏览器已经更新迭代这么久了，应该会有所变化，更不用说他做的是移动端了。 首先来测试一下PC浏览器的最小字体。 Windows环境Chrome、360极速浏览器、360安全浏览器、Firefox浏览器、IE11浏览器、Edge浏览器、QQ浏览器 Mac 环境 从上面的结果来看，很明显只有Chrome浏览器和QQ浏览器,在PC端限制字体大小12px，而其它浏览器没有限制字体的大小。 至于为什么这么干，据说Google是因为觉得中文如果小于12px，会影响用户观看和增加识别难度，才有这个骚操作。 不过个人随着大家使用的屏幕越来越多，以及中文用户越来越多和这个小于12px的需求越来越多的话，终有一天谷歌开放这个限制的。 在线例子狠狠点击跳转: PC浏览器最小字体在线Demo测试 参考链接移动端最小字体限制测试","link":"/2020/04/01/Web/%E2%80%9C%E6%BA%90%E4%BA%8E%E4%B8%80%E5%9C%BA%E5%86%B2%E7%AA%81%E2%80%9D%20-%20PC%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E9%99%90%E5%88%B6%E6%B5%8B%E8%AF%95(%E4%B8%8A)/"},{"title":"“源于一场冲突” - 移动端浏览器最小字体限制测试(下)","text":"接下来是移动端浏览器的测试结果 iPhone X、华为荣耀 - 微信内置浏览器 以上都是基于微信内置浏览器进行测试的，也就是在微信直接点击打开的，因为毕竟多少移动端网页项目一般都是跟公众号关联。 虽然测试的量不够大，但从结果上来看 苹果手机不限制移动端浏览器的最小字体，跟PC的限制一样。安卓机的一些机子，有些限制，有些不限制，估计考虑到移动端屏幕比较小的原因，如果有限制最小字体的话，从这次的结果来看都是8px 最后，所以那么个人如果坚持认为在项目默认最小字体为12px，那么在PC的项目可行，但显然在移动端是不合理的。 邓爷爷说过：“实践是检验真理的唯一标准”，不仅适用于经济发展，也适用于我们去解决一个问题。蜜汁 参考链接移动端最小字体限制测试","link":"/2020/04/01/Web/%E2%80%9D%E6%BA%90%E4%BA%8E%E4%B8%80%E5%9C%BA%E5%86%B2%E7%AA%81%E2%80%9C%20-%20%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E9%99%90%E5%88%B6%E6%B5%8B%E8%AF%95(%E4%B8%8B)/"},{"title":"了解原理的重要性 - 理解JavaScript的Event Loop","text":"印象中，有好几次的面试都跟 JS 的 Event Loop 有关或者说跟它有关系。有些面试官会问，讲一讲 Vue 的 nextTick的原理吧，有些则很直接，你了解 Event Loop 么，讲一讲原理。 虽然我都能答上来，但那时候我有一个疑问？为什么这么多面试官喜欢这个问题，或者说我懂了 Event Loop 原理为什么能加分?要回到这些问题，首先得了解它是干什么，以及它有什么用。 什么是Event Loop我们都知道，JavaScript 从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。 单线程意味着，JavaScript 代码在执行的任何时候，都只有一个主线程来处理所有的任务。 因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。 而如何处理这些任务就是 Event Loop。可以扫一眼下面的图片，有一个初步的了解。 图中的产生堆（Heap）和栈（Stack），可以简单理解为，JS 处理的数据和函数; Web APIs 则是浏览器提供的函数，优先级比 JS 的栈（Stack）的函数要低，也就是栈里面的函数处理完了，才能轮到浏览器函数, 记住这个很重要! 下面用浏览器函数代替 Web APIs 方便讲解 而 Callback Queue 即事件队列，类似在饭堂吃饭的排队，一个一个来打饭（处理）。 Event Loop, 在处理所有任务的时候，首先会处理 JS 栈里面的函数，然后一定要在处理完栈里面的函数的时候，才可以处理 浏览器函数。 所以图中的箭头是从 栈（Stack）执行浏览器函数，最后指向事件队列。 为什么 JS 需要 Event Loop, Event Loop 的特性永不阻塞和单线程单线程是必要的，也是 JavaScript 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 DOM 操作。试想一下 如果 JavaScript 是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个 DOM，此时该如何处理呢？ 为什么是永不阻塞，设想一下 JavaScript 本身是单线线程的，如果遇到一个如果 浏览器函数（WebAPIs），突然阻塞了，刚好浏览器在这个时候需要插入DOM以及渲染CSS。那么呈现给用户是一个非常不友好的空白页面。这也是为什么浏览器函数优先级比 JavaScript 函数的原因之一。（这是我个人的看法，暂时没查到具体原因，不过这个原因我觉得也比较合理） 为什么要了解原理呢？或者说了解它有什么用那么问题来了，为什么我们要花这么力气去了解 JavaScript 的 Event Loop 呢？原因很简单，你了解它之后你就能明白，为什么 setTimeout 函数、AJAX等等API总是在其它函数之后执行。同时，在你写项目的时候可以对整个项目的掌握，以及代码出现错误的时候，你能迅速定位错误并解决它。 可能大家还是觉得作用不大，这里是一个原理。如果你能完完全全掌握这个语言所有的原理，那么你的技术肯定能上一个档次，也能相应获得一个比较好的薪酬。同时，现在前端的技术日新月异，其实搞来搞去都是前端三板斧。很多人都过于热衷于新技术和蹭热点，所以导致很多人干了很多年技术依旧很差。 也正是有这么人不懂，你学了之后才能体现你价值，因为他们有的，你有，他们没有，你有。你的“特别”，才能在芸芸众生之中突出你的价值所在！ 参考链接 视频，非常推荐Help, I’m stuck in an event-loop JavaScript 运行机制详解：再谈Event Loop 详解JavaScript中的Event Loop（事件循环）机制 Understanding Event Loop, Call Stack, Event &amp; Job Queue in Javascript 前端开发都应该懂的事件循环（event loop）以及异步执行顺序（setTimeout、promise和async/await）","link":"/2020/03/23/Web/%E4%BA%86%E8%A7%A3%E5%8E%9F%E7%90%86%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%20-%20%E7%90%86%E8%A7%A3JavaScript%E7%9A%84Event%20Loop/"},{"title":"函数编程 - 没有最好的，只有更好","text":"我最早在一个群里面听到函数式编程，发现在IT行业所谓的新技术以及新概念，真的是日新月异。 通过这篇文章，谈谈什么是函数式编程，以及它的作用。跟一直以来我们所接受的面向对象编程，那个更好？还有它的应用场景是什么，换句话说，它应该什么时候用得上。 以及表达我的一个观点，也就是标题上写的，没有最好，只有更好。 前端的“前世今生”首先我们先来了解前端整个发展历史，基本可以代表两个阶段。第一个是前世，从带着缺陷的诞生到迈向成熟的阶段，类似于婴儿落地，到叛逆青少年然后迈向成熟的阶段；第二个阶段则是，从成熟迈向发展的阶段，这个阶段的前端在市场启着一定重要的作用，不像第一个阶段主要为后端打杂。 前世(1990 ~ 2012jQuery)1990年，万维网之父蒂姆·伯纳斯-李（Tim Berners-Lee）在NeXT电脑上发明了第一个Web浏览器。 1991年8月6日，Tim在alt.hypertext新闻组贴出了一份关于World Wide Web的简单摘要，这标志了Web页面在Internet上的首次登场。 最早的Web主要被一帮科学家们用来共享和传递信息，全世界的Web服务器也就几十台。由于仅是用来传递信息，从可视化方式或从传递数量上看，仅比电报强一点点。 当时还没有JavaScript，用的是纯静态的页面。由于是纯静态页面，造成必须使用后端来生成，这样极大占用后端的资源，从导致JavaScript的诞生。 JavaScript是由网景公司，发布了第一款商业浏览器Navigator的网景工程师布兰登·艾克（Brendan Eich）创造的。传闻只用了10天时间设计出JavaScript语言，近乎上帝七日创造世界那么高效。但也因为工期太短的缘故，导致许多瑕疵，因此一直被正统传序员所嫌弃，直到Ajax的出世，才让人们找到理由忍受它的畸形。另外，早期的浏览器都配有一个选项，用来禁止JavaScript语言运行。 同时由于初期设计的缺陷为后面的发展埋下了伏笔，浏览器之战。 也正是因为初期设计的缺陷，从导致任何厂家都可以基于它进行改装，从而为自己的浏览器筑起保护墙。 最具代表性，就是微软的IE浏览器和网景公司的网景浏览器，一个JScript，另一个是JavaScript，但是由于微软公司在推出IE浏览器的时候，网景公司已经占据了大部分市场，同时也由于IE浏览器奇葩的各种问题，从导致很多工程师不愿意兼容IE浏览器，因此发掘了UA，专门用于过滤掉IE浏览器，只要网页在运行通过UA判断出是IE浏览器，就提示用户用网景浏览器打开。 但微软反其道而行，微软让自己的UA伪装成网景的UA，加上windows系统的捆绑，从而迅速占据市场，并最终超越网景公司。最后，网景公司被微软收购了。 也正是因为微软统治了浏览器市场，加上微软不遵循规范，尽管但是有ECMA-262（JavaScript规范文档）与W3C（HTML与CSS的规范文档），从而导致了jQuery诞生，专门用于解决市面上的浏览器的兼容性，虽然网景公司被收购，但还是有一些其他浏览器占据了一些市场份额的。 今生(2013 ~ 至今2020), 后jQuery时代、MVVM框架（Vue、React）、小程序虽然jQuery解决了浏览器兼容性问题，同时也极大简便前端对DOM和BOM的操作。 但同时，也引发了一些问题，比如每一个页面需要引入很多很多的jQuery插件，如果不分批引入又容易造成一个文件过大，加载时间太长，加上jQuery另一个问题是全局污染，由于插件的质量问题，或者开发的素质问题，这时候已经不同通过传统的编程规范来限制开发人员编程造成的问题，事实上规范这种东西，很少有人遵守，因为人性本身是懒惰。 于是一些优秀的前端工程师们决定从取经后端，引入模块机制。最终NodeJS的诞生，统一了这种模快机制,也为目前前端的三大框架奠定了基础，Vue、React和Angular。 小程序是腾讯专门基于微信打造的一个生态，严格意义我不认为是前端发展出来，只能说它基于当时的情况和市场，选择用前端技术制造小程序生态。 为什么会诞生函数式编程从前端诞生以及它发展到现在的历史可以看出，技术一直是为解决某些问题而诞生的一些新技术，都是基于一个范式，都是基于现在有生态 + 新方案 = 新技术。 所以，基于JavaScript面向对象的开发模式导致的问题，大家又为此创造一个新开发模式或者新规范，函数式编程。 面向对象开发模式有什么问题呢？简单来说，就是由于当对象的属性过于复杂，并且操作它频繁的时候，有时候开发人员非常难于预测在程序运行的确定性。也就是，它容易导致不确定性。 而函数式编程恰恰就是为了解决这些问题而产生的一个方案，一个新开发模式。 在做项目时，该如何选择？面向对象编程开发，还是函数式编程开发那么在做项目的时候应该选择哪种开发模式呢？很简单，你善于哪种就用哪种，当年你认为你的项目必须用上函数式编程模式的时候，再用上也不迟，因为它的切换成本也不大，同时在切换的时候，可以局部切换有一个过渡性的阶段。 总结所以在做项目的时候，没什么最好的方案，只有在适当的条件更好的方案。我们得抛弃以前老师教的思维，正确的答案只有一个；这种思想，往往对于工作和生活是不适用的，如果你有留意，在你每次做出生活和工作上的重大选择的时候，应该会发现你的选择，没有最好，只有更好。 在信息爆炸的时代，需要具有自己的看法以及思维判断能力，每种新技术的诞生，不可能诞生一个去学一个，所以我们在了解它们之后，结合自己的项目以及能力，选择一个当下最适合新技术去解决一些问题，这样渐进式开发。 最好，技术没有最好，只有更好。 参考链接 前端开发 20 年变迁史 函数式编程 函数式编程初探 JS 函数式编程指南 YouToBe 函数式编程","link":"/2020/03/25/Web/%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B%20-%20%E6%B2%A1%E6%9C%89%E6%9C%80%E5%A5%BD%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%9B%B4%E5%A5%BD/"},{"title":"前端项目的性能优化之路","text":"前言提供整体思路，具体步骤，需要具体了解和实现 按照思路，能极大改善项目的性能 Content方面 减少HTTP请求：合并文件、CSS精灵、inline image 减少DNS查询： DNS查询完之前浏览器不能从这个主机下载任何文件、方法：DNS缓存、讲资源分布到恰当的数量的主机名，平衡并行下载和DNS查询 避免重定向 ： 多余的中间访问 使用AJAX缓存，真相跟 HTTP缓存没有什么区别。相关链接 非必须组件延迟加载 未来所需组件预加载 减少DOM元素数量 将资源放到不同的域下面：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量 减少iframe数量 不要404 使用语义化标签相关链接 Server方面 使用CDN 添加Expires或者Cache-Control： 当Cache-Control和Expires同时存在时，Cache-Control会覆盖Expires。相关链接 使用Gzip压缩 配置Etag Flush Buffer Early Ajax使用GET进行请求 避免空src的img标签 Cookie方面 减小Cookie 引入资源的域名不要包含cookie CSS方面 将样式表放到顶部 不要使用CSS表达式 不使用@import 不使用IE的Filter JavaScript 将脚本放到页面的底部 将JavaScript和CSS从外部引入 压缩JavaScript和CSS 删除不需要的脚本 减少DOM的查询 和 操作 合理设计事件监听器 合理使用循环，尽量减少循环次数图片方面 优化图片： 根据实际颜色需要选择色深、压缩 优化CSS精灵 不要在HTML中拉伸图片 保证favicon小并且可缓存 移动方面 保证组件小于25K Pack Components into a Multipart Document","link":"/2018/05/14/Web/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AF/"},{"title":"在浏览器移动端，页面适配方案实际上有两种","text":"在前端的开发面试中，经常会问到一个问题，”你是如何进行（浏览器）移动端的页面适配的？“，我以前通常只会回答一种适配方案，并且也只认为只有这一种。实际上随着对前端不断认识的加深，目前比较流行实际上大概只有两种。 视网膜屏幕为什么要进行适配，原因很简单，市面的手机有各种不同大小尺寸的手机，自从iPhone4横空出世之后，移动端就多了一个新概念视网膜屏幕。简单讲解一下，这个新概念移动端浏览器有什么影响。 简单来说，这个概念主要是为了移动设备提出来的，最开始没有 DPR 的概念。但是随着技术的发展，从 iPhone 4 开始，苹果公司将 iPhone 4 的分辨率提高了一倍，但是尺寸没有变化，这意味着大小相同的屏幕上，像素多了一倍(一个方向上，像素点其实是 4 倍)，但是屏幕的尺寸没有变化，因为以前设备像素与逻辑像素的比例一直是 1 ： 1，都没人去关心这个，而 iPhone 4 的 DPR 为 2 了，所以就有了 DPR 的概念。 如果弄不懂也没关系，可以简单理解为 dpr 是 缩小比例，比如说，设计师给你一个 750 x 1334，里面的各种标注的宽高，都需要按照除以一个缩小比例。 例如：下图，假设在iPhone6的设备中，DRP为2，则里面标注的数字都要除以 2，页面才能正常显示。 所以，从诞生这个新概念的开始，前端开发工程们，就走上了适配浏览器移动端漫漫之路。下面，向大家介绍两种主流方案。 下面两种方案，meta 统一设置为如下所示1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 详细的meta标签知识，可以参考这里meta属性的使用详解 第一种，以 rem 单位为代表首先，大家先看一下动图： 当浏览器解析HTML文档时，创建了一个用来代表页面元素的集合，叫做DOM（文档对象模型，Document Object Model）。树状结构，每一个节点代表一个元素。就是顶层节点（根节点），在下面的是它的子节点和，再往下就是它们的子节点，还有后代节点，如此类推。 根节点是文档里所有其他元素的祖先。它有一个特别的伪类（pseudo-class）选择器（:root），在样式表里可以用这个选择器表示。使用带类名的类型选择器html，或者直接用标签选择器，效果是一样的。 rem 是根em（root em）的缩写。rem是和根元素关联的，不依赖当前元素。不管你在文档中的什么地方使用这个单位，1.2rem的计算值是相等的，等于1.2倍的根元素的字号大小。下面的示例代码中，声明了根元素的字号大小，并在嵌套的无序列表中使用rem声明字号大小。 12345678910111213141516&lt;html&gt; &lt;heade&gt; &lt;style&gt; html { font-size: 100px; } .child { width: 0.1rem; // 10px height: 0.1rem; // 10px } &lt;/style&gt;&lt;/heade&gt; &lt;body&gt; &lt;p class=&quot;child&quot;&gt;我是Child&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 回过头来看，动图里面就使用到使用 rem 来进行适配，只是不同设备下的 html 的 font-size 值按等比例改变。所以，你看到图中的页面都是按等比例缩放或者放大。 PS: iPad设备看起来不是等比例，要注意在模拟器环境，设备的 zoom 值不是百分百 方案二，px 单位 为代表通常使用这种方案，遵循一个理念。更大尺寸的手机，应该显示更多的内容，而不是简单按比例放大或者缩小。同样先观察下图： 不知道你们注意到没有，在切换不同设备的同时，页面不会等比放大或者缩小,必须手动刷新之后才能正常显示。 这种方案通常是根据目前市场上手机设备的分辨率和尺寸，在里面选一个最合适和最小的，比如，4.0寸、4.7寸、5寸、6.1寸…，假设 4.0寸 的手机只占 0.2%，而 4.7寸 占据了大多数，那么设计师应该先以 4.7 寸 设计，然后前端以此为基础进行开发，最后根据不同的尺寸的手机进行适当调整即可。 像上面动图那种，从效果来看是根据不同尺寸的设备，编写了对应的CSS。 总结上面只是简单介绍了两种方案，实际项目不是简单地二选一，要根据团队、项目开发时间等等因素综合考量。因为总不能在三个月的开发时间，强硬地选择上面动图的开发方案，虽然实现起来不难，但这种工作很繁琐时间长，不符合当前要迅速上线项目的。既吃力不讨好，又损害公司的利益，得不偿失。 参考链接 屏幕尺寸大全 像素相关概念：PPI、DPI、设备像素、独立像素 为什么很多web项目还是使用 px，而不是 rem？ 饿了么 淘宝","link":"/2020/12/03/Web/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%8C%E9%A1%B5%E9%9D%A2%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E5%AE%9E%E9%99%85%E4%B8%8A%E6%9C%89%E4%B8%A4%E7%A7%8D/"},{"title":"如何利用vw+rem进行移动端布局","text":"前言因为在公司，只有一个前端，在做移动端布局的时候。利用px进行布局,发现，需要进行各种手机的适配。所以在开发第二版的时候，想着引用lib-flexible库(即手淘的方案),询问了上一家公司的同事，会有一些字体和一些诡异的问题。在无意中，突然一个网友跟我说，他有一个很好用的适配方案。利用vw+rem。听着他分析了一把，感觉还不错，所以大胆尝试了一把 根据CSS3规范,视口单位主要包括以下4个: vw : 1vw 等于视口宽度的1% vh : 1vh 等于视口高度的1% vmin : 选取 vw 和 vh 中最小的那个 vmax : 选取 vw 和 vh 中最大的那个 用视口单位度量，视口宽度为100vw，高度为100vh（左侧为竖屏情况，右侧为横屏情况） 例如，在桌面端浏览器视口尺寸为650px，那么 1vw = 650 * 1% = 6.5px（这是理论推算的出，如果浏览器不支持0.5px，那么实际渲染结果可能是7px）。 兼容性 利用适口单位适配页面对于移动端开发来说，最为重要的一点是如何适配页面，实现多终端的兼容，不同的适配方式各有千秋，也各有缺点。 就主流的响应式布局、弹性布局来说，通过Media Queries 实现的布局需要配置多个响应断点，而且带来的体验也对用户十分的不友好:布局在响应断点范围内的分辨率维持不表，而在响应断点切换的瞬间，布局带来断层式的切换变换，如同卡带的唱机般”咔咔咔”地一又一下。 而通过采用rem单位的动态计算的弹性布局,则是需要在头部内嵌一段脚本来进行监听分辨率的变化来动态改变根元素字体大小，使得CSS于JS耦合了在一起。 有没有办法能够解决这样的问题呢？ 答案是肯定,通过利用适口单位实现适配的页面,是既能解决响应式断层问题，又能解决脚本依赖的问题的。 用法以iPhone6为基准(750)第一步一般来说，我都会对移动端进行meta标签设置 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=2.0, maximum-scale=2.0, minimum-scale=2.0, user-scalable=no&quot;&gt; 因为iPhone6以及大多数的dpr为2,为了第二步的方便进行换算 第二步设置body、html的font-size 123html { font-size: 13.3333333333333vw // 设计图100px，浏览器根据缩放为 50px} 13.3333333333333vw怎么来?100 / 750 = 0.133333333333333vw我们把这个适口当做100px,然后除于750换算得出 1px = 0.133333333333333vw那么整个适口等于 0.133333333333333 * 100 = 13.3333333333333vw = 100px最终于得出 100px = 1rem (设计图100px，浏览器根据缩放为 50px) 通过这样子换算我们利用vw把rem转换成了根据设计以100px为基准 tip: (设计图100px，浏览器根据缩放为 50px) 那么在项目上就很好地可以进行使用了 12345678910div { // width: 设计图100px，实际浏览器根据缩放为 50px; width: 1rem; }span { height: .12rem} 已经用上该方案并上线的项目该项目是本人开发的，技术略渣，多多包涵","link":"/2018/06/20/Web/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8vw-rem%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/"},{"title":"如何垂直居中一个元素","text":"需要居中元素为单行文本，为包含文本的元素设置大于font-size的line-height： 12345678&lt;p class=&quot;text&quot;&gt;center text&lt;/p&gt;&lt;style&gt;.text { height: 200px; line-height: 200px;}&lt;/style&gt; 简单介绍一下: 这种方法是把父元素变成display: table,就是此元素将以块级表格来显示。子元素变成display: table-cell,此元素会作为一个表格单元格显示。子元素就利用单元格的属性: vertical-align: middle,来进行居中。 利用 display:table 1234567891011121314151617&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; 垂直居中 &lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent{ display：table; width:500px; height:500px; } .child{ display: table-cell; vertical-align: middle; }&lt;/style&gt; 利用display: flex &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; 垂直居中 &lt;/div&gt; &lt;/div&gt; &lt;style&gt; .parent{ display: flex justify-content: center align-items: center } .child {} &lt;/style&gt;","link":"/2018/05/15/Web/%E5%A6%82%E4%BD%95%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0/"},{"title":"如何水平居中一个元素","text":"如果需要居中的元素为常规流中inline元素，为父元素设置text-align: center;即可实现 如果需要居中的元素为常规流中block元素，1）为元素设置宽度，2）设置左右margin为auto。3）IE6下需在父元素上设置text-align: center;,再给子元素恢复需要的值 12345678910111213141516171819&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body { background: #DDD; text-align: center; /* 3 */ } .content { width: 500px; /* 1 */ text-align: left; /* 3 */ margin: 0 auto; /* 2 */ background: purple; }&lt;/style&gt; 如果需要居中的元素为浮动元素，1）为元素设置宽度，2）position: relative;，3）浮动方向偏移量（left或者right）设置为50%，4）浮动方向上的margin设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body { background: #DDD; } .content { width: 500px; /* 1 */ float: left; position: relative; /* 2 */ left: 50%; /* 3 */ margin-left: -250px; /* 4 */ background-color: purple; }&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度，2）偏移量设置为50%，3）偏移方向外边距设置为元素宽度一半乘以-1 123456789101112131415161718192021&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body { background: #DDD; position: relative; } .content { width: 800px; position: absolute; left: 50%; margin-left: -400px; background-color: purple; }&lt;/style&gt; 如果需要居中的元素为绝对定位元素，1）为元素设置宽度, 2）设置左右偏移量都为0, 3）设置左右外边距都为auto12345678910111213141516171819202122&lt;body&gt; &lt;div class=&quot;content&quot;&gt; aaaaaa aaaaaa a a a a a a a a &lt;/div&gt;&lt;/body&gt;&lt;style&gt; body { background: #DDD; position: relative; } .content { width: 800px; position: absolute; margin: 0 auto; left: 0; right: 0; background-color: purple; }&lt;/style&gt;","link":"/2018/05/15/Web/%E5%A6%82%E4%BD%95%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0/"},{"title":"如何防止跨站攻击?XSS和CSRF","text":"什么是CSRF？全称：CSRF(Cross-site request forgery),跨站伪造请求 CSRF(XSRF)顾名思义,是伪造请求，冒充用户在站内正常操作。例如，一论坛评论的发表是通过 GET 请求访问，点击发贴之后 JS 把评论内容拼接成目标 URL 并访问： 1http://example.com/bbs/create_post.php?title=标题&amp;content=内容 那么，你就只需要在当前评论网站中，包含一链接： 1http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈 只要有用户点击了这个链接，那么用户就会在不知名的情况下发表了这个评论。虽然只是一个恶作剧，当既然能够伪造发送请求，那么增、删、改、查也是有可能的。 如何防范CSRF攻击？ 关键操作只接口POST请求，服务器拒绝GET请求 验证码 CSRF 攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。 但如果你在一个网站做出任何举动都需要输入验证码，酱紫会非常严重用户体验，所以我应该在关键的功能地方，才设置验证码。 比如:注册功能、获取手机验证码 md5 + Token 目前主流的做法是使用 Token 抵御 CSRF 攻击。下面通过分析 CSRF 攻击来理解为什么 Token 能够有效 CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击。 另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的。这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击。 Token 使用原则 Token 要足够随机————只有这样才算不可预测 Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度 Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中 什么是XSS?全称：XSS（Cross Site Scripting，跨站脚本攻击） XSS全称”跨站脚本”,是注入攻击的一种。其特点是不对服务器端造成任何伤害,而是通过一些正常的交互途径，例如发布评论，提交含有JavaScript的内容文本。这时候如果服务器没有进行转义或者过滤这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这个脚本。 运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口： 123while (true) { alert(&quot;你是傻xxxxx&quot;);} 也可以是其他盗号或者未授权行为 XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。 如何防御XSS攻击？理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于 script。防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。 如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML escape 。下面一小段脚 1&lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt; 经过 escape 之后就成了： 1&lt;script&gt;window.location.href=&quot;http://www.baidu.com&quot;&lt;/script&gt; 它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。 输入过滤。永远不要相信用户的输入，对用户输入的数据做一定的过滤。后台服务器在进行接收用户输入的数据的时候，对特殊危险字符进行过滤或者转义处理，然后在存储到数据库。 服务器输出编码。服务器输出到浏览器的数据，可以使用系统的安全函数来进行编码或转义来防范XSS攻击。输出HTML属性时可以使用HTML转义编码(HTMLEncode)进行处理，输出到页面脚本代码中，可以相应进行JavaScript Encode处理。 HttpOnly Cookie。预防 XSS 攻击窃取用户 cookie 最有效的防御手段。Web 应用程序在设置 cookie 时，将其属性设为 HttpOnly，就可以避免该网页的 cookie 被客户端恶意 JavaScript 窃取，保护用户 cookie 信息。 WAF(Web Application Firewall)，Web 应用防火墙，主要的功能是防范诸如网页木马、XSS 以及 CSRF 等常见的 Web 漏洞攻击。由第三方公司开发，在企业环境中深受欢迎。","link":"/2019/08/19/Web/%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%B7%A8%E7%AB%99%E6%94%BB%E5%87%BB-XSS%E5%92%8CCSRF/"},{"title":"所谓技术选型是什么，该如何做？兼谈“品牌”的重要性","text":"最近发生的一些事情，让我对技术选型有了更加深刻的认识，以及对它的理解。 首先从最近发生的事情说起，由于项目特别是后台使用几乎没人知道的 JFinal 造成开发效率低，以及维护的困难性。原因它的维护人员更新慢加上技术社区不活跃，没人愿意基于它开发插件，形成一个技术生态。 不过在这里说明，只是从一些角度判断当前技术选型的好坏，并不存在什么完美的，通用的技术选型。 工作上遇到的问题最近由于特殊原因紧急上线了以前的小程序，小程序是在两年前写的。幸运的是，我当时使用了小程序原生语法，并没有特大的问题。但是，一旦遇到需要后端配合的东西非常麻烦而且无法排查。 微信支付举一个例子，首先我司做的小程序是一个电商小程序，那么从技术的角度来说。首先正常的订单流程得首先跑通吧，比如选择商品加入购物车，创建订单，支付。但是，神奇的是在微信支付那里一直处于loading状态，而且请求一直超时。 我和后端小哥，根据我们的经验一直不断猜测什么原因，并且不断进行排查。但是，在我们费了九牛二虎之力后，问题我们还是解决不了。 在几天之后，最终后端小哥，在把支付插件的版本更新之后，竟然神奇的成功了。 约定优于配置其次，还有一个的小问题，但又不是小问题。整个后台项目没有按照编程规范来进行编写，导致后期维护非常困难！ 比如，在做微信小程序的微信登录的时候。我和后端小哥基于现有的后台基础上，竟然花费了两三天的时间。 登录配置，没有遵循约定优于配置的规范。首先观察下面两张图，分别是支付插件和登录插件的配置。 支付插件没什么问题，各种支付就都遵循了编程规范的单一职责原则，我个人理解为，你的函数、功能以及配置有且仅有表达一种意思。这句话什么意思呢？好比如，在一个生产线流水工厂里面，每个工人仅负责这条生产线的某一部分，而且仅仅这部分是负责。再比如，一个函数如果表示加法运算，那么只能是加法运算，不能说它还里面做了“坏事”，我还进行加减乘除运算从而导致结果的不正确。 好了，理解了单一职责原则。那么上面的问题就很明显了，登录插件里面的微信登录，是表示公众号微信登录，还是APP的微信登录，或者说是小程序的微信登录？这就违反单一职责原则，因为它表示了太多层的意思。以导致我们一眼看到它，不知道他是用来干什么的。 所以没辙，后端小哥只能打开代码，一行一行代码来看，来研究究这个微信登录插件到底是用来干什么的。 结局出乎我们的意料，微信登录插件仅仅用于公众号微信登录，而微信小程序的微信登录则支付插件里面的微信小程序支付！我… 技术选型 + 总结在这次的项目中，还遇到很多问题就不一一举例的。经过这次填坑之旅，虽然它很崎岖，但也让我理解了什么的技术选型才是好的技术选型。 首先，在技术选型的时候，我们选择一些具有较高知名度“品牌”框架，比如后端是Java，那么就用Spring体系，因为它不仅有一个团队维护，而且有 Apache基础赞助，也就说维护它的人，是有钱赚的。(有钱赚，肯定就动力以及有心思继续搞好这个东西) 而且我一开始提到的 JFinal 是纯粹开发人员无法收入的公益项目。这也就解释了，为什么大厂流出的框架比较受欢迎，通常来说大厂流出来的框架，公司内部已经用上并且很可能已经上线了，通常大厂有专门的团队维护。 **其次，约定优于配置。为什么遵循约定优于配置的规范呢(这里只是介绍一种规范，每个公司规范不一定一样)**？从上面我们就可以看出，如果大家都遵循一种规范，那么你看到这个东西立马就能知道它干什么的了。 不要小看这个作用，如果你看到它某种东西，不知道什么意思，那么就会问，就和人进行交流。通常大家的储备知识不一样，理解能力不一样，有时候要为搞懂一件事情，还是很费功夫的。你的交流时间和你询问的人交流时间日积月累起来，就是非常长的了，特别是在赶项目的时候。 最后，我明白了为什么大家在买车买房买手机的时候，喜欢大品牌。很简单的一个道理，如果购买不出名的小品牌，很容易出现问题，而且售后不一定好，如果真的出现问题不仅影响心情，同时也很浪费时间。大品牌就不一样了，质量有保障，售后也还过得去。所以，花多点钱购买大品牌，其实就省下来很多时间。","link":"/2020/03/31/Web/%E6%89%80%E8%B0%93%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F%E5%85%BC%E8%B0%88%E2%80%9C%E5%93%81%E7%89%8C%E2%80%9D%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"},{"title":"理解RESTful架构(转载)","text":"阮一峰：理解RESTful架构","link":"/2019/11/01/Web/%E7%90%86%E8%A7%A3RESTful%E6%9E%B6%E6%9E%84/"},{"title":"简书网页劫持分析，浏览器指纹信息，使用 Chrome DevTools 调试 JavaScript 技巧，Android Chrome 远程调试，利用 CSP 预防劫持 (转载)","text":"摘要最近，每天第一次打开简书都会跳转到一个恶意网页，它以浏览器错误问题引导用户下载一个安装包。这个安装包安全性未知。另外打开网页时还会自动向剪贴板中写入一个淘口令，打开淘宝的时候会自动打开一个红包。页面跳转似乎是同一个 IP 每天只有第一次会触发，自动复制淘口令每次都会触发。另外，恶意网页的域名隔一段时间会更换。 经过分析得出，此问题准确来说不算是网页劫持，而是简书自己的一个广告供应商的问题。恶意代码是直接嵌入正常业务代码的，排除了被劫持的可能。由于已经持续很长一段时间了，所以说不定是简书默许了这个行为。此外，CSDN 似乎某些情况下也有这个问题（不确定）。 文章末尾介绍了使用 CSP (Content Security Policy) 预防页面劫持的方法。 关键词： 简书 劫持 网页 广告 恶意跳转 分析 DevTools 调试 JavaScript 指纹 Canvas Fingerprint CSP Cookie webpack 注意： 如果想知道如何劫持 HTTPS 网页的，抱歉这里没有，目前也不太可能出现 HTTPS 网页劫持或证书劫持的问题。 问题引出最近（其实已经很长时间了），每天第一次打开简书都会跳转到一个恶意网页，它以浏览器错误问题引导用户下载一个安装包。这个安装包安全性未知。另外打开网页时还会自动向剪贴板中写入一个淘口令，打开淘宝的时候会自动打开一个红包。 页面跳转似乎是同一个 IP 每天只有第一次会触发，自动复制淘口令每次都会触发。 因为用电脑访问并不会出现任何问题，所以我曾经一度以为是我的手机中病毒了。iOS 也不会触发，他们似乎仅针对 Android 手机。 所以我就用电脑对网页的脚本分析了一下，这里把分析过程分享给大家。说白了就是内嵌了一段 js 脚本（不过里面能发现很多有趣的东西）。这篇文章的主要目的也是介绍一些 JavaScript 的调试技巧。 目录 抓包 分析 js 代码依赖关系 格式化代码 分析代码逻辑与目的 为什么会出现这种问题 前端开发者如何预防这种问题 其他相关的思考与感想 抓包打开 Chrome 浏览器，按 F12 打开 Chrome DevTools（Chrome 开发者工具），切换到 Network 标签中勾选 Preseve log，然后访问一个简书的网页。 网页是我在 Bing 上随便找到 site:jianshu.com - 国内版 Bing 等待页面加载完成。简单浏览一下域名，看看有没有外部脚本。 似乎 PC 端不太行，那个页面似乎只能在安卓端触发，这里采用一种方法模拟一下手机端。点击开发者工具左上角的手机图标，然后在网页上方多出的工具栏中选择一个 Android 机型，刷新页面再看看。 这里有一个小技巧，右键列表的表头，勾选 Domain。然后按照域名排序，你就可以轻松忽略大量相同域名的文件了。 我们似乎有意外发现，来自非简书的域名 卧槽！这么多奇奇怪怪名字的域名，一看就不是什么好东西。这得有多少使用简书的人被这帮恶意脚本 X 啊。 分析 js 代码依赖关系 我们可以看到文件是这样加载的 为了防止不必要的外链风险，文中所有的域名均使用下划线 _ 代替了点 . 1234567891011https://www_jianshu_com/p/bc916e388452 https://cdn2_jianshu_io/asimov/2.c90dbb2ede007dc39cbf.js https://ox86_xu7b_com/m301650.js https://s9_cnzz_com/z_stat.php?id=1277879054&amp;web_id=1277879054 https://ws2_hbssjd_cn/ms/a.js?b=200473!301650!88!640!150!200&amp;u=5!5.0!0!1!c20tZzkwMHA%3D!8!77.0.3865.75!1&amp;c=1!0!x!6!4!1!24!640!360!0!5!0!x!1!d2luMzI%3D!1!0!0!0!0!1!3!x!d3d3LmppYW5zaHUuY29t!1!1!1!R29vZ2xlSW5jLn5BTkdMRShJbnRlbChSKUhER3JhcGhpY3M0NjAwRGlyZWN0M0QxMXZzXzVfMHBzXzVfMCk%3D!12!1!1!1!42!56!-1!-1!2585131335&amp;f=83338 https://s5_cnzz_com/z_stat.php?id=1277762915&amp;web_id=1277762915 https://vi12x_xcle_cn/sucnew/640x150/20190909sg150.png https://yun_lvehaisen_com/h5-mami/msdk/tmk.js https://engine_tuistone_com/api/v1/activity/get4web?request_id=2NQi3x8zovefyJ6WYcB8c8K2L1Zz8Jn3Haz5vKiixtlv8Swe1574800139758&amp;app_key=2NQi3x8zovefyJ6WYcB8c8K2L1Zz&amp;slotId=304277&amp;device_id=8Jn3Haz5vKiixtlv8Swe1574800139758&amp;callback=jsonp_0020308437386842737 https://engine_tuistone_com/api/v1/activity/spm4web?slotId=304277&amp;app_key=2NQi3x8zovefyJ6WYcB8c8K2L1Zz&amp;device_id=8Jn3Haz5vKiixtlv8Swe1574800139758&amp;activity_id=2000017418%2C923%2C923&amp;sdk_type=JSSDK&amp;sdk_version=3.3.1&amp;sdk_source=jianshu.com&amp;type=0&amp;click_url=https%3A%2F%2Factivity.tuipear.com%2Factivity%2Findex%3Fid%3D17418%26slotId%3D304277%26login%3Dnormal%26appKey%3D2NQi3x8zovefyJ6WYcB8c8K2L1Zz%26deviceId%3D8Jn3Haz5vKiixtlv8Swe1574800139758%26dsm%3D1.304277.0.0%26dsm2%3D1.304277.2.17418%26tenter%3DSOW%26subActivityWay%3D48%26tck_rid_6c8%3D0acc3777k3fjua4n-4603223%26tck_loc_c5d%3Dtactivity-17418%26dcm%3D401.304277.0.923%26&amp;data1=0acc3777k3fjua4n-4603223&amp;data2=%7B%22clickUrl%22%3A%22%2Factivity%2Findex%3Fid%3D17418%26slotId%3D304277%26login%3Dnormal%26appKey%3D2NQi3x8zovefyJ6WYcB8c8K2L1Zz%26deviceId%3D8Jn3Haz5vKiixtlv8Swe1574800139758%26dsm%3D1.304277.0.0%26dsm2%3D1.304277.2.17418%22%2C%22materJson%22%3A%22%7B%5C%22content%5C%22%3A%5C%22%5B%7B%5C%5C%5C%22imageUrl%5C%5C%5C%22%3A%5C%5C%5C%22%2F%2Fyun.tuitiger.com%2Fmami-media%2Fimg%2Fqm1eti6pdn.gif%5C%5C%5C%22%2C%5C%5C%5C%22width%5C%5C%5C%22%3A150%2C%5C%5C%5C%22height%5C%5C%5C%22%3A150%2C%5C%5C%5C%22msItemId%5C%5C%5C%22%3A22%7D%5D%5C%22%2C%5C%22gmtCreate%5C%22%3A1503470517000%2C%5C%22gmtModified%5C%22%3A1565093474000%2C%5C%22id%5C%22%3A923%2C%5C%22md5%5C%22%3A%5C%22DVt9EZ6wUcKxAg6mAseK8n%5C%22%2C%5C%22msId%5C%22%3A22%2C%5C%22pictureGroup%5C%22%3A%5C%224%5C%22%2C%5C%22pictureSize%5C%22%3A21%2C%5C%22pictureType%5C%22%3A%5C%220%5C%22%2C%5C%22pictureVal%5C%22%3A%5C%22150*150%5C%22%2C%5C%22title%5C%22%3A%5C%22%E6%91%87%E4%B8%80%E6%91%87%5C%22%7D%22%2C%22materialId%22%3A923%2C%22sckFromType%22%3A%22null%22%2C%22sckId%22%3A923%7D&amp;refer_host=www.jianshu.com&amp;md=&amp;timestamp=&amp;nonce=&amp;signature=&amp;connect_type=undefined&amp;callback=jsonp_039959120667317904 https://yun_tuitiger_com/mami-media/img/qm1eti6pdn.gif 万恶之源都是这个 2.c90dbb2ede007dc39cbf.js，它加载了 m301650.js 和 tmk.js 这两个文件，似乎 tmk.js 是用来加载页面右下角的广告的。而另一个就是跳转到骗人下载安装包那个页面。 这个 m301650.js 接入 cnzz 站长统计，看来访问量不小，都需要分析访客来源了。说不定分析之后还要针对性投放浏览器恶意下载页面呢。 分析代码然后就是分析代码的目的了。 这种明知道被 X 了，却不知道对面在做什么的感觉很难受。我非得把它扒的一干二净不可。 我们需要分析一下 m301650.js a.js tmk.js 这三个文件，如果有需要的话也可以分析一下 2.c90dbb2ede007dc39cbf.js，看看恶意代码是怎样嵌入到项目主代码中的。 前方高能！想学技术的仔细瞧，吃瓜群众凑个热闹就行了。 格式化代码右键选择 Open in Sources panel。 点击代码编辑器左下角的格式化代码按钮。 尝试分析代码然而事情并没有那么简单，简单浏览一下就会发现，这里有很多加密后的常量，还有疑似的解码算法。 解密字符串这里有很多种方法，下断点是最容易的，依赖于 Chrome 强大的调试功能，轻松就能找到解密函数。 动态调试往往比静态分析要简单。动态调试你能获取到程序运行时的第一手资料，静态调试只能靠一层层的推断。不过动态调试可能被检测出来，静态调试则没有这个问题。 方法 1：下断点调试 先在被混淆函数 d 那一行下一个断点 刷新页面，重新执行一次这个函数，触发断点 直接在控制台输入被混淆的函数名 d，然后回车，调试工具会直接输出当前上下文环境中的 d 的值。 这样我们很容易就能找到这个解密代码。 方法 2：尝试搜索所有动态语句如果我们直接找不到某个变量或函数名，那么他应该是动态生成的。 搜索 eval, new Function 动态执行语句 查找 String.fromCharCode, String.charAt 等可能动态生成标识符的函数 先搜索 eval，这种加密虽然最简单，但对于大多数不懂的人也是足够有效的。 二八定律处处存在，可能这个加密只是最简单的那 20% 的加密方法，但他却能阻止 80% 的人破解代码。（比例不一定对，但是这种现象是经常存在的） m301650.js 中只有一处 eval 1234567891011121314151617181920212223eval(function(p, a, c, k, e, d) { e = function(c) { return c.toString(36) }; if (!''.replace(/^/, String)) { while (c--) { d[c.toString(a)] = k[c] || c.toString(a) } k = [function(e) { return d[e] }]; e = function() { return '\\\\w+' }; c = 1 }; while (c--) { if (k[c]) { p = p.replace(new RegExp('\\\\b' + e(c) + '\\\\b', 'g'), k[c]) } } return p}('6 d(b){5 a,c=&quot;&quot;;4(a=0;a&lt;b.1;a+=2)c+=3.7(8(b.e(a,a+2),9));f c}', 16, 16, '|length||String|for|var|function|fromCharCode|parseInt|16|||||slice|return'.split('|'), 0, {})); 解密很简单，把 eval(...) 括号中的部分放到控制台执行就行了（注意括号对应关系），输出的内容就是被加密的代码原始的样子。 https://tool.lu/js，这个网站可以自动解密 eval 加密的 js 代码，把 eval(...) 粘贴进文本框，点击 解密（Decrypt） 即可解密到源码。你可以试试再点击 加密（Encrypt） 你会发现加密后的源码和我们之前看到的类似，看来这段代码的作者也是比较偷懒，直接用现成的加密方法了。 12345function d(b) { var a, c = &quot;&quot;; for (a = 0; a &lt; b.length; a += 2) c += String.fromCharCode(parseInt(b.slice(a, a + 2), 16)); return c} 这就是我们要找的那个 d 函数。这个代码很容易理解，就是一个 hex2bin 的功能，将十六进制字符串转换为二进制字符串。 对于 JavaScript 这种动态性极强的语言，尽量还是采用第一种方式。 比如 d(&quot;7265676D6F64654669656C6431&quot;)，先加载 d 函数，然后运行这条语句就行了。 批量解密字符串上面知道了解密函数，但是我不想手动替换每一个加密的地方，我需要把所有 d(...) 自动解密。 上重量级武器——语法解析器！我使用了 acorn 这个解析器（Parser），将 js 代码转换成 AST（抽象语法树），使用 acorn-walk 对 AST 中所有对 d 函数的调用都解码，最后再使用 escodegen 将 AST 转换回原来的代码。 注意：你的电脑必须安装了 Node.js 才可以执行下面的步骤 新建一个文件夹（例如附件的 decoder/ 文件夹），进入这个文件夹。 首先安装依赖 1npm install acorn acorn-walk escodegen 然后新建一个文件（例如 index.js），并编写代码 1234567891011121314151617181920212223const fs = require('fs');const acorn = require('acorn');const walk = require(&quot;acorn-walk&quot;)const escodegen = require('escodegen');function d(b) { var a, c = &quot;&quot;; for (a = 0; a &lt; b.length; a += 2) c += String.fromCharCode(parseInt(b.slice(a, a + 2), 16)); return c}const content = fs.readFileSync('../samples/m301650.js');const ast = acorn.parse(content);walk.simple(ast, { CallExpression(node) { if (node.callee.name === 'd' &amp;&amp; node.arguments[0].type === 'Literal') { node.type = 'Literal'; node.value = d(node.arguments[0].value); } }});const decodedContent = escodegen.generate(ast);fs.writeFileSync('../samples/m301650.decoded.js', decodedContent); 执行脚本 1node index.js 上面的脚本会自动读取原始代码 ../samples/m301650.js，把解码后的代码写入 ../samples/m301650.decoded.js 文件。 ../samples/m301650.js 是我从之前那些链接手动下载的。 开始分析代码代码总共不到 900 行，认真阅读一下就会理解。 这里谈谈一个我个人学习时的思想。学习可以大概分两种类型，第一种是教科书式学习，看教科书的目录就可以明白，它交给你所有的知识点，怎么组织知识结构由你自己来做。第二种是工具书式学习，用到什么查什么，没用到的东西虽然书上有，但是暂时不用去了解。在算法中，就类似于广度优先搜索和深度优先搜索。在数据缓存方面，就类似 eager load（饥饿）和 lazy load（懒加载）。在学校通常是第一种方式学习，在工作中通常是第二种方式学习。 这里的代码怎么阅读呢？也有两种方法，一个就是按照顺序读代码，了解各个函数的用途，然后再分析主程序。另外一个就是直接读主程序代码，先了解有哪些函数，但不需要看内容，然后分析主程序，主程序中调用了哪个函数，再去看那个函数。（放在 C 语言中，头文件就是存放那个函数声明的地方，其他语言中的 include import require using 也是做这个用的） 图灵机的思想就是“读取当前的状态→程序进行某种运算→最终写入新状态”。从这三个方面任意一方面开始像其他两方面展开分析都是可以的，但是从中间向两侧分析是最简单的。因为我们分析程序的目的就是了解程序究竟做了什么。（这个可以暂时不用理解，因为实战中多体会几次就会发现这样最方便） 分析代码时，我们通常想找出那些影响整个程序状态的代码。在通常意义的破解中，就是找出对系统 API 的调用（分析跨模块调用）。在 js 中就是对浏览器内置的函数的调用。 这里先去除到暂时不会改变状态的代码（声明性的代码），单纯的声明变量或函数对程序是没有影响的。程序的第一层大致是这样的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465(function (q, p) { function A() { } function B(b, a, c) { } function v(b, a, c, d) { } function C(b, a) { } var n = { }; B.prototype = { }; A.prototype = { }; n.V = 'https://ewn.hfqxjx.cn/ms/g.js'; n.N = '301650'; C(navigator.userAgent); try { } catch (b) { n.l(b, 'f_1'); } var F = new function (b, a) { }(navigator.userAgent, n); q = new B(q, p, n); p = ''; try { p = 'u=' + F.J(); } catch (b) { n.l(b, 'maCal_1'); } try { var z = q.J('kwashhhh'); p = p + '&amp;c=' + z.pa; } catch (b) { n.l(b, 'maCal_2'); } try { var t = n.u('kwashhhhfgp'); if (!t &amp;&amp; z) { t = new A().get(z.qa); var E = new Date(); E.setHours(48, 0, 0, 0); n.v('kwashhhhfgp', t, E); } t &amp;&amp; (p = p + '!' + t + '&amp;f=' + Math.floor(100000 * Math.random() + 1)); } catch (b) { n.l(b, 'macal_3'); } try { var _hmt = _hmt || []; var oscr = document.createElement('script'), osdiv = document.createElement('div'); oscr.src = 'https://s9.cnzz.com/z_stat.php?id=1277879054&amp;web_id=1277879054'; osdiv.style.display = 'none'; osdiv.appendChild(oscr); document.body.appendChild(osdiv); } catch (b) { n.l(b, 'macal_4'); } try { n.h('1', 'https://ewn.hfqxjx.cn/ms/a.js?b=200473!301650!88!640!150!200&amp;' + p); } catch (b) { n.l(b, 'macal_5'); }})('kwashhhh', '301650')); 其中 A B v C 函数都是声明，没有执行，暂时不用分析。n B.prototype A.prototype 基本上不用分析，因为他们基本上只是定义变量，不会修改全局状态。n.V = n.N = 修改的是程序的局部变量，对全局不会造成影响。 C(navigator.userAgent) 是第一个需要分析的代码，后面的所有语句几乎都可能与全局状态有关，都需要分析。 等等！我们真的需要这么麻烦吗？上面的方法适用于静态分析，不过动态分析比静态分析要简单！我们只需要在程序的第一句话下断点，然后一直单步运行就可以走完程序的逻辑了。 单步运行代码 在 Chrome DevTools 中 F8 是继续运行，F10 是单步步过，F11 是单步步入，Shift + F11 是执行跳出当前函数，更多快捷键可以在 右上角的三点 &gt; Settings &gt; Shortcuts &gt; Debugger 看到。 m301650我新建了一个 m301650.html 里面只有一句话 &lt;script src=&quot;m301650.decoded.js&quot;&gt;&lt;/script&gt; 这样我们可以打开这个本地的网页就可以进行测试了，同时这样也不会有其他代码的干扰。 这个过程虽然不难，但是非常的枯燥，用文字叙述也十分麻烦，此处省略，直接给出分析结果。 这个脚本收集了 window navigator 对象提供的各种各样的信息，例如：计算机或手机品牌型号、计算机操作系统（Windows、Linux、Mac OS、Android、iOS）、版本、CPU 核心数、浏览器种类（Chrome、IE、Opera、Firefox、Edge、Safari、微信、QQ、360、小米、OPPO、百度）、版本、排版引擎（WebKit、Trident、Gecko）、WEBGL 渲染引擎版本、Canvas Fingerprint、屏幕宽度、高度、色彩深度、是否支持触摸、触控点数、是否开启 Cookie、是否支持 LocalStorage、SessionStorage、IndexedDB。 这个脚本最后会加载 https://ewn_hfqxjx_cn/ms/a.js 并附加上这些获取的参数。a.js 又会做一堆事情，我们继续分析。 a这个 a.js 并没有做什么过分的事情，脚本会在页面某个位置添加一个图片，例如下面这个页面中间京东的广告。 这个广告看上去像是简书自己添加的，不是什么恶意广告，只是域名让人看起来非常可疑。 不过，让我觉得很烦的是。到目前为止，我刚分析了 2 个 js 文件，就已经加载了 3 个 cnzz 的统计脚本了。我已经将 cnzz.com 加入我的屏蔽域名中了。 反混淆工具tmk这个脚本也很复杂，也是单步调试慢慢看。在我心情烦躁时，我尝试搜索了一下 Reverse uglify js，我发现了 http://jsnice.org 这个网站，真的跟网站域名说的一样，Nice! 他可以自动推断值的类型，并据此来重命名变量，例入通过 var a = document.createElement('script')，会被转换成 var script_element = document.createElement('script')。他还会把 uglify 中常用的 &amp;&amp; 和 || 转换成 if (xxx) 或者 if (!xxx)，总之就是一个字：爽！ 代码的内容并不复杂，tmk.js 只提供了一个 TuiSDK 类，真正调用的地方在 2.c90dbb2ede007dc39cbf.js 中 123456var t = document.createElement(&quot;div&quot;);new TuiSDK({ container: t, appKey: &quot;2NQi3x8zovefyJ6WYcB8c8K2L1Zz&quot;, slotId: &quot;304277&quot;}); 这个广告使用 jsonp 返回数据，这个广告 SDK 只是根据这个返回值在网页上添加一个图标和一个链接，虽然这个广告图片特别像那种流氓网站（下面这张图片右下角的“送”字），但其实并没做什么过分的事情。 不过 jsonp 不仅仅可以返回数据，还是可以植入代码的，这个 SDK 是否可信我不太清楚，我测试的时候没有发现 jsonp 加载恶意代码的情况。 2到目前为止都并没有脚本修改跳转链接，也没有往剪贴板中写入数据，看来问题回到了最开始调用他们的 2.js 中，难道是简书出现了内鬼？我黑我自己？我们来分析 2.js 这个脚本没有混淆字符串，直接搜索链接就可以搜索出很多可以的网址。直接搜索 //(.+?\\.)+.+?/ 这个正则表达式。 showTui: //yun_lvehaisen_com/h5-mami/msdk/tmk.js jumpTui: https://engine_seefarger_com/index/activity?appKey=44oLpJM9AkUsZMnyoGDaEZQfADeo&amp;adslotId=296981 clickShengyao: https://cm_bilibili_com/mgk/page/284698023573377024/ insertGT: https://ad_lflucky_com/janes/js/jans.js goZhangxin: http://newspool_zhangxinzhixun_com/waifangsspgrlm/s1/index.html?appKey=7271ef91d1d5113 insertAMC: https://ox86_xu7b_com/m301650.js fetchSoHoAd: //statics_itc_cn/aap/prod/js/1.0.0/sohu_aap.js .gu-pao-ad: https://www_jianshu_com/p/428251ede1aa 好多广告，包括最后一个站内链接也是广告，接广告没啥问题，主要是某些广告平台的跳转页面令人恶心，谁知道什么时候会下载一个病毒或流氓软件，感觉太不靠谱了。 关于浏览器检测jans比如那个向剪贴板写入淘口令的就是 https://ad_lflucky_com/janes/js/jans.js。这么多淘口令，一天两个，不带重样的。 这个脚本里面也有用户隐私统计。不过值得注意的是，他甚至根据各种浏览器的特性（例如：电脑端不支持这个 UA 不可能拥有这个功能），判断出哪些浏览器信息是经过伪造的，然后上报这些伪造数据。 例如我用 PC 版 Chrome 模拟 Android Chrome 时，就会是下面这样的结果 1234navigator.platform&quot;Win32&quot;navigator.userAgent&quot;Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Mobile Safari/537.36&quot; 统计脚本发现 platform 为 Win32 而 UA 中写的却是 Linux，则他会认为我是假的 OS，新建了一个 iframe，链接为 https://ad_lflucky_com/janes/fk.html?fk=fakeOS，这个 iframe 的内容很简单，就是一个 cnzz 的统计脚本。 这个想法很有意思，把 cnzz 当做一个计数器，自己都不需要动态的服务器，只需要部署静态文件就可以进行数据统计了。 此外他还会利用各种特性检测假浏览器、假信息、假语言、假分辨率。例如： navigator.productSub 在 IE 上时 undefined，在 Safari 类浏览器下为 20030107 eval.toString().length 在不同浏览器上不同 object.toSource() 仅在 Firefox 类浏览器上受支持。 screen.height 不能比 screen.availHeight 小，因为前者是屏幕高度，后者是去除任务栏后的浏览器窗口可用的高度。 远程调试我其实很好奇为什么电脑端没有触发跳转到下载浏览器 apk 那个广告，我怀疑能是脚本对浏览器真伪进行了检测，只有真正的安卓端才会弹。 绕过方式也不难。Chrome 支持远程调试，我可以拿一台 Android 真机来运行 Chrome，这样就可以避免所有的检测。 开启调试接上 USB 线，打开开发者选项，打开 USB 调试。 打开 chrome://inspect 正常的话直接点 inspect 就可以了。这里有个问题，如果无法访问 Google 的话，不能正常使用这个 inspect，Chrome 提供了一种备选方案，当 PC 端 Chrome 版本低于 Android Chrome 时，inspect fallback 会出现，我需要用些小技巧让他强制出现。 在这个页面打开 F12 开发者工具，在 Sources 中找到 Overrides，启用，然后选择一个本地文件夹保存文件（例如：我选择的是 D:\\Temp\\chrome-local-override）。 切换到 Page，找到 inspect.js，搜索 fallback，找到这两行注释掉，然后 Ctrl + S 保存。你会发现文件图标上多了一个紫色的小点。 刷新页面，就会显示 inspect fallback 功能了。（Local Override 只会在开着 DevTools 时启用，关闭开发者工具之后，就会取消文件替换功能。） 调试 看到这个加载记录，我们可以明确了 m301650.js -&gt; a.js -&gt; d.js -&gt; p7090z.html 这一个过程了， 其中可以看到一堆 d.js 的加载，仔细看看都是 302 重定向。点开看详情，全都是各种 App 的跳转（网址域名中的点 . 已经替换成下划线 _） 1234567891011121314151617openapp.jdmobile://virtual?params={&quot;category&quot;:&quot;jump&quot;,&quot;des&quot;:&quot;m&quot;,&quot;url&quot;:&quot;https://u_jd_com/UKBirM&quot;,&quot;keplerID&quot;:&quot;0&quot;,&quot;keplerFrom&quot;:&quot;1&quot;,&quot;kepler_param&quot;:{&quot;source&quot;:&quot;kepler-open&quot;,&quot;otherData&quot;:{&quot;mopenbp7&quot;:&quot;0&quot;},&quot;channel&quot;:&quot;cedad4c0ad02455c9a818f1b3d98da1a&quot;},&quot;union_open&quot;:&quot;union_cps&quot;}https://878928_xyz/2019llq_5/m.878928.xyz/7090.htmlopenapp.jdmobile://virtual?params={&quot;category&quot;:&quot;jump&quot;,&quot;des&quot;:&quot;m&quot;,&quot;url&quot;:&quot;https://u_jd_com/M7fTMi&quot;,&quot;keplerID&quot;:&quot;0&quot;,&quot;keplerFrom&quot;:&quot;1&quot;,&quot;kepler_param&quot;:{&quot;source&quot;:&quot;kepler-open&quot;,&quot;otherData&quot;:{&quot;mopenbp7&quot;:&quot;0&quot;},&quot;channel&quot;:&quot;2de699902eec4131927c7b68871512b3&quot;},&quot;union_open&quot;:&quot;union_cps&quot;}vipshop://goHome?tra_from=tra%3AC01V4m36ysoz00q7%3A%3Amig_code%3A1xx1%3Aac013b3kbkgv6tsf9mhia46zu7m1fufxtbopen://m_taobao_com/tbopen/index.html?source=auto&amp;action=ali.open.nav&amp;module=h5&amp;bootImage=0&amp;spm=2014.ugdhh.2200612145320.219258-1604-32768&amp;bc_fl_src=growth_dhh_2200612145320_219258-1604-32768&amp;materialid=219258&amp;h5Url=https%3A%2F%2Fh5.m.taobao.com%2Fbcec%2Fdahanghai-jump.html%3Fspm%3D2014.ugdhh.2200612145320.219258-1604-32768%26bc_fl_src%3Dgrowth_dhh_2200612145320_219258-1604-32768tbopen://m_taobao_com/tbopen/index.html?source=auto&amp;action=ali.open.nav&amp;module=h5&amp;bootImage=0&amp;spm=2014.ugdhh.2200612145320.219272-1604-32768&amp;bc_fl_src=growth_dhh_2200612145320_219272-1604-32768&amp;materialid=219272&amp;h5Url=https%3A%2F%2Fh5.m.taobao.com%2Fbcec%2Fdahanghai-jump.html%3Fspm%3D2014.ugdhh.2200612145320.219272-1604-32768%26bc_fl_src%3Dgrowth_dhh_2200612145320_219272-1604-32768newsapp://startup/doc/EVLBFM6D0001899O?s=jixinkeji&amp;spsug=ug&amp;spsugdate=0&amp;spsugextend=jixinkeji07uclink://www_uc_cn/cc77796ca7c25dff9607d31b29effc07?action=open_url&amp;src_pkg=sxmhx&amp;src_ch=sxmhx133&amp;src_scene=pullup&amp;url=ext%3Ainfo_flow_open_channel%3Ach_id%3D100%26insert_item_ids%3D4556851981770947449%26type%3Dmultiple%26from%3D6001uclink://www_uc_cn/cc77796ca7c25dff9607d31b29effc07?action=open_url&amp;src_pkg=sxmhx&amp;src_ch=sxmhx134&amp;src_scene=pullup&amp;url=ext%3Ainfo_flow_open_channel%3Ach_id%3D100%26insert_item_ids%3D4556851981770947449%26type%3Dmultiple%26from%3D6001 这里面的第二个就是那个恶意软件的页面，PC 版 Chrome 打开直接提示危险网页。 不知道为什么，这些链接都没有成功打开。可能因为跳转到新页面，直接把 Pending 的 Response 都 Cancel 了。 分析跳转流程他们似乎对 IP 有检测，我再次访问这个链接时，并没有关于刚才那些链接的代码。 1https://ewn_hfqxjx_cn/ms/a.js?b=200473!301650!88!640!150!200&amp;u=5!8.1.0!3!1!bWltYXgz!8!78.0.3904.96!1&amp;c=1!2!Y2VsbHVsYXI%3D!3!8!7!24!786!393!0!5!0!x!3!bGludXhhcm12OGw%3D!1!1!1!0!0!1!1!x!d3d3LmppYW5zaHUuY29t!1!1!1!UXVhbGNvbW1%2BQWRyZW5vKFRNKTUxMg%3D%3D!13!1!1!1!33!62!-1!-1!2276550266&amp;f=90265 似乎重新换一个 IP 有用，并且也可能跟时间有关，可能是每 1 个小时刷新某些东西（这里不确定）。 这个 a.js 是动态生成的，里面的广告图片链接每次刷新都会变，跳转到恶意下载的那部分代码，通常时候是没有的，换 IP 之后会出现 1 次。 这个跳转流程并不复杂，就是根据 d.js URL 中的 n=1157258&amp;a=125977 这个参数使用 location.href 跳转到各个不同的 URL。具体可以看上面的代码图片（或 ./samples/a.v2.js）。 里面这个 https://nw44_zmlled_cn/js/mob/sjas.js 脚本又通过 iframe 引入了另外一个页面 https://dqj77_bkyhq_cn/js/tmp/ImgTj.html，这个页面包含大量 img 标签，可能都是用来进行访问统计的，真的恐怖，有必要搞这么多吗？ 分析 URL 参数我们可以具体明确一下 URL 中的那些参数都是哪些浏览器数据。生成这些数据的代码都在 m301650.js（因为 a.js 是从 m301650.js 发起的）。 1b=200473!301650!88!640!150!200&amp;u=5!8.1.0!3!1!bWltYXgz!8!78.0.3904.96!1&amp;c=1!2!Y2VsbHVsYXI%3D!3!8!7!24!786!393!0!5!0!x!3!bGludXhhcm12OGw%3D!1!1!1!0!0!1!1!x!d3d3LmppYW5zaHUuY29t!1!1!1!UXVhbGNvbW1%2BQWRyZW5vKFRNKTUxMg%3D%3D!13!1!1!1!33!62!-1!-1!2276550266 b=200473!301650!88!640!150!200 是固定值，然后后面分为 u c f 三部分，f 是一个随机数。 我的浏览器 User Agent 是 Mozilla/5.0 (Linux; Android 8.1.0; MI MAX 3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.96 Mobile Safari/537.36 你可以找到这些数据。 u 值 原始内容 说明 5 Windows = 1, Mac OS = 2, Linux, 模拟器 = 4, Android = 5 8.1.0 系统版本 3 UA 包含 mi = 3 1 手机 = 1, 平板 = 2, iPod = 3, 模拟器 = 4, 桌面 = 5 bWltYXgz mimax3 设备制造商 8 浏览器种类：Safari = 1, AppleWebKit = 2, MSIE = 3, IEMobile 或 Windows CE 或 Windows Phone 或 WP7 = 4, Opera = 5, Namoroka = 5, Shiretoko = 5, Firefox = 6, Minefield = 6, Netscape = 7, Chrome = 8, chromeframe = 9, UCWEB = 10, QQBrowser 或 MQQBrowser = 11, 360EE = 12, MicroMessenger = 13, QQ = 14, 华为手机或其他 = 15, miuibrowser = 16, oppobrowser = 17, baiduboxapp = 18 78.0.3904.96 浏览器版本 1 渲染引擎：WebKit 或 AppleWebKit = 1, KHTML = 2, Gecko = 3, Presto = 4, Trident = 5 c 值 原始内容 说明 1 document.cookieEnabled 启用 Cookie = 1, 不启用 = 0, 获取出错 = -1 2 navigator.connection 网络类型：Wi-Fi = 2, 移动网络 = 1, 其他 = 0 Y2VsbHVsYXI%3D cellular navigator.connection.type 详细网络类型（Wi-Fi 或蜂窝网络 2G、3G、4G，未知 = x） 3 history.length 访问历史长度 8 navigator.hardwareConcurrency CPU 线程数 7 如果 Cookie 有 kwashhhhnrfr 则直接返回，否则判断 Referer：未知 = 1, baidu.com = 2, .google. = 3, sogou.com = 4, so.com = 5, m.sm.cn = 6, bing.com = 7, 本站 = 8, 然后再将这些写入 Cookie 24 screen.colorDepth 色彩深度 786 screen.width 屏幕的长边像素 393 screen.height 屏幕的短边像素 0 window !== top 是否被嵌入：被嵌入 = 1, 顶级页面 = 0 5 navigator.userAgent 操作系统类型：windows = 1, mac = 2, linux = 3, iphone 或 ipad = 4, android = 5, windows phone = 6 0 navigator.oscpu 操作系统和 CPU 类型：win = 1, mac = 2, linux = 3, 其他 = 11 x navigator.oscpu 具体值，没有 = x 3 navigator.platform 平台类型：win = 1, mac = 2, linux = 3, android = 3, pike = 3, ipad 或 ipod 或 iphone = 4, 其他 = 12, 如果不支持 navigator.plugins 并且 UA 不是 Windows 或 Windows Phone = 13 bGludXhhcm12OGw%3D linuxarmv8l navigator.platform 1 navigator.maxTouchPoints 最大触摸点数 1 45 分钟新访客：在 Cookie 中设置一个 kwashhhhuuxs 记录从本周周一 0 点开始到现在的分钟数，如果不存在返回 1，超过 45 分钟再次访问或无法解析返回 2，否则返回 0 1 今日新访客：如果 Cookie kwashhhhuuxx 存在则返回 0，不存在设为 12 过期时间设为明天 0 点，返回 1 0 距离上次访问过去天数，使用 kwashhhhudd 记录 访问时间 / 86400 * 86400,今年访问天数，计算得出 0 今年访问天数，如果上两行的今日新访客为 1 则今年访问天数 + 1 1 1 1 PV: 对当前 location.href 进行 Hash，然后在 Cookie 中记录访问次数 x x d3d3LmppYW5zaHUuY29t www.jianshu.com document.domain，如果没有则用 obj.referrer 中的 host 1 window.localStorage 可用 1 window.sessionStorage 可用 1 window.indexedDB 可用 UXVhbGNvbW1%2BQWRyZW5vKFRNKTUxMg%3D%3D Qualcomm~Adreno(TM)512 WEBGL_debug_renderer_info gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) + &quot;~&quot; + gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) 13 document.getElementsByTagName(&quot;script&quot;).length 1 navigator.maxTouchPoints 最大触摸点数 1 document.createEvent(&quot;TouchEvent&quot;) 是否支持触摸事件 1 &quot;ontouchstart&quot; in window 33 document.title.length 标题长度 62 document.getElementsByTagName(&quot;div&quot;).length div 个数 -1 document.getElementById('kwashhhh').offsetLeft 嵌入的 div 被排版在什么位置 -1 document.getElementById('kwashhhh').offsetTop 2276550266 由各种浏览器参数组成的 Hash，包括：localStorage sessionStorage indexedDB WEBGL_debug_renderer_info navigator.maxTouchPoints document.createEvent(&quot;TouchEvent&quot;) &quot;ontouchstart&quot; in window oscpu platform userAgent navigator.language colorDepth 屏幕宽高 document.body.addBehavior openDatabase IE ActiveXObject navigator.plugins Canvas Fingerprint 为什么会出现这种问题引入未经验证的其他域的脚本 本案例中其他域的脚本不在自己网站的可控范围内，不论其是否可信，都应该尝试进行监控，避免对网站用户带来不必要的损失。 不知道法律上怎么判，但是假如用户通过简书页面加载的广告下载到了恶意 App，并造成了财产损失，简书肯定要承担责任，看就是看有没有人故意搞简书了。 只要使用 script 标签加载了其他域的脚本，当前网页就很难受你自己的控制了，他可以进行任何可能的操作，包括覆盖当前网页已有的比如 jQuery 库，甚至假如你的代码隔离不够，把某个 XHR 库暴露给全局了，他就可能拦截你所有的请求数据。 所以这种广告 SDK 尽量通过 CORS 跨域执行 XHR 请求，也不要盲目的使用 &lt;script&gt; 或 jsonp 加载不可控来源的脚本。 前端开发者如何预防这种问题这里讲的是如何预防，而不是如何解决。解决掉这个问题的方法只能是把所有依赖的 package 或 SDK 亲自过一遍。 JavaScript 不支持反射，你没法在运行时对其他代码进行检测。（当然，幸亏他不支持反射，否则你的完美隔离的代码和数据也可以被外来脚本获取到了） 所以这里只讲如何预防，预防的方法很简单，但是处理起来很麻烦。 CSP (Content Security Policy 内容安全策略)在 HTTP 返回头或 &lt;meta&gt; 中添加 Content-Security-Policy，即可限制资源来源，具体请参考 Content Security Policy (CSP) - HTTP | MDN。 处理完之后，在较新的浏览器中访问你的网页时，任何外部脚本攻击均不能执行。这些请求头让浏览器仅加载受控域名下的资源，任何企图使用来自其他域名的资源的操作都会直接报错。禁止加载来自未知域名的 JS 脚本，禁止使用未知域名的 CSS 样式文件，禁止使用未知域名的图片，甚至也禁止未知域名的内嵌 iframe，以及被其他域名以 iframe 形式引入。 优点是，你所有的东西都来自自己可控的域名下，缺点是你必须把所有你有的域名都列出来，包括执行内嵌代码都需要显示指出。 来自 MDN 的示例一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片，但是限制音频或视频需从信任的资源提供者 (获得)，所有脚本必须从特定主机服务器获取可信的代码. 1Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com 在这里，各种内容默认仅允许从文档所在的源获取，但存在如下例外: 图片可以从任何地方加载 (注意 “*” 通配符)。多媒体文件仅允许从 media1.com 和 media2.com 加载 (不允许从这些站点的子域名)。可运行脚本仅允许来自于 userscripts.example.com。 其他此外还有很多可用的安全选项。例如可以启用 HSTS 强制使用 HTTPS。声明 Cookie 为 HttpOnly 禁止 js 中获取 Cookie 内容。不过这些是防劫持用的而不是防止外部脚本的。 其他相关的思考与感想简书x百度另外也不知道简书跟百度有什么交易，一个页面竟然加载了好几百个百度的资源。 概率性 Bug概率性的 Bug 往往让人捉摸不透。作为一名程序员，改 Bug 也是常有的事情，碰到那些无法复现的 Bug 极为头疼，不过这个问题真的没有什么好的调试办法，只能不断的调试找到代码中可能有错误的位置。 不过换个方向思考一下，如果这不是一个 Bug，而是一个故意设的陷阱呢？部分游戏反外挂使用概率性封号、延迟封号的方法，让外挂制作者不知道到底是哪个功能过检测失败了。也有一种“蜜罐”方法，正常玩家不可能执行到“蜜罐”中的方法，而外挂制作者可以看到这部分代码，好好组织代码结构，让他我以为这段代码有用，可实际上一旦这段代码被执行到了，他会向服务器报告这个人使用了外挂。 本例中，目标网站的脚本是动态生成的，必须换 IP 才能抓到 1 次，这篇文章前前后后花了大约 2 周零零散散的时间。真的直到我发这篇文章的前一天我才真正抓到那个恶意跳转的脚本。 这种概率性 Bug 真的很麻烦。比如各种游戏的抽卡，如果玩家想要测试卡池概率有没有问题，只能大量花钱，靠频率接近概率的方式测试。 WebpackWebpack 通过 bundle 的方式增加了网页的加载效率，但是这种打包容易让一些毫无用处的代码一起加入发布的版本中，不过这些都没有隐藏恶意代码这个问题严重。应该不会有人去查看 bundle 的代码吧，最多利用 map 文件看看引入了哪些文件。没有 webpack 时我们很明确我们依赖了哪些 js 文件，但有了 webpack，我们没有再专注于代码安全，接入广告商的 SDK 直接打包进 bundle 了，甚至都不知道其中有恶意代码。 总结简书移动端页面会加载一堆 webpack bundle 其中的 2.js 包含广告功能，其中一个广告功能的代码加载了一个外部脚本。这个外部脚本是动态生成的，他会判断访问者的 IP，同 IP 每天第一次访问会跳转到恶意下载页面，之后不会再跳转。这个广告还接入了大量统计平台，加载一次页面就有好几百的请求。还另外一个广告也引入了外部代码，其中嵌入了向剪贴板中写入淘口令的指令。 本文分析了恶意代码对外的表现，基本弄清简书接入的广告的问题，主要目的还是学习和分享各种 JavaScript 动态调试技能。 希望简书尽快解决这个问题吧。（会不会简书内部已知，并且默许呢？） 相关链接 Navigator.productSub - Web APIs | MDN Cross-Origin Resource Sharing (CORS) - HTTP | MDN Access-Control-Allow-Origin - HTTP | MDN Content Security Policy (CSP) - HTTP | MDN Content-Security-Policy - HTTP | MDN Strict-Transport-Security - HTTP | MDN HTTP cookies - HTTP | MDN 最后，我自己经常说的一句话：所有能插入中间操作的代码都可以被调试破解。","link":"/2019/12/24/Web/%E7%AE%80%E4%B9%A6%E7%BD%91%E9%A1%B5%E5%8A%AB%E6%8C%81%E5%88%86%E6%9E%90%EF%BC%8C%E4%BD%BF%E7%94%A8-Chrome-DevTools-%E8%B0%83%E8%AF%95-JavaScript-%E6%8A%80%E5%B7%A7%EF%BC%8C%E5%88%A9%E7%94%A8-CSP-%E9%A2%84%E9%98%B2%E5%8A%AB%E6%8C%81/"},{"title":"编程语言的发展史，为什么前端的混合开发不如原生？","text":"经常会在群里看到，有人会问 uni-app、React Native等等（都是一种混合开发APP的框架）好不好用啊，会不会性能太差。 这次就来谈谈这些框架的优缺点，以及为什么性能不如原生APP。再一次体会了解原理的重要性。 语言的发展历史，机器语言、汇编语言、高级语言计算机从诞生开始就通过 低电平 和 高电平 也就所谓的的“0” 和 “1”组成的电路来运行的，“0” 和 “1”组成的语言就是机器语言，早期的计算机科学就是通过改变“0” 和 “1”来进行“编程”的。 举一个简答的例子，假设“01” 是 加法，“001” 是 等于号，“0011”和 “1100” 分别代表数字 5 和 10。你只要把这些组合成相应的电路就实现一个简单的运算。下面是一个减法算法电路图，可以扫一眼有个印象。 早期科学们为了有时了进行一个运算，在一个非常复杂的电路里面修改，有时候要花好几个月时间才能修完，这是一个极为浪费时间和头疼的事情。 这种使用的是最原始的穿孔卡片上使用的语言是只有专家才能理解的语言，与人类语言差别极大，这种语言就称为机器语言。机器语言是第一代计算机语言。这种语言本质上是计算机能识别的唯一语言，人类很难理解。以后的语言就是在这个的基础上简化而来。虽然后来发展的语言能让人类直接理解但最终送入计算机的还是这种机器语言。 下面就是穿孔卡片机 由于机器语言，非常不符合人类的习惯，加上工作量太大，在最早被确认的现代化、电力引导(electrically powered)的计算机约在1940年代被创造出来之后，大家就发明了一种汇编语言。 就是下面这种 虽然汇编语言比机器语言稍微好点，但也要花费大量的脑力。既而现在大家所熟悉的高级语言诞生了，比如Java、JavaScript、C、C#等。为什么说他们是高级语言，因为它们的语法更加贴近人类，比如这段就很接近人类的语法 12345if (xxx) { 运算} else { 运算 } 如果(xxx)成立，则执行中括号里面运算，否则则执行另一个运算。 简单总结一下，其实就是大家为了在用同样的时间，做更多的事情（编程），随着计算机的不断发展，越来越贴近人类的编程语言被发明。 如果大家看不懂也没有关系，就记住这句话就可以了。 语言的“能量守恒定律”，既要马儿，又不给马儿吃草，又要马儿不掉膘是不可能的。虽然高级语言的诞生提高了开发人员的编程效率，但其实这是把很多工作都扔给计算机。我自己称为语言的“能量守恒定律”，你既然要马儿，就得马儿吃草。其中这吃草的部分就工作都扔了计算机。 同样，在前端不断涌现的各种混合开发框架，比如React Native、uni-app、Flutter、Cordova等，之所以能一套代码运行在多个平台上（Android、iOS、浏览器），原理简单来说就是把部分工作扔给了计算机（给马儿吃草），让它帮你生成多套代码。你的工作确实减少了，但计算机的工作量剧增，所以混合开发的APP一直不如原生开发的APP。 我个人觉得，随着摩尔定律，每个18个月芯片的性能就提升一倍，也就说计算机的能干活的更多了，这种混合开发也许能替代原生开发Android、iOS的这种方式。 最后，大家在选择混合开发框架的时候，如果项目对性能要求比较高，建议使用原生开发；如果类似电商这种，可以考虑使用React Native、Flutter这种，通过编译生成两台原生代码。 当然了，如果是小公司考虑成本，需要一套代码运行三个平台，个人建议听从老板的建议，毕竟人家发工资给你恰饭，同时你也可以锻炼混合开发的能力也是可以的嘛。 参考链接 H5 手机 App 开发入门：概念篇 H5 手机 App 开发入门：技术篇 编程语言发展史 混合框架对比","link":"/2020/04/03/Web/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E5%89%8D%E7%AB%AF%E7%9A%84%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E4%B8%8D%E5%A6%82%E5%8E%9F%E7%94%9F%EF%BC%9F/"},{"title":"Google面试题：如何设计一个地图功能，找到离当前最近的加油(转载)","text":"今天我们讲解一个Google的面试题，假如你负责手机或者车载地图这个产品，如何设计这样一个功能，即找到离当前位置最近的几个加油站？这样的面试问题一来是考察计算机科学的基本知识，二来是看候选人分解问题、解决问题的能力。 在解题之前，我们先要把问题理解清楚，而不是一上来就盲目地做。很多人面试失败的主要原因就是答非所问，或者没有体会出题人的考察点。 对于这个问题，如果是车载的地图，需要考虑到汽车是移动的，结果会不断更新，因此那些速度很慢的算法就不适合这个场景了。其次，结果的刷新记录也不必太快，以免用户觉得结果太不确定。事实上，如果有两个加油站，一个距离2.5公里，一个2.3公里，对开车的人来讲差别不是很大，更何况路况的拥堵情况可能让这200米的差距变得越发不重要。但是，如果是行人在手机上寻找最近的7-11便利店，200米的差距就有意义了，而且通常步行不会拥堵，因此少走两百米就省两百米。 在正式解答这一类应用问题之前，可以谈谈不同场景下所需要考虑的因素。事实上，如果一个候选人一上来就将这个问题抽象化，并且解决了问题，有经验的考官最后会和面试者讨论各种应用场景下的变通，看看候选人只是刷题背答案，还是对具体问题有全面的思考。有些时候，一些候选人觉得对方考自己的问题都答上来了，但是没有被录取，其实那些看似轻松随意的讨论，也是考官考察候选人，获取信息的环节，不能轻视。 讲完了考这道题的目的和通常的面试过程，我们接下来就来分析一下这道题，我们以车载系统为例来讲解，这个问题我们需要做三步分解。 首先，我们需要搞清楚每一个加油站的位置和汽车现在的位置，最好同时也搞清楚行车方向。 一般来讲，在遇到课堂上的书面考试题时，已知条件都会写得极清楚，不会多给，也不会少给。而面试的问题，已知条件有时需要和考官沟通确认。在这个问题中，加油站的位置是GPS的坐标，还是街道的名称和号码，或者是什么地图中特定的坐标，这个要和考官沟通清楚。为了简单起见，我们不妨假设这些信息都有。至于汽车的位置，要更加复杂一点，因为它没有门牌号，只有GPS的定位，可能还需要转换成街道地址的范围（比如在北京朝阳区东方路1号到10号之间）。这些我们假定也都能办到。上述这些都算作确定了的已知条件，接下来的讨论就基于这些已知信息。 第二步，就要说说距离的计算了。 在地面上行驶，两点之间的距离不是欧几里得直线距离，因为车辆不可能穿过建筑直行。因此，两点之间的距离其实是很多距离片段的叠加。在一个城市里，连通两个点之间每一段距离的线路可以有很多种，它们之间的组合呈指数上涨，也就是说，拐几道弯，隔了几个红绿灯，各种路线的组合很容易就有上千种，那么怎么找到上千种路线中最短的一条呢？ 在数学中有一种方法叫做动态规划， 可以完成这件事，在上千种组合中用很少的步骤（大约几十步）就能算出最短的路径。真正面试Google这样的公司时，面试官或许会考对方这个算法。这个算法我在《数学之美》一书中介绍了，这里就不赘述了，非计算机专业的朋友只要知道这个名称也就可以了，不必深究细节。 总之，我们是有办法在地图上找到两个点之间最短的行车路径。接下来，我们就可以把汽车和城市里所有的加油站之间的距离列一个表，它的格式可以如下：加油站G1，距离D1；加油站G2，距离D2；……加油站GN，距离DN。到此，第二步算是完成了。 接下来的第三步，就是要按照距离排序，找出最近的几个加油站。 我们可以认为这是整个问题的子问题。 对于这个子问题，我遇到过的一些面试者会想到排序。排序当然是一个解决办法，但不是最佳的。对N个加油站根据距离排序大约需要N乘以LogN的计算量，如果像北京这样的城市，有1000个加油站，LogN大约是10。也就是说，计算的复杂度大约是N的10倍这个量级，也就是一万左右。这个计算量对计算机来讲算不上什么，但是如果考虑到汽车在移动，每分钟应该更新三五次数据，北京市有上百万辆车在路上，可能有上千辆车在寻找加油站，这种计算对于地图这种产品，也是一个负担。因此，好的工程师在设计产品时，需要找到更好的方法，这就是我们今天要讲的重点。 怎样找到更好的方法？我们需要回到问题的原点。上述通过排序找到最近的几个加油站的方法，其实做了很多无用功。原来的问题所要求的只是找到最近的几个加油站，提问题的人其实不关心那些距离比较远的加油站的距离和排序， 如果把所有的加油站都按照距离排序，做的工作其实比要求的多，而多做的工作在产品中也没有用途。**因此，提高产品的性能，其实就应该从避免做无用功入手。 怎么才能避免做无用功呢？我们不妨回忆一下昨天说的锦标赛排序以及高盛的赛跑问题。锦标赛排序的好处是，它并非要等到所有的排序工作都做完的时候，才知道谁是第一名，而是可以只排出前几名。 事实上，在二叉树这种数据结构中，有一种更特殊的细类，被称为“堆”，用这种数据结构，就可以做到只排出前几名，而不用管后面的名次。因此我们不妨把这种新方法称为小规模的堆排序。如果只需要排出前K名，这种算法得到第一名的复杂度是N，而得到第二、第三、第四名等等的复杂度都只有Log N，比对1000个加油站排序要快得多。如果我们只要找到最近的10个加油站，计算的量级大约是1000左右，比以前说的快速排序降低了10倍。 10倍之差，在工程上显然有意义。如果N非常大，就更有意义了。比如说，淘宝要找到一年之中交易额最高的10个顾客，给予一些奖励。我们假设淘宝的顾客有5亿，那么这种采用堆排序的方法找到前十名的时间，可以比快速排序节省30倍的时间。如果再稍微变通优化一下，则可以省上百倍的时间。在大数据的很多应用中，我们通常只关心前几个，而不需要对所有的数据排序。因此，Google通过这道面试题，其实可以不断地往下追问，全面考察面试者的专业技能。 到此，似乎这道面试题解决得很完美了，那么是否还能继续改进呢？答案是肯定的。 我们在前面做分析时，其实不知不觉地做了一个假设，就是整个算法优化的过程是围绕着一个使用者的某一次使用进行的。但在现实生活中，一个城市里（甚至一个国家），很多人会同时从不同的地方在寻找加油站。类似地，同一个人，在不同时间，也会在某个地方开车时，寻找加油站。 如果考虑到这个真实的应用场景应该是很多人不停地使用这个功能，那么很多计算其实都是可以预先算好的，等到服务的时候，直接把结果调出来即可，而不需要做重复计算。 比如我们可以把北京市所有路口之间点到点的距离事先计算好，当一个人要找加油站时，距离的计算就不再需要实时地采用动态规划来计算了，而只要算一下从当前的位置出发到附近的几个路口的距离，再算一下某个加油站到它所在地附近路口的距离，由于各个路口点到点的距离都是事先计算好的，因此做几次简单的加法即可。这样一来，计算距离的时间就能省几十倍。这就是对上面的问题进行了全局优化的好处。 我们有时候讲大数据思维，大数据很重要的一条就是不能像过去那样，将各个事件看成彼此独立的，分开来处理，而是要把所有数据集中起来，进行全局优化。通过找最近的加油站这道面试题，我们可以在思维上得到下面这些启发： 1.不要做无用功。要通过少做事情，特别是少做不必要的事情来提高效率。很多时候，我们很忙，因为做的事情太多，如果这时能回到原点重新审视一下我们的目标，就会发现我们做了很多无用功。把那些无用功去掉，我们就比其他人进步快，产出高了。 2.很多事情都遵循同一个规律，比如从锦标赛，到找加油站，到处理零售交易，都会用到二叉树，特别是它的一个子类——堆。这些问题，都可以被称为“等价的问题”。在这儿，我们再次看到等价性的重要性。需要强调的是，学习理论很重要。当然，在学习理论的时候，需要了解这个理论为什么会被提出，当时要解决的应用问题是什么，搞清楚这些，便可以一通百通。 我们在解决问题时，很多时候不知不觉地做了一些主观假设，或者说自己给了自己一些前提条件。在上述问题中，我们在很长的时间里，都是假设找最近的加油站这件事，是为我这个人服务的，并没有考虑，这个假设不在题目中，是我们心中缺省默认的。因此我们不会去考虑为我服务和为你服务的关系，在做产品时则不应该有这样的主观假设，否则就把自己限制死了, 无法跳出我们的局限性，进行进一步优化了。 最后，从这个例子你可能已经看出，好的面试官是不怕面试者刷题的，因为他总是可以一层层深入地问下去。而好的面试题不仅可以引导面试往深入进行，而且对从业者还有很深的启发意义。","link":"/2019/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/Google%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%9C%B0%E5%9B%BE%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%89%BE%E5%88%B0%E7%A6%BB%E5%BD%93%E5%89%8D%E6%9C%80%E8%BF%91%E7%9A%84%E5%8A%A0%E6%B2%B9(%E8%BD%AC%E8%BD%BD)/"},{"title":"KMP算法 (转载)","text":"KMP算法是一种改进的字符串匹配算法, 由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此称为KMP算法。 核心：利用匹配失败后的信息，尽量减少模式串和主串的匹配次数以达到快速匹配的目的。具体实现通过一个 next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度为 O(m-n) 普通字符串匹配说明主串：BBC ABCDAB ABCDABCDABDE子串：ABCDABD用子串去匹配主串，获取第一个符合子串的的位置 1). 首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。 2). 因为B与A不匹配，搜索词再往后移。 3). 以此类推直到,直到字符串有一个字符，与搜索词的第一个字符相同为止。 4). 接着比较字符串和搜索词的下一个字符，还是相同。 5). 直到字符串有一个字符，与搜索词对应的字符不相同为止。 6). 这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。 KMP算法说明已知条件： 当空格与D 不匹配时，前面六个字符”ABCDAB”已经匹配成功KMP算法的想法是：设法利用这个已知条件，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。 如何做到这一点？针对已经匹配的字符串”ABCDAB”，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。tip: 如果不匹配到的字母，肯定是 0。比如匹配到”ABCDAB”，那么”D”肯定是 0 子串根据这张表，移动的位数： 1移动位数 = 已匹配的字符数 - 对应的部分匹配值 当空格与”D”不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知最后一个匹配字符B对应的”部分匹配值”为2，因此按照公式算出向后移动的位数：123移动位数 = 已匹配的字符数 - 对应的部分匹配值移动位数 = 6 - 2 = 4 子串需要移动 4 位 2）因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。 因为空格与A不匹配，继续后移一位。 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。 部分匹配表两个重要概念： “前缀” 和 “后缀” 前缀：指除了最后一个字符串之外，一个字符串的全部头组合。 后缀：指除了第一个字符串之外,一个字符串的全部尾组合。 “ABCDABD”的部分匹配表的产生“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。 以”ABCDABD”为例， 12345678910111213－ &quot;A&quot;的前缀和后缀都为空集，共有元素的长度为0；－ &quot;AB&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0；－ &quot;ABC&quot;的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；－ &quot;ABCD&quot;的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；－ &quot;ABCDA&quot;的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为&quot;A&quot;，长度为1；－ &quot;ABCDAB&quot;的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为&quot;AB&quot;，长度为2；－ &quot;ABCDABD&quot;的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。 特殊情况字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 参考链接：阮一峰: 字符串匹配的KMP算法","link":"/2019/10/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/KMP%E7%AE%97%E6%B3%95/"},{"title":"十大经典排序算法(转载)","text":"算法概述算法分类十种常见的排序算法可以分为两大类: 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn),因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序 复杂算法 相关概念 稳定：如果 a 原本在 b 前面， 而 a=b,排序之后仍然在 b 的前面 不稳定： 如果 a 原本在 b 前面，排序之后 a 可能会出现在 b 的后面 时间复杂度：对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数 冒泡排序 (Bubble Sort)冒泡排序是一种简单的排序算法。它重复地走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经常交换慢慢”浮”到数列的顶端。 算法描述 比较相邻的元素。如果第一个比第二个打，就交换它们两个； 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成 动图演示 代码演示1234567891011121314function bubbleSort(arr) { const len = arr.length; for (let i = 0; i &lt; len - 1; i++) { for (let j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { // 相邻元素两两对比 const temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr;}bubbleSort([5, 10, 30, 1, 100, 2]) // 1, 2, 5, 10, 30, 100 选择排序（Selection Sort）选择排序(Selection-sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，知道所有元素均排序完毕。 算法描述n个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为 R[1..n] ，有序区为空 第 i 趟排序 (i=1,2,3…n-1) 开始时，当前有序区和无序区分别为 R[1…i-1] 和 R[i…n] 。该趟排序从当前无序区中-选出关键字最小的记录 **R[k]**，将它与无序区的第1个记录交换 R[1…i] 和 R[i+1…n] 分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1 趟结束，数组有序化。 动图演示 代码演示1234567891011121314151617function selectionSort(arr) { const len = arr.length; let minIndex, temp; for (let i = 0; i &lt; len - 1; i++) { minIndex = i; for (let j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { // 寻找最小的数 minIndex = j; // 将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr;} selectionSort([5, 10, 30, 1, 100, 2]) // 1, 2, 5, 10, 30, 100 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是 O(n²) 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时一般人想到的最多的排序方法了吧。 插入排序（Insertion Sort）插入排序（Insertion-Sort） 的算法描述是一种简单直观的排序算法。它的工作原理通过构建有序序列，对未排序数据，在已排序序列中从后扫描，找到相应位置并插入。 算法描述一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5； 动图演示 代码实现123456789101112131415function insertionSort(arr) { const len = arr.length; let preIndex, current; for (let i = 0; i &lt; len; i++) { preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) { arr[preIndex + 1] = arr[preIndex]; preIndex--; } arr[preIndex + 1] = current; } return arr;}insertionSort([5, 10, 30, 1, 100, 2]) // 1, 2, 5, 10, 30, 100 算法分析插入排序在实现上，通常采用in-place排序（即只需用到 O(1) 的 额外空间的排序），因而在从后往前扫描过程中，需要把反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 希尔排序 (Shell Sort)1959年Shell 发明，第一个突破 O(n²) 的算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫 缩小增量排序 算法描述先将整个待排序的记录排序分成若干子序列分别直接插入排序，具体算法描述： 选择一个增量排序 t1，t2，…，tk， 其中 ti &gt; tj, tk=1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序序列分割成若干个长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量为1时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动图演示 代码演示1234567891011121314151617function shellSort(arr) { const len = arr.length; for (let gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) { // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 for (let i = gap; i &lt; len; i++) { let j = i; const current = arr[i]; while (j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) { arr[j] = arr[j - gap]; j = j - gap; } arr[j] = current; } } return arr;}shellSort([5, 10, 30, 1, 100, 2]) // 1, 2, 5, 10, 30, 100 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。 归并排序归并排序是建立在归并操作上的一种有效的排序算法。该算法采用的是分治法 （Divide and Conquer） 的一个非常典型的应用。将已有的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成为一个有序列表，称为2-路归并。 算法分析 把长度为n的输入序列分成两个长度为 n/2 的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 动图演示 代码实现12345678910111213141516171819202122232425262728293031function mergeSort(arr) { const len = arr.length; if (len &lt; 2) { return arr; } const middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));} function merge(left, right) { const result = []; while (left.length&gt;0 &amp;&amp; right.length&gt;0) { if (left[0] &lt;= right[0]) { result.push(left.shift()); } else { result.push(right.shift()); } } while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;}mergeSort([5, 10, 30, 1, 100, 2]) // 1, 2, 5, 10, 30, 100 算法分析归并排序是一种稳定的排序算法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好得多,因为始终都是O(nlogn）的 时间复杂度。代价是需要额外的内存空间。 快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 算法描述快速排序采用分治把一个串(list) 分成两个子串(sub-list)。具体算法描述如下： 从数列挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准值后面（相同的数可以到任一边）。在这个分区退出后，该基准值就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 动图演示 代码实现123456789101112131415161718192021222324252627282930313233function quickSort(arr, left, right) { var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) { partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); } return arr;} function partition(arr, left ,right) { // 分区操作 let pivot = left, // 设定基准值（pivot） index = pivot + 1; for (let i = index; i &lt;= right; i++) { if (arr[i] &lt; arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index-1;} function swap(arr, i, j) { const temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;}quickSort([5, 10, 30, 1, 100, 2]) // 1, 2, 5, 10, 30, 100 堆排序（Head Sort）堆排序（Head Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父亲结点。 算法描述 将初始待排序关键字序列 （R1、R2…Rn） 构建成大顶堆，此堆为初始的无序区； 将堆元素 R[1] 与最后一个元素 R[n] 交换,此时得到新的无序区 (R1,R2,…Rn-1)和新的有序区(Rn),且满足 **R[1,2…n-1] &lt;= R[n]**； 此交换后新的顶堆 R[1] 可能违反堆的性质，因此需要对当前无序区 (R1,R2,…Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2,…Rn-2) 和新的有序区 （Rn-1, Rn）。不断重复此过程直到有序的元素个数为 n-1,则整个排序过程完成。 动图演示 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445let len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { // 建立大顶堆 len = arr.length; for (let i = Math.floor(len/2); i &gt;= 0; i--) { heapify(arr, i); }} function heapify(arr, i) { // 堆调整 let left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) { largest = left; } if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) { largest = right; } if (largest != i) { swap(arr, i, largest); heapify(arr, largest); }} function swap(arr, i, j) { const temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;} function heapSort(arr) { buildMaxHeap(arr); for (let i = arr.length - 1; i &gt; 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0); } return arr;}heapSort([5, 10, 30, 1, 100, 2]) // 1, 2, 5, 10, 30, 100 计算排序（Counting Sort）计算排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是确定范围的整数。 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项； 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去1 动图演示 代码实现1234567891011121314151617181920212223function countingSort(arr, maxValue) { let bucket = new Array(maxValue + 1), sortedIndex = 0, arrLen = arr.length, bucketLen = maxValue + 1; for (let i = 0; i &lt; arrLen; i++) { if (!bucket[arr[i]]) { bucket[arr[i]] = 0; } bucket[arr[i]]++; } for (let j = 0; j &lt; bucketLen; j++) { while(bucket[j] &gt; 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr;}countingSort([5, 10, 30, 1, 100, 2], 100) // 1, 2, 5, 10, 30, 100 算法分析计算排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度 **O(n+k)**，空间复杂度也是 **O(n+k)**，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键在于这个映射函数的规定。桶排序（Bucket Sort）的工作的原理；假设输入数据服从均匀分布，将数据分到有限的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 算法描述 设置一个定量的数组当做空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排序好的数据拼接起来。 图片演示 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243import insertionSort from './insertionSort' // 引入插入排序算法function bucketSort(arr, bucketSize) { if (arr.length === 0) { return arr; } let i; let minValue = arr[0]; let maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) { if (arr[i] &lt; minValue) { minValue = arr[i]; // 输入数据的最小值 } else if (arr[i] &gt; maxValue) { maxValue = arr[i]; // 输入数据的最大值 } } // 桶的初始化 const DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; const buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) { buckets[i] = []; } // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) { buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); } arr.length = 0; for (i = 0; i &lt; buckets.length; i++) { insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (let j = 0; j &lt; buckets[i].length; j++) { arr.push(buckets[i][j]); } } return arr;}bucketSort([5, 10, 30, 1, 100, 2], 100) // 1, 2, 5, 10, 30, 100 算法分析桶排序最好情况下使用线性时间 O(n),桶排序的时间复杂度，取决与各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 **O(n)**。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大 基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法描述 取得数组中的最大数，并取得位数； arr 为原始数组，从最低位开始取每个位组成 radix 数组； 对 radix 进行计数排序（利用计数排序适用于小范围的特点）； 动图演示 代码实现1234567891011121314151617181920212223242526var counter = [];function radixSort(arr, maxDigit) { var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) { for(var j = 0; j &lt; arr.length; j++) { var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } var pos = 0; for(var j = 0; j &lt; counter.length; j++) { var value = null; if(counter[j]!=null) { while ((value = counter[j].shift()) != null) { arr[pos++] = value; } } } } return arr;}// 注意 6 是数组 arr的位数,也就是长度radixSort([5, 10, 30, 1, 100, 2], 6) // 1, 2, 5, 10, 30, 100 基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n) 的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n) 的时间复杂度。假如待排数据可以分为 d 个关键字，则基数排序的时间复杂度将是 O(d*2n) ，当然 d 要远远小于 n ，因此基本上还是线性级别的。 基数排序的空间复杂度为 **O(n+k)**，其中 k 为桶的数量。一般来说 n&gt;&gt;k，因此额外空间需要大概 n 个左右。 参考：十大经典排序算法（动图演示）","link":"/2019/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E8%BD%AC%E8%BD%BD/"},{"title":"商品 SKU 组合查询算法实现 (转载)","text":"前言在系统学习了98集的数据结构和算法之后，以为自己的水平已经达到了一个新的高度了。但是在做一个APP的时候，发现自己竟然处理不了加入购物车的多级SKU对应的库存问题。着实是一个不小的打击。在解决问题之后，记录下来，牢记耻辱。 什么是SKU维基百科解释: 存货单位（英语：stock keeping unit，SKU/ˌɛsˌkeɪˈjuː/）[1]，也翻译为库存单元，是一个会计学名词，定义为库存管理中的最小可用单元，例如纺织品中一个SKU通常表示规格、颜色、款式，而在连锁零售门店中有时称单品为一个SKU。最小库存管理单元可以区分不同商品销售的最小单元，是科学管理商品的采购、销售、物流和财务管理以及POS和MIS系统的数据统计的需求，通常对应一个管理信息系统的编码。 举个例子: 如图所示 该商品有四个属性单位 公母、重量、数量、颜色分类四个属性又有对应的 单位 123456{ '公母' : ['公的', '母的'], '重量' : ['100克', '200克', '300克', '400克'] '数量' : ['一对', '两对', '三对', '四对'] '颜色分类' : ['花色', '原色', '黑色', '金色']} 如图选中的的 ['200克', '三对'] 是一个SKU, ['公的', '花色'] ['300克', '三对'] ['三对'] ['母的','300克', '三对'] ['公的','100克', '三对','原色']这些组合都是一个SKU 也就是说明，公母、重量、数量、颜色分类对应的属性，单独或者两个属性或者以上的组合都是一个SKU 业务场景在电商项目很几率在遇上，商品 SKU 组合查询的实现。如图： 以 公母、重量组合成对应的 SKU如下表格: 公母 重量 库存 公 100克 10 公 200克 10 公 300克 10 公 400克 10 母 100克 10 母 200克 10 母 300克 0 母 400克 10 图中只是选中的 ['母'] 有库存，然后查找对照上面的表格 ['母', '300克']。当用户选择['母'] 的时候，那么对应的['母的', '300克']， 300克的选项应该显示为不可选择状态(平常用淘宝的觉得这个功能很简单，但…实际开发起来自己却不会(尴尬)。) 解决方案场景还原12345678910111213141516171819202122232425262728 // 属性集var key = [ {name: '公母', item: ['公的', '母的']}, {name: '重量', item: ['100克', '200克', '300克']}, {name: '数量', item: ['一对', '两对', '三对']}];// 数据集var sku = { '公的;100克;一对': {price: 100, count: 10}, '公的;200克;一对': {price: 101, count: 0}, '公的;300克;一对': {price: 102, count: 12}, '母的;100克;一对': {price: 103, count: 13}, '母的;200克;一对': {price: 104, count: 14}, '母的;300克;一对': {price: 105, count: 3}, '公的;100克;两对': {price: 100, count: 0}, '公的;200克;两对': {price: 101, count: 11}, '公的;300克;两对': {price: 102, count: 9}, '母的;100克;两对': {price: 100, count: 0}, '母的;200克;两对': {price: 101, count: 11}, '母的;300克;两对': {price: 102, count: 0}, '公的;100克;三对': {price: 100, count: 10}, '公的;200克;三对': {price: 101, count: 11}, '公的;300克;三对': {price: 102, count: 3}, '母的;100克;三对': {price: 100, count: 10}, '母的;200克;三对': {price: 101, count: 11}, '母的;300克;三对': {price: 102, count: 2}}; 有了这两组数据，就可以渲染 DOM 结构，然后用户点击的时候，获取对应的 key 拼接，再根据key从 数据集 里面 取得对应的信息 See the Pen 商品组合SKU算法实现(基础版) by bamboo (@celverbamboo) on CodePen. 上面这个演示有个最大的问题就是，必须把每个属性都选择后，才能获取到对应的库存和价格，如果没有选择完整，就无法获取对应的数据。 原因也很简单，因为 数据集 里没有提供嘛。比如只选择了['公的']，拼接出来之后，就变成了公的;;,再看看数据集，里面没有所以需要对数据集进行处理。 对数据集进行处理首先，我们希望得到如下数据当前sku为 ['公的', '100克', '一对'] 1234567['公的', '', '']['', '100克', '']['', '', '一对']['公的', '100克', '']['公的', '', '一对']['', '100克', '一对']['公的', '100克', '一对'] 如果sku['公的', '100克', '一对', '花色'] 123456789101112131415161718['公的', '', '', '']['', '100克', '', '']['', '', '一对', '']['', '', '', '花色']['黑', '100克', '', '']['黑', '', '一对', '']['黑', '', '', '花色']['', '100克', '一对', '']['', '100克', '', '花色']['', '', '一对', '花色']['黑', '100克', '一对', '']['黑', '100克', '', '花色']['黑', '', '一对', '花色']['', '100克', '一对', '花色']['黑', '100克', '一对', '花色'] 由此可以得出，我们需要 从 m 个不同元素中取出 n 个元素的组合算法，然后根据该组合，并且获取对应的sku的key，把重复sku的key库存加上。 算法代码(JS版) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// 属性集const keys = [ ['10', '11'], ['20', '21'], ['30', '31', '32']];// 数据集, 一般由后台返回const data = { '10;20;30': { price: 1, count: 0 }, '10;20;31': { price: 2, count: 2 }, '10;20;32': { price: 3, count: 3 }, '11;20;30': { price: 4, count: 4 }, '11;20;31': { price: 5, count: 5 }, '11;20;32': { price: 6, count: 6 }, '10;21;30': { price: 7, count: 0 }, '10;21;31': { price: 8, count: 8 }, '10;21;32': { price: 9, count: 0 }, '11;21;30': { price: 10, count: 10 }, '11;21;31': { price: 11, count: 11 }, '11;21;32': { price: 12, count: 0 },};//保存最后的组合结果信息const SKUResult = {};// 调用函数initSKU();console.log(SKUResult);//初始化得到结果集function initSKU() { let i, j, skuKeys = getObjKeys(data); // 过滤获取所有对应的sku-key数组 for (i = 0; i &lt; skuKeys.length; i++) { const skuKey = skuKeys[i];//一条SKU信息key const sku = data[skuKey]; //一条SKU信息value const skuKeyAttrs = skuKey.split(';'); //SKU信息key属性值数组 skuKeyAttrs.sort(function(value1, value2) { return parseInt(value1) - parseInt(value2); }); //对每个SKU信息key属性值进行拆分组合 const combArr = combInArray(skuKeyAttrs); for (j = 0; j &lt; combArr.length; j++) { addSKUResult(combArr[j], sku); } //结果集接放入SKUResult SKUResult[skuKeyAttrs.join(';')] = { count: sku.count, prices: [sku.price] } }}//获得对象的keyfunction getObjKeys(obj) { if (obj !== Object(obj)) throw new TypeError('Invalid object'); const keys = []; for (const key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { keys[keys.length] = key; } } return keys;}//把组合的key放入结果集SKUResultfunction addSKUResult(combArrItem, sku) { const key = combArrItem.join(';'); if (SKUResult[key]) {//SKU信息key属性· SKUResult[key].count += sku.count; SKUResult[key].prices.push(sku.price); } else { SKUResult[key] = { count: sku.count, prices: [sku.price] }; }}/** * 从数组中生成指定长度的组合 * 方法: 先生成[0,1...]形式的数组, 然后根据0,1从原数组取元素，得到组合数组 */function combInArray(aData) { if (!aData || !aData.length) { return []; } const len = aData.length; const aResult = []; for (let n = 1; n &lt; len; n++) { const aaFlags = getCombFlags(len, n); // console.log(JSON.stringify(aaFlags)) while (aaFlags.length) { const aFlag = aaFlags.shift(); const aComb = []; for (let i = 0; i &lt; len; i++) { aFlag[i] &amp;&amp; aComb.push(aData[i]); } aResult.push(aComb); } } return aResult;}/** * 得到从 m 元素中取 n 元素的所有组合 * 结果为[0,1...]形式的数组, 1表示选中，0表示不选 */function getCombFlags(m, n) { if (!n || n &lt; 1) { return []; } const aResult = []; const aFlag = []; let bNext = true; let i, j, iCnt1; for (i = 0; i &lt; m; i++) { aFlag[i] = i &lt; n ? 1 : 0; } aResult.push(aFlag.concat()); while (bNext) { iCnt1 = 0; for (i = 0; i &lt; m - 1; i++) { if (aFlag[i] === 1 &amp;&amp; aFlag[i + 1] === 0) { for (j = 0; j &lt; i; j++) { aFlag[j] = j &lt; iCnt1 ? 1 : 0; } aFlag[i] = 0; aFlag[i + 1] = 1; const aTmp = aFlag.concat(); aResult.push(aTmp); if (aTmp.slice(-n).join('').indexOf('0') === -1) { bNext = false; } break; } aFlag[i] === 1 &amp;&amp; iCnt1++; } } return aResult;} 在调用initSKU之后，打印 SKUResult则获得以下结果。 完整版在获得数据集之后,在点击对应的SKU属性之后，应该获取当前的SKU，然后和其它的属性对应的SKU进行遍历拼接。即可获得从 SKUResult的商品信息。效果如图： See the Pen 商品组合SKU实现算法(完整版) by bamboo (@celverbamboo) on CodePen.","link":"/2019/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%95%86%E5%93%81-SKU-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"},{"title":"数据结构与算法之美 -- 从“栈”的应用实例角度，学习栈","text":"通常很多关于数据结构与算法的文章和视频，都是先解释栈的定义，然后再一些的例子以此来说明。不过这次我准备倒过来，先给具体的案例，然后通过反证法为什么这个场景应该使用栈，而不是其它的数据结构。先浏览下图，对栈这个数据结构有印象，后面介绍具体案例逐一解释。 应用场景 浏览器的历史记录相信大家对浏览器的历史记录都不陌生，比如你在浏览一个网页时，误点击网页中的其中一个链接，网页进行了跳转。这个时候，你就点击类似一个左箭头的图标,然后就可以返回到刚才浏览器的页面。如下所示 不知道，大家有没有注意一点，在上面的动图中，在你点击一个网页的某一个地方进入另一个页面的时候，右箭头是置灰不可点击的。而在你以为误点击之后，点击左箭头返回的时候，右箭头就显示不置灰表示可以点击了。这是为什么呢？答案就是，这里使用了栈数据结构，并应用了栈的特性先进后出。 以当前这个例子为例，你进入一个页面的时候，其实浏览器就把你的进入的这个页面的记录，进行入栈的操作，这个时候当前栈就了一个元素。当你在当前页面点击某个链接的时候进入另个一个页面的同时一样也把当前页面的记录进行入栈操作，这个时候当前栈则有两个元素。暂且把这个栈，称为“后退栈”，意思就是专门用来进行后退操作的栈。 接下来，你发现点错了链接进入了你不想要的页面，但你想进入的页面是在上一个页面。所以，你这个就会点击浏览器左上角的后退按钮（左箭头），返回刚才的页面。同样的，这个时候会有一个叫做“前进栈”,把刚才从“后退栈”出栈的元素入栈到这个“前进栈”。整个过程，如下图所示。 了解上面的过程，我们就知道，之所在进入第一个页面的时候，前进的右箭头之所置灰，是因为“前进栈”当前没有元素，所以置灰。同样的，如果“后退栈”检测到当前只有一个元素，浏览器的后退左箭头就会置灰，因为没有元素可以给你出栈了嘛。 最后，从整个过程可以看出，栈数据结构是一个先进后出的方式。为什么？浏览器的历史记录这个案例就知道，因为栈有一堵“墙”，你只能先进后出。也正是因为这堵墙，浏览器得以实现检测当前是否使用前进后退的功能，而队列则不行，因为队列没有“墙”，所以这里不适合使用队列这种数据结构。","link":"/2020/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E%20--%20%E4%BB%8E%E2%80%9C%E6%A0%88%E2%80%9D%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E8%A7%92%E5%BA%A6%EF%BC%8C%E5%AD%A6%E4%B9%A0%E6%A0%88/"},{"title":"现实中的RSA非对称沟通，以及理解RSA算法","text":"在工作中以及生活中，我发现很多人的沟通有很多问题，简单来说“问非所需”。这就让我想到了RSA算法很类似，因为它是非对称的，恰好和RSA算法很相似，所以通过这篇文章理解RSA算法和谈谈如何进行有效地提出问题,有时候往往能问出一个有效的问题，其实问题就解决一半了。 什么是RSA算法RSA算法，中文名称为”公钥加密算法”。 阮一峰老师说，如果你问我，哪一种算法最重要？因为它是计算机通信安全的基石，保证了加密数据不会被破解。你可以想象一下，信用卡交易被破解的后果。 一点历史1976年以前，所有的加密方法都是同一种模式： （1）甲方选择某一种加密规则，对信息进行加密； （2）乙方使用同一种规则，对信息进行解密。 由于加密和解密使用同样规则（简称”密钥”），这被称为 “对称加密算法”（Symmetric-key algorithm）。 1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为”Diffie-Hellman密钥交换算法”。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥。 这种新的加密模式被称为 **”非对称加密算法”**。 （1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。 （2）甲方获取乙方的公钥，然后用它对信息加密。 如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。 这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。 具体原理可以点击这里查看 现实例子比如A君是一个刚刚踏入产品经理的一个实习生，有一天问了我在工作上的一些问题，他问的问题也很有趣, 比如”什么是接口，什么是字段等等” 一开始听到这些问题有点懵，因为他是非科班出身的，计算基础很差，不懂这些很正常。但是，另人疑惑的是为什么他会问这种问题，这就让人很奇怪了，在我的追问之下,原来他想了解这些问题原因是为了更好跟开发人员的沟通。 不过他提的问题还是不对，因为如果要真正和开发人员非常好的沟通，需要对计算机有个整体的了解。至少得懂计算机基础、计算机组成和原理、计算机操作系统、计算机网络原理等等，同时还得会一些编程。 鉴于他的情况，我跟他说你做为一个产品经理，目前了解这些没有什么用，时间上也赶不及，你现在最重要的是清晰表达你需要什么就好了，至于他们怎么做，怎么实现，那是开发人员的事情。至于计算机相关知识，以后慢慢补充就行。 他听了之后，感叹一声，“你这么说我就懂了”。 实际，他想要了解的不是开发上的一些技术的问题，而是如何做好产品经理的工作。 总结A君提的问题以及想要的答案，很像RSA算法里面的公钥和私钥，虽然这个比喻不太恰当，但比较容易理解，A君刚开始问的问题是公钥，其实他真正想要问的其实私钥，但他自己并不知道私钥是什么，所以往往这种碰到这种问题，往往要理解背后的私钥是什么才可以解决问题。不然的话，沟通是非常低效的，最后变成了“问非所答”。 RSA算法和这种沟通，都是具有非对称性，通过这个例子，不仅可以理解RSA算法，也能收获理解什么才是有效的沟通。 参考链接 RSA算法原理（一） RSA算法原理（二）","link":"/2020/04/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%8E%B0%E5%AE%9E%E4%B8%AD%E7%9A%84RSA%E9%9D%9E%E5%AF%B9%E7%A7%B0%E6%B2%9F%E9%80%9A%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%90%86%E8%A7%A3RSA%E7%AE%97%E6%B3%95/"},{"title":"电话号码排序组合(二维数组排序组合)","text":"tip: 有时候不一定追求的效率，代码思路也要简单易懂，思路清晰 题目电话号码排序组合 解题思路1.1~9的键值对应用一个数组来对应，下标则是对应电话号码的key 123// 建立电话号码键盘映射let map = ['', 1, 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']// 空字符串纯属占位 2.算法解析如果当用户输入两个键值时,例如 2,3,似乎只需要遍历两次运算就能得到结果，但是如果用户输入的键值超过2个以上呢。那么用户输入键值是不确定的，所以简单用for循环来解决肯定是不行的。 假设用户输入3个键值(2,3,4),那么我们可以先运算前面两个(2,3)得到一个数组，然后替换(2,3)的位置，然后再进行相同的运算方法。那么很明显，这里需要用到了递归。 3.代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function combinedSort(str) { // 建立电话号码键盘映射 const map = ['', 1, 'abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'] const num = str.split('') const code = [] num.forEach((item) =&gt; { if (map[item]) { code.push(map[item]) } }) const comb = (arr) =&gt; { const arrLen = arr.length if (arrLen) { // 临时变量用来保存前两个组合的结果 const tmp = [] // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素 for (let i = 0, len = arr[0].length; i &lt; len; i++) { if (arrLen &gt;= 2) { for (let j = 0, len2 = arr[1].length; j &lt; len2; j++) { tmp.push(`${arr[0][i]}${arr[1][j]}`) } } else if (arrLen === 1) { tmp.push(arr[0][i]) } } arr.splice(0, 2, tmp) if (arr.length &gt; 1) { comb(arr) } else { return tmp } return arr[0] } else { return [] } } return comb(code)}// 测试栗子combinedSort('23') // ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']combinedSort('234') /* [ 'adg', 'adh', 'adi', 'aeg', 'aeh', 'aei', 'afg', 'afh', 'afi', 'bdg', 'bdh', 'bdi', 'beg', 'beh', 'bei', 'bfg', 'bfh', 'bfi', 'cdg', 'cdh', 'cdi', 'ceg', 'ceh', 'cei', 'cfg', 'cfh', 'cfi'] */combinedSort('') // []combinedSort('2') // ['a','b','c'] 通过","link":"/2019/10/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E6%8E%92%E5%BA%8F%E7%BB%84%E5%90%88(%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%BB%84%E5%90%88)/"},{"title":"算法效率的度量方法","text":"前言算法效率，一般是算法的执行时间 影响算法效率的因素 算法采用的策略、方案 编译产生的代码质量 问题的输入规模 机器执行指令的速度 由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模 算法的好坏取决于：两个重要概念：时间复杂度和空间复杂度时间复杂度：时间复杂度是指执行算法所需要的计算工作量,简单来说，执行次数(循环次数) == 时间 空间复杂度：空间复杂度是指执行这个算法所需要的内存空间,简单来说，执行时所占用的空间，即内存大小 常见函数的时间复杂度图: 小甲鱼的攻略方法（小甲鱼是个人） 用常数 1 取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高项 如果最高阶存在且不是1，则去除与这个项相乘的常数 常用的时间复杂度所耗费的时间从小到大依次是: O(1) &lt; O(log(n)) &lt; (n) &lt; O(nlog(n)) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) 度量方法在算法中，大O法来表示时间的复杂度， 比如O(1)、O(logn)、O(n)、O(n^2)。不知你们有没有看过港剧的警匪片，里面经常有O记这个单位，其实是重案组的简称。为了方便记忆，你们这么理解，如果你碰到大量数据需要进行处理（重大案件）或者需要找出大量数据里面的前几个（找真凶），那么这时候请派出”O记” 事后统计法就是函数开始调用的时候，记录开始调用时间和结束调用时间exp:1234567const arr = [];for(let i=0; i&lt;100000; i++){ arr.push(Math.random());}console.time(&quot;sort&quot;);arr.sort();console.timeEnd(&quot;sort&quot;); 这办法缺陷很多，主要原因如下： 受计算机硬件和语言的影响 测试数据难以设计 需要手动编写测试用例 2）事前分析估算法 首选这种方法，侧重的是研究算法随着输入规模扩大增长量的一个抽象，而不是精确地定位需要执行多少次。不考虑算法效率的因素的1、2、4点。 判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高项）的阶数。 看图体会一下： 1算法G是2n^2，算法H是3n+1，算法I是 2n^+3n+1 次数 算法G（2n^2) 算法H（3n+1） 算法I（2n^2+3n+1） n=1 2 4 6 n=2 8 7 15 n=5 50 16 66 n=10 200 31 231 n=100 2000 301 20301 n=1000 2000000 3001 200301 n=10000 200000000 30001 200030001 n=100000 20000000000 300001 20000300001 n=1000000 2000000000000 3000001 2000003000001 如何利用大O法来判断函数的运行效率分析算法时间复杂度的步骤: 用常数 1 取代运行时间中的所有加法常数; 在修改后的运行次数函数中，只保留最高阶项; 如果最高阶项存在且不是1，则去除与这个项相乘的常数; 得到的最后结果就是大O阶。 O(1) 12345678int sum = 0, n = 100;printf(“常数阶\\n”);printf(“常数阶\\n”);printf(“常数阶\\n”);printf(“常数阶\\n”);printf(“常数阶\\n”);printf(“常数阶\\n”);sum = (1+n)*n/2; // 无论 n 多大，都是执行一次 O(n) 12345int i , n = 100, sum = 0;for( i=0; i &lt; n; i++ ) // 执行次数随着 n 的增加而增加{ sum = sum + i;} O(n^2) 12345678int i, j, n = 100;for( i=0; i &lt; n; i++ ) { for( j=0; j &lt; n; j++ ) { printf(“I love FishC.com\\n”); }} n等于100，也就是说外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环出来，需要执行100*100次，也就是n的平方。所以这段代码的时间复杂度为O(n^2) 12345678int i, j, n = 100;for( i=0; i &lt; n; i++ ){ for( j=i; j &lt; n; j++ ) { printf(“不一样\\n”); }} 由于当i=0时，内循环执行了n次，当i=1时，内循环则执行n-1次……当i=n-1时，内循环执行1次，所以总的执行次数应该是：n+(n-1)+(n-2)+…+1 = n(n+1)/2 = n^2/2+n/2忽略最高项n^2的乘数以及其余项,得出O(n^2). 4）O(logn) 12345int i = 1, n = 100;while( i &lt; n ){ i = i * 2;} 由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于或等于n，则会退出循环。于是由2^x = n得到x = log₂n，所以这个循环的时间复杂度为O(log₂n)。 常见的时间复杂度: 例子 时间复杂度 装逼术语 5201314 O(1) 常数阶 3n+4 O(n) 线性阶 3n^2+4n+5 O(n^2) 平方阶 3log(2)n+4 O(logn) 对数阶 2n+3nlog(2)n+14 O(nlogn) nlogn阶 n^3+2n^2+4n+6 O(n^3) 立方阶 2^n O(2^n) 指数阶 (终于明白吴军老师，所说指数级增长的可怕了)","link":"/2019/10/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95/"},{"title":"算法时间复杂度和空间复杂度的计算","text":"算法，即解决问题的方法。同一个问题，使用不同的算法，虽然得到的结果相同，但是耗费的时间和资源是不同的。 就比如要拧一个螺母，使用扳手还是钳子是有区别的，虽然使用钳子也能拧螺母，但是没有扳手好用。 “条条大路通罗马”，解决问题的算法有多种，这就需要判断哪个算法“更好”。 算法VS程序很多人误以为程序就是算法，其实不然：算法是解决某个问题的想法、思路；而程序是在心中有算法的前提下编写出来的可以运行的代码。 例如，要解决依次输出一维数组中的数据元素的值的问题，首先想到的是使用循环结构（ for 或者 while ），在有这个算法的基础上，开始编写程序。 所以，算法相当于是程序的雏形。当解决问题时，首先心中要有解决问题的算法，围绕算法编写出程序代码。 有算法一定能解决问题吗？对于一个问题，想出解决的算法，不一定就能解决这个问题。 例如拧螺母，扳手相对于钳子来说更好使（选择算法的过程），但是在拧的过程（编写程序的过程）中发现螺母生锈拧不动，这时就需要另想办法。 为了避免这种情况的发生，要充分全面地思考问题，尽可能地考虑到所有地可能情况，慎重选择算法（需要在实践中不断地积累经验）。 “好”算法的标准对于一个问题的算法来说，之所以称之为算法，首先它必须能够解决这个问题（称为 准确性）。其次，通过这个算法编写的程序要求在任何情况下不能崩溃（称为 健壮性）。 如果准确性和健壮性都满足，接下来，就要考虑最重要的一点：通过算法编写的程序，运行的效率怎么样。 运行效率体现在两方面： 算法的运行时间。（称为 “时间复杂度”） 运行算法所需的内存空间大小。（称为 “空间复杂度”） 好算法的标准就是：在符合算法本身的要求的基础上，使用算法编写的程序运行的时间短，运行过程中占用的内存空间少，就可以称这个算法是“好算法”。 调查表明，人们对于软件或者 APP 的运行效率有极高的要求，例如对于网页打开的忍耐极限是 6 秒甚至更短，如果你设计的网页打开的时间超过 6 秒，多数人会在 4 秒甚至 3 秒的时候毫不犹豫地关掉而去浏览其他网页。在这个大背景下，一个好的“算法”更注重的是时间复杂度，而空间复杂度只要在一个合理的范围内就可以。 时间复杂度的计算计算一个算法的时间复杂度，不可能把所有的算法都编写出实际的程序出来让计算机跑，这样会做很多无用功，效率太低。实际采用的方法是估算算法的时间复杂度。 在学习C语言的时候讲过，程序由三种结构构成：顺序结构、分支结构和循环结构。顺序结构和分支结构中的每段代码只运行一次；循环结构中的代码的运行时间要看循环的次数。 由于是估算算法的时间复杂度，相比而言，循环结构对算法的执行时间影响更大。所以，算法的时间复杂度，主要看算法中使用到的循环结构中代码循环的次数（称为“频度”）。次数越少，算法的时间复杂度越低。 例如：a) ++x; s=0;b) for (int i=1; i&lt;=n; i++) { ++x; s+=x; }c) for (int i=1; i&lt;=n; i++) { for (int j=1; i&lt;=n; j++) { ++x; s+=x; } } 上边这个例子中，a 代码的运行了 1 次，b 代码的运行了 n 次，c 代码运行了 n*n 次。 时间复杂度的表示算法的时间复杂度的表示方式为： 1O(频度) 这种表示方式称为大“O”记法。 1注意，是大写的字母O，不是数字0。 如果a、b、c组成一段程序，那么算法的时间复杂度为O(n^2+n+1)。但这么表示是不对的，还需要对n2+n+1进行简化。 简化的过程总结为3步： 去掉运行时间中的所有加法常数。（例如 n2+n+1，直接变为 n^2+n） 只保留最高项。（n2+n 变成 n^2） 如果最高项存在但是系数不是1，去掉系数。（n^2 系数为 1） 所以，最终a、b和c合并而成的代码的时间复杂度为O(n^2)。 常用的时间复杂度的排序列举了几种常见的算法时间复杂度的比较（又小到大）： 1O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(n^2)平方阶 &lt; O(n^3)(立方阶) &lt; O(2^n) (指数阶) 拿时间换空间，用空间换时间算法的时间复杂度和空间复杂度是可以相互转化的。 谷歌浏览器相比于其他的浏览器，运行速度要快。是因为它占用了更多的内存空间，以空间换取了时间。 算法中，例如判断某个年份是否为闰年时，如果想以时间换取空间，算法思路就是：当给定一个年份时，判断该年份是否能被4或者400整除，如果可以，就是闰年。 如果想以空间换时间的话，判断闰年的思路就是：把所有的年份先判断出来，存储在数组中（年份和数组下标对应），如果是闰年，数组值是1，否则是0；当需要判断某年是否为闰年时，直接看对应的数组值是1还是0，不用计算就可以马上知道。","link":"/2019/11/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AE%A1%E7%AE%97/"},{"title":"锦标赛排序算法（转载）","text":"为什么要发明一种不太容易理解的算法？前提: 不使用锦标赛排序算法，算法时间复杂度为 n * log(n)，相当于快速排序因为在特定的场合下，它更快速。比如说，如果我们需要选出第一名，这种算法的复杂度只有 N，不是 N 乘以 log(n)次计算就可以了。如果还需要算出第二名，则额外增加log(n)次计算就可以了，对第三名也是如此。也就是说，这种方法在从 N 个数据中选出 K 个数据的事情中特别快。 题目假定有二十五名短跑选手比赛竞争金银铜牌，赛场上有五条赛道，因此一次可以有五个人同时比赛。比赛并不计时，只看相应的名次。假如选手的发挥是稳定的，也就是说如果 A 比 B 跑得快，B 比 C 跑得快，那么 A 一定比 C 跑得快。 思路第一步，将 25 名选手分为五个组，每组五个人，为了便于说明，我们不妨把这25人根据所在的组进行编号，A1-A5在A组，B1-B5…最后E1-E5在最后E组。 然后让每个组进行分别比赛，排出各组的名次来。不失一般性（数学中的一种常见表达），我们假设他们的名次就是他们在小组中的编号，即A组的名次是A1、A2、A3、A4、A5，B组和其它组的名次也是类似（如下图）： 第二步，让各组的第一名，也就是A1、B1、C1、D1、E1再比一次，上图中是第一排红颜色的，这样就能决出第一名。不失一般性，我们假设A1在这次比赛中获胜，这样我们就知道了第一名。 由于A1是第一名，根据我们前面讲的淘汰赛的问题，A2可能也很厉害，只是运气不好，小组赛遇到了A1，当A1已经获得冠军了，他就应该作为亚军的候选人。接下来，就进入第三步。 第三步，A2和另外四个组的第一名竞争亚军。如果这一次A2赢了，他显然是亚军，就由A3递进参加争夺第三名的比赛。我在下图中用红色圈定了这种情况下参加第八次比赛的五位选手。如果A2没有赢，另外四个组的某个第一名赢了，那个赢的人就是亚军，就由那个组下一位选手递进，决逐第三名。 第四步，如上图选出的五个人进行第三名的比赛，至此，前三名全部产生。 上面这种方法，表现可能算是中规中矩，但不算完美。 那么这个问题最好的答案是什么呢？其实前六次比赛都是必须的，也就是说，最佳答案的第一步和第二步都是必须的。但是，在上述方案中，有一个信息被忽略了，那就是第六组比赛（即五个第一名的比赛）结束之后，最后的两名已经没有资格决逐第三名了。我们不妨假设那一次比赛从最快到最慢的结果是A1、B1、C1、D1、E1。在D1和E1之前已经有三名选手了，他们肯定不是前三名。 那么谁还会是第二名的候选呢？根据锦标赛排序的原则，直接输给第一名的人，也是A组中的A2，以及最后附加赛输给他的B1，仅此两人而已。接下来我们要问，除了A2和B1，谁还会是第三名的候选呢？和A1在某一组比赛的第三名，他们是A3、C1，或者输给第二名候选人B1的人那个人，即B2。 因此，第二、三名的候选人一共只有五个，即A2、A3、B1、B2和C1（下图中的红色选手），刚好凑一组。第七次，让他们五个再跑一次即可。这样加上前六次，只需要赛七组，这是最佳的方法。 这种方法为什么很多人想到的赛八次的方法更有效一点？原因可以归结为两点： 首先是少做了一些无用功。在八次的比法中间，最后两次让D1、E1不断参加没有必要的比赛，实际上是浪费资源。有些写的计算机软件速度快，有些人的慢，主要差别就在于那些慢的软件，多做了很多无用功。 其次，要善用信息。前几次比赛的结果里面有很多有用的信息，比如其实已经筛选出了前三名的候选，这些信息要善于使用。","link":"/2019/10/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%94%A6%E6%A0%87%E8%B5%9B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"用粗调和精调优化项目","text":"优化极限所在 根据香农第二定律，一个移动网络只要传输的带宽固定了，整个网络的传输率就被限制死了。《吴军的谷歌方法论第152封信 | 维特比和高通公司》 这给我了一个提示，同理，我们在优化项目的时候，同时也要考虑和弄清楚”通信的带宽上限是多少“，也就是服务器的性能 举个例子，如果 一个服务器是 1核2G，带宽为1M，另一个服务器是，4核3G，带宽为2M 很明显第二个服务器性能远远大于第一个服务器，假设我们现在优化前端首页加载时间，那么第一个服务器，无论怎么优化加载时间都会比第二个服务器的时间要长。 因为第一个服务器的性能限死了，首页加载的时间必定大于第二个服务器。第一个服务器性能的极限决定了它不能超越第二服务器。 粗调和精调这里以优化前端项目为例子，网上的各种优化前端项目的文章有很多，比如非常出名雅虎军规。我也阅读不了不少这种文章和了解各种优化前端的技巧。 但，这里有一个问题就是，在我优化我司的项目的时候，我没有一个比较明确的优化思路，或者说我优化那个地方，效果最好。 这一次，我想用吴军老师精调和粗调的方法，进行优化项目。 为什么使用粗调和精调优化项目？要解释这个问题，首先得了解什么是粗调和精调。 如果我要问，有一个数字是40.365，比如说天文望远镜的焦距，你怎样达到它？ 一般人按照生活直觉，直奔这个数字去就可以了。但是在工程上，这样简单的一个数字并非抽象的，而是非常具体的。 如果是天文望远镜的焦距，你是否会用手把握着望远镜的那个圆筒，前后移动，估摸着镜片之间的距离来调整呢？如果这是导弹发射的角度，你自己是否会用个量角器估算导弹和水平线的角度呢？显然我们不能这么做，我们必须有一个可以准确达到这个数字的办法，这就是工程的思维—— 不仅仅要知道目标在哪里，还必须设计一个能够达到目标的道路。 对于天文望远镜，设计它们的工程师必须设计一个能够转动的旋钮，让它的长度接近40.365这个数字。 但是接下来的问题来了，如果这个旋钮每转动一圈，调整的幅度太大，要调到小数点后面三位几乎不可能。如果每转动一圈调整的幅度太小，比如每次调整0.001，那么可能要花很长时间才能调到40.365这个数。类似地，调整导弹的角度也是如此。 类似地，这里可以设计一个按钮每次转动精度为1的，第二一个按钮精度为0.1,第三个按钮精度则为0.01。 优化项目同样是如此，每一次调整被称为是一次迭代，调整的幅度被称为迭代的步长。一开始的时候，迭代的步长要比较大，这样能够很快地确定大致范围，效率比较高。 粗调优化PS:服务器是1核2G，带宽1兆，一个小水管 优化手段： 服务器器开启 gzip 压缩 效果：未开启gzip之前加载时间： 开启gzip之后加载时间： **项目加载时间从 23s 变成 7.6s, 时间减少66%**，效果明显 微调 优化代码，减少首页加载ajax请求 使用CDN 将 CSS 放在文件头部，JavaScript 文件放在底部 使用字体图标 iconfont 代替图片图标等等一些常规优化手段，效果就不展示了，效果不算很明显。 总结虽然使用粗调和精调优化项目比较简单，但是便于记忆和操作理解。比如优化项目这个例子，我需要找到粗调的方法，然后再去精调，这样优化项目才能做到事半功倍。 同时，该方法也告诉我们，我们人生做事情的方向是对，通过努力，必然可以达到目的，其中确认方向是粗调，在做事情的时候，调整方法，是微调。 参考链接 吴军的谷歌方法论第025封信 | 粗调和精调：从一道Google的面试题谈起 吴军的谷歌方法论第152封信 | 维特比和高通公司","link":"/2021/02/26/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%94%A8%E7%B2%97%E8%B0%83%E5%92%8C%E7%B2%BE%E8%B0%83%E4%BC%98%E5%8C%96%E9%A1%B9%E7%9B%AE/"},{"title":"一篇文章理解前端缓存","text":"首先记住一点,HTPP1.1新生代总比老的HTTP1.0总要有更多的优势。 Expires Expires: HTTP 1.0的规范。用来告诉浏览器这个资源的过期时间。 例如: Expires: Wed, 26 Aug 2020 06:32:49 GMT原理：1、每次请求这个资源时，浏览器自动判断是否超出了这个时间。2、如果没有超出，就直接使用缓存(http status:200 from cache)。3、不发送请求。如果超出，看其他参数的情况。 缺点：由于Expires这个时间是服务器端的时间，如果客户端的时间和服务器端的时间有误差，那么Expires就没什么用了。 示例： Etag 主: Etag辅: If-None-Match 或 If-MatchETag: HTTP 1.1规范。服务器通过算法计算出的资源唯一标志符（类同Md5码）。用来帮助服务器控制Web端的缓存验证 原理：1、当浏览器请求服务器的某项资源时 -&gt; A，服务器根据 A 算出一个哈希值 -&gt; (aa620aa68c06d8a929526e0bb6f35b8ebb090f2c)2、并通过 ETag 返回给浏览器，浏览器把 “aa620aa68c06d8a929526e0bb6f35b8ebb090f2c” 和 A 同时缓存在本地,3、当下次再向服务器请求 A时，会通过类似 If-None-Match 或 If-Match : “aa620aa68c06d8a929526e0bb6f35b8ebb090f2c” 的请求头把 ETag 发送给服务器，4、服务器再次计算A的哈希值并和浏览器返回的值做比较，如果发现A发生了变化就把A返回给浏览器(status 200),如果发现 A 没有变化就给浏览器返回一个(status 304) 未修改。5、这样通过控制浏览器端的缓存，可以节省服务器的宽带，因为服务器不需要每次把全量数据返回给客户端 示例： Cache-Control Cache-Control: HTTP 1.1规范。用来定义缓存的过期时间。 Expires有服务器时间和浏览器时间不统一的问题，所以HTTP 1.1新定义了Cache-Control。它是一个通用HTTP头，能分别在请求报文和响应报文中使用 Cache-Control有很多值可以设置，在这里只介绍两个最常用的。 1234Cache-Control: no-cache // 浏览器不缓存, 返回的结果要看其他参数的情况Cache-Control: max-age=600 // 数字，秒，表示浏览器缓存10分钟，这段时间内即使服务器资源有修改，浏览器也不会改变。 // 这段时间内请求，http status是200 from cache 当Cache-Control和Expires同时存在时，Cache-Control会覆盖Expires。可以这么记忆，HTTP 1.1的新生代比老的HTTP 1.0总要有更多的优势。 示例： Last-Modified Last-Modified: HTTP 1.1规范。表示资源在服务器上的最后修改时间。 原理：1、浏览器在第一次请求时会保留Last-Modified的值，并在下一次请求时通过If-Modified-Since或If-Unmodified-Since两个请求头将Last-Modified传给服务器。2、服务器比对两个Last-Modified是否一致。如果两者一致，则http response返回空响应(http status:304)，否则，返回新的资源(http status:200) Last-Modified 和 Etag 都存在的情况，它们要都符合才能返回304。这也很好理解，都是HTTP1.1的小兄弟，大家权利要统一。 缺点：如果这个资源在服务器上被修改了，但是最后的内容却没有变。这时候Last-Modified就匹配不上了，相当于多返回了一个相同的资源文件，浪费了流量。 缓存判断顺序(Expires、Cache-Control、ETag、Last-Modified)上面已经说过以下三条规则： Expires 和 Cache-Control 决定了浏览器是否要发送请求到服务器，ETag 和Last-Modified 决定了服务器是要返回304+空内容还是新的资源文件 Expires 和 Cache-Control 同时存在时，Cache-Control 会覆盖Expires。如果 Cache-Control 不存在，则使用 Expires 判断 ETag 和 Last-Modified 同时存在时，两者都要满足才会返回304 Keep-Alive Keep-Alive 是一个通用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。 在Http1.0中，如果不使用Keep-Alive模式。在浏览器请求资源的时候，每请求一个资源都必须跟服务器进行一次TCP链接。酱紫的重复连接，造成资源浪费。所以在HTTP1.1中，默认使用Keep-Alive连接。 使用情况：Http 1.0中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用Keep-Alive；Http 1.1中默认启用Keep-Alive，如果加入”Connection: close “，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。 当HTTP采用keepalive模式，当客户端向服务器发生请求之后，客户端如何判断服务器的数据已经发生完成？ 使用消息首部字段 Conent-Length 使用消息首部字段 Transfer-Encoding 当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用 Transfer-Encoding：chunk 模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用”Transfer-Encoding: chunked”这样的方式来代替Content-Length。 chunk编码将数据分成一块一块的发生。Chunked 编码将使用若干个Chunk串连而成，由一个标明长度为 0 的chunk标示结束。每个 Chunk 分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF)隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。 为了兼容 HTTP/1.0 应用程序，HTTP/1.1 的请求消息体中必须包含一个合法的 Content-Length 头字段，除非知道服务器兼容HTTP/1.1。一个请求包含消息体，并且 Content-Length 字段没有给定，如果不能判断消息的长度，服务器应该用用400 (bad request) 来响应；或者服务器坚持希望收到一个合法的Content-Length字段，用 411 (length required)来响应。 所以,所有 HTTP/1.1 的接收者应用程序必须接受 “chunked” transfer-coding (传输编码) ，因此当不能事先知道消息的长度，允许使用这种机制来传输消息。消息不应该够同时包含 Content-Length 头字段和 non-identity transfer-coding。如果一个消息同时包含 non-identity transfer-coding和Content-Length ，必须忽略Content-Length 。","link":"/2019/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E7%90%86%E8%A7%A3%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98/"},{"title":"《智能时代》读后感 -- 想要生活过得好，就得引入新的信息","text":"《智能时代》一书中提到信息论的发明人香农早就指出，要想消除一个系统的不确定性，就必须使用信息。当你没有收集到足够多的信息时，不确定性就是一种客观事实，无论采用什么方法，都不可能消除。 我们正处于信息时代往智能时代过渡阶段，什么是智能时代，简单来说就是 大数据+AI+IoT = 超级智能（智能时代），而我们得以从信息时代过渡到智能时代，5G提供了基础。 我们正处于一个信息爆炸的社会不知道大家都没有一个体会，现在很多人的手机不仅在微信关注了公众号，同时还安装了今日头条、抖音、快乐、西瓜视频…等等，很多获取信息的产品。不仅如此，还有些人加入各种各样的微信、QQ群。虽然大家获取信息不仅容易，而且途径越来越多。但是，我发现其实很多是别人有意识过滤的，加入了自己主观想法的信息。从信息的角度讲，这些都是加入了噪音的信息，很容易给系统（生活）增加不确定性。 就是因为很多人吸取了很多带有噪音的信息，比如从网上看到很多文章，某某人通过直播挣钱多少钱了，某某高中毕业出来混，通过不断创业或者说一些关于读书无用论，终于在某一次成功了。其实，这些都是小编人为了吸引眼球，增加阅读量，不仅过滤有用的信息，而且还加入一些噪音。比如说，读书无用论，这个结论从何而来，很多人都觉得，读得书再多，都还如一个人出生富人家庭，然后做个富二代通过家族里面的公司历练，有一笔启动资金，无后顾之忧去创业，还有就是通过家族的人脉关系更加容易成功。 那么问题来了？假设给你一笔钱，你创立了一家公司，是通过接单子挣钱的，也有一定的人脉关系，家里也很帮忙，刚开始可能通过人脉上的便利以及资金充足的情况下，别人可能第一次碍于人情帮你的忙，给你单子，但是如果跟你合作没有利润可言，那么为什么第二次还要给你单子。假设跟你合作有利润，如果别人碰到能合作得到更多利润的人，那么你的竞争优势在哪里呢？还有一个就是，什么时候你见过各大上市的公司的CEO，不是博士的毕业，而是通过靠关系上位的？ 那么如何获得别人没有的竞争的优势呢？成为领域的专家，你就能获得别人没有的信息，然后通过这个信息，产生更大的价值。那么如何成为领域的专家，首先读好书，考个好大学，然后出来之后，也一直不断通过学习提升自己。 读书和学习，其实是一个获取信息的过程首先，在这里声明，我只是说一个现象，下面的话是没有偏见的。正因为大家在不断获取带有噪音的信息，也就是没有用的信息，对自己提升慢甚至带有副作用，你通过读书或者学习，获取有用的信息，对自己的提升才会帮助，甚至你获取有用的信息多了，你就可以成为领域的专家。 那么什么是有用的信息呢？下面，分享一下个人的经验。 1、通常可以免费和随意获取的，基本都是无用的，甚至带有噪音。比如，今日头条、抖音上获取的。 2、可以通过一些平台，付费购买一些课程，获得大神对某个领域感悟和分析。比如得到APP 3、比如我自己是做开发的，我更愿意付费向慕课网或者极客这种平台购买课程。当然了也可以白嫖，但是你付钱了，就有动力坚持学下去了。 最后，其实把生活看着一个系统，而系统肯定存在不确定性的，那么你只有引入新的有用的信息（学习），才能消除更多的不确定性。当你的系统不确定性比别人很多的时候，你不仅能成为领域的专家，同时你也能通过利用信息创造别人创造不了的价值，获得丰厚的利润。","link":"/2020/05/19/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E3%80%8A%E6%99%BA%E8%83%BD%E6%97%B6%E4%BB%A3%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%20--%20%E6%83%B3%E8%A6%81%E7%94%9F%E6%B4%BB%E8%BF%87%E5%BE%97%E5%A5%BD%EF%BC%8C%E5%B0%B1%E5%BE%97%E5%BC%95%E5%85%A5%E6%96%B0%E7%9A%84%E4%BF%A1%E6%81%AF/"},{"title":"《红楼梦》读后感 - 中国人文的基因是什么","text":"为什么要读经典 经典能流传这么久，肯定承载这个国家的人文 吴军老师关于为什么要读经典的文章借鉴 读懂经典的好处，你处于这个国家，这个社会，你只有懂了这个国家的人文价值，才能更好地融入社会，以及更懂得如何地处理人际关系 感悟读完红楼的最大感悟，虽然中国朝代更迭不断，近代甚至受到外族入侵，但是其中文化和人性是从来没断过的，所以现在的人完全继承以前的人文精神和价值，其中最典型的就是人情世故。所以，读懂红楼梦，就能读懂中国人。 红楼的里面，人情世故的体现 贾珍办事送礼 贾府遇到危机，首先是托关系 现如今 现如今依旧保存，托熟人办事的习惯 喜欢拖关系找工作","link":"/2021/01/05/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E3%80%8A%E7%BA%A2%E6%A5%BC%E6%A2%A6%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F-%E4%B8%AD%E5%9B%BD%E4%BA%BA%E6%96%87%E7%9A%84%E5%9F%BA%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88/"},{"title":"三年来从我的角度谈谈顺德饮食文化 - 论专注做到极致的重要性","text":"我在顺德工作三年的经历，从顺德人对饮食的热爱让我产生了一个思考。 话说，从2017年来到顺德工作已经三年了，但三年来我发现为什么他们一谈起吃的，吐沫横飞，面红耳赤滔滔不绝呢？相反，谈起工作的时候相对兴趣则是一般。 在一次做“趣抢券”项目的时候，先介绍这个项目主要是做什么的，简单来说用户可以购买优惠券，然后根据这个优惠券提供的商家地址到店消费。 因为我们对顺德本地饮食并不是很了解，所以CEO喊了一个妹子暂且叫她董小姐吧,去逛逛附近的广场那家店条件比较适合跟我们合作。 前几次，CEO和一个男的去逛了广场，他们的策略很简单粗暴。既然没什么思路那么就一个选辣的，另一个则选不辣，然后去屁颠屁颠去调研了。然而效果并不是理想，由于他们对美食天赋，说不出那家店好，那家店不好，所以没有选出什么值得合作的店铺 在某一天，董小姐不来上班，刚开始我以为只是单纯地请假了。直到在下午的时候，她竟然拿着一大堆传单然后跑过去找CEO，一张张递到CEO面前。“啊，这家店很不错啊，怎样怎样”“那家店也很不错啊，怎样怎样，味道如何”等等一些。 董小姐对工作和美食形成如此巨大的反差，加重了我的疑惑。不过由此可以看出，董小姐对美食是真真正正的热爱。 顺德饮食文化的由来 简单来说，顺德饮食文化来源，是古代中原人越南岭下广东，因地制宜地将中原饮食习俗与当地丰富的农渔资源相结合，这是顺德饮食文化的发源 。而顺德饮食文化能发展起来，最重要的就是饮食不但只是一种文化，更是谋生的手段，已经彻彻底底和顺德人的生活融合起来。 举个例子，我部门有一个做后端的妹子。可能是因为是做开发的原因,平时上班也不休边幅，脸色苍白，头发凌乱， 看上去整个人都是无精打采的面貌。找她讨论工作的时候，也是有气无力的样子。那时候我就在想，也许她就这样了吧！ 但在一次讨论会上，刷新了我对她的认识，同时让我明白，一个人热爱一件事情就会表现得非常主动，并且乐此不疲。 讨论附近哪里的美食比较好吃的时候。也是为了做这个“趣抢券”的项目，董小姐也是一起参加。那个场景，我至今没忘，那种感觉就好像进入了菜市场，叽叽喳喳的声音不断地在我的耳边响起。一会说这个好事，一会说那个好吃。而且非常详细描述了其中几道印象深刻菜的味道。有时候，为了寻找记忆里熟悉的味道，还会为此进行一番深度的思考（她们俩在工作的时候可不会）。 还有一次，在周末的时候，项目出了点的问题需要找后端的妹子解决解决，她说：“我在中山呢，要回去才行”，我问她去中山干嘛，就说了一句中山有好吃的呀。我的天，顺德距离她的至少六七十公里，在大周末竟然为了美食大老远跑去品尝。不过看得出来她真的是乐在其中。 在这里我不仅感慨，顺德人对美食是真的是热爱到骨子里了呀。为了美食，不仅愿意开发几十公里甚至上百公里，就是为了品尝一道美食。 反思，某些事情做到极致，一群人可以对整个城市都产生影响包括自己最后，我再重新思考的时候，我终于明白了顺德就是因为顺德人对美食的热爱形成了一种文化，把它在生活的各个方面得到体现并且乐此不疲，才能把顺德是美食城这个文化，发扬出去，由此也给顺德的饮食行业带来了蓬勃的发展。 整个广东省乃至全国，只要说起顺德，就会下意识认识顺德有好多好多好吃的，是一个美食城，如果喜欢美食的话就可以去品尝品尝。 所以，如果热爱某件事情，我们不应该停留在嘴上，需要把它体现在生活甚至工作的各个方面，这样事情做到了极致，也是可以成功的。 同时也让我明白了，一个种文化思想的重要性，它不仅影响生活，同时也影响热爱这种文化的人行为方式，并且由一代代有子孙繁衍继承下去。 分享一波最近特别喜欢吃的烧鸡","link":"/2020/03/04/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E4%B8%89%E5%B9%B4%E6%9D%A5%E4%BB%8E%E6%88%91%E7%9A%84%E8%A7%92%E5%BA%A6%E8%B0%88%E8%B0%88%E9%A1%BA%E5%BE%B7%E9%A5%AE%E9%A3%9F%E6%96%87%E5%8C%96/"},{"title":"何为长期投资?《漫步华尔街》告诉你","text":"2019年末，武汉疫情爆发扩散整个中国；而在2020年3月份开始，中国已经基本控制住疫情，但世界范围开始陆续爆发疫情，美国和欧洲同样如此。这就导致了，很多人对经济不乐观，从国内媒体和国外，每天的新闻报道，都是有关于疫情和美股在一个月内熔断四次的新闻。 以下网民调侃美股熔断的一个段子。 暂且不说，熔断这件事情，但网民无节制造负面消息，实在不是一件什么光彩的事情。在我读完《漫步华尔街》我却想谈谈，我却想谈谈为何长期投资？ 何为长期投资我发现很多人长期投资的误解,以为只是 1 ~ 2年，但事实上，实际长期投资指的是至少10~20年，甚至30年。那么问题来了，为什么长期的投资的时间需要那么长？ 首先，我们知道2000年互联网泡沫，2008年金融危机。以下面是互联网泡沫纳斯达克综合指数的走势图 接下来我们在看历史以来纳斯达克综合指数的走势图 道琼斯工业指数成立以来，以2008年金融危机为例，在 2005~2015 区间可以明显看到有一段是明显下滑趋势。 虽然从2000年开始经历了一次互联网泡沫，以及08年金融危机，但股市的整体是向上的。然而，你购买其中的一支股票，可能因为一次的黑天鹅事件导致的经济危机，而一蹶不振。 因为这支股票，在危机时没处理得当，或者危机之后资金不足被其它公司超越，还有就是可能危机之后，这个市场严重缩水而导致一蹶不振。具体例子，可以看看《漫步华尔街》，文中多次提到并且有数据图标可查看 但是，股市一直是永远向上涨，只要在购买指数基金之后，只有我们有足够的耐心，不管过程发生什么黑天鹅事件。长期持有指数基金（基本代表股市，比如沪深300，由上海以及深圳交易所按权重比例组成股票占比的基金），你的基金投资在短时间内可能有一些波动，但是随着时间推移，经济总会增长回来并且非常有可能赶超之前。 对比自己来说也是一样了解了这些之后，我对投资的策略已经很明确了。不过反过来想，我的人生不一样是如此吗？在2020年的今天，我发现我周围的人都很焦虑，做事情都很急躁。往往为了短期利益，抛弃长期受益，比如作为一名开发人员，不断学习新技术新概念，反而忽略基础的重要性（数据结构与算法、计算机基础、计算机网络）。 也正因为如此，比如我自己是做前端开发就碰到很多即将踏入中年的同行，他们由于选择了短期的做法，从而导致对自己的受益非常低，不仅感觉自己不能百尺竿头更进一步，而且多数人都觉得做前端就那样了，都在谋求转行了。 所以，只要了解人生是一个漫长的过程，在学什么的时候就不会犹豫，更不会因为短视而选择了杀鸡取卵的做法，从而导致自己在某个阶段停滞甚至倒退。 最近好想养条狗，但是又没钱，放张图片好了，“云养狗”","link":"/2020/03/24/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E4%BD%95%E4%B8%BA%E9%95%BF%E6%9C%9F%E6%8A%95%E8%B5%84-%E3%80%8A%E6%BC%AB%E6%AD%A5%E5%8D%8E%E5%B0%94%E8%A1%97%E3%80%8B%E5%91%8A%E8%AF%89%E4%BD%A0/"},{"title":"向量代数，书评网站利用户间的不相关性推荐 - 笔记","text":"各种大佬说，想要在开发走得远，必须学好数学。好比如，数学类似内功心法，编程技能是招数，你苦练招数，只是增加熟练度，到了后面想要打败更强大的敌人，单凭招数熟练度是啃不动的了，所以这个必须拥有强大的内功心法，让招数发挥更强大的威力才得以击败他。 这次，总结一下自己近段时间学习数学的知识和例子，并且为自己解惑一下，书评网站如何利用用户不相关性，推荐书给你，以达到自己内功和招数的融合。 向量向量是一个有方向和大小,且满足平行四边形法则的几何对象。比如下图 方向：箭头表示的方向，比如你汽车行驶的方向 大小：(m,n)长度，比如你汽车行驶方向时的速度 余弦距离首先得先了解一下余弦距离，从几何上看，两个向量夹角几乎为0时，非常相似； 当然夹角为0的时候，两者关系最为紧密，此时余弦值为1。而相互垂直时，余弦值为0，相关性最差，或称相互独立： 也就是说，从上面可以得出：1.两根向量夹角越小，相关性越强2.两根向量垂直，彼此之间就没有关系，相互独立3.两根向量夹角为180°的时候，则完全相反 利用余弦夹角挖掘用户相关性 – 某书评正因为余弦距离解释了事物的相关性，所以有非常多的应用。比如在数据挖掘中，很多时候通过比较用户数据的余弦距离，以判断用户的相似性。 下面是某书评网站，用户对一些书籍进行了相应的评分： 那么第一个用户信息可以用向量 u=(4,3,0,0,5,0) 来表示。 第二个的用户信息可以用向量 v=(5,0,4,0,4,0 ) 来表示。 则它们的相似性就可以用余弦距离来表示： 带入数据，结果保留到小数点后两位： 以此类推，我们就可以做出如下表格，表明各个用户的相似性： 但是这有一个问题，比如第一个用户喜好假如是： 也就是说他对所有的书评分都为1。 而第二个用户的喜好是： 也就是说他对所有的书评分都为5。 按照我们的直觉，这两个人喜好是很不相同，但是： 余弦距离居然表明两者的喜好是相同的。 我们来改进一下： 5分，表示很喜欢，实际值为2 4分，表示喜欢，实际值为1 3分，表示中性态度，实际值为0 2分，表示讨厌，实际值为-1 1分，表示很讨厌，实际值为-2 不打分，默认实际值为0 因此，第一个用户喜好的实际值为： 而第二个用户喜好的实际值为： 结果： -1表示两人的爱恨是相反的。 反过来利用不相关性-1，也就是相反的爱恨不代表不相关，我们可以这么来看，比如我们知道第一个用户和第二个用户的余弦距离为-1，那么第一个用户喜欢的就不要推荐给第二个用户，第一个用户讨厌的可以推荐给第二个用户，所以实际两人是相关的，而且还非常相关。 有句话怎么说来着： 总结有人可能会问，实际上开发中了解这个有什么用。其实如果你工作上真正遇到需要开发类似这种推荐系统的时候，如果你了解这个原理，你就有了方向。有了方向，你可以仿照上面书评的例子，根据自己的业务需求，更改其中的变量，或者增加一些其它参数变量以便更接近你需要的效果。 呐，这不是万变不离其宗的意思么？ 参考链接 马同学 向量","link":"/2020/12/24/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%EF%BC%8C%E4%B9%A6%E8%AF%84%E7%BD%91%E7%AB%99%E5%88%A9%E7%94%A8%E6%88%B7%E9%97%B4%E7%9A%84%E4%B8%8D%E7%9B%B8%E5%85%B3%E6%80%A7%E6%8E%A8%E8%8D%90%20-%20%E7%AC%94%E8%AE%B0/"},{"title":"学习《吴军的谷歌方法论》读后感","text":"一直以来对得到或者喜马拉雅这种音视频的APP都没什么好感，缘由于一开始接触了喜马拉雅听了免费的内容，里面的音频主讲的东西随心所欲，并且多数都是鸡汤，所以产生了反感的心态。不过话说回来，有价值的内容怎么会免费呢？ 后来得益于我上家的CEO，加上自己的好奇心，购买了得到的《吴伯凡的日知录》，但也并没什么感觉。听了几乎一年后，觉得里面的内容太虚，虽然我的CEO觉得这种“虚”的东西对他很受用。但，我可能作为一名理工男以及一名老实的程序员更喜欢目的性很明确，以及结合实际如何操作的方法。《吴军的谷歌方法论》就这样一个从“计算机思维、发明的逻辑、教育和学习、人生和商业的智慧”触发的课程。在这里再次表示非常感谢吴军老师的教导 计算机思维这个东西，听起来有点抽象。也许在很多人印象中，计算机不就是一个简单硬件和软件组合的一台机器么，简称电脑。一个机器还能有思维么，这就很诡异了，难道在未来机器真的会发展成超级智能，像《终结者》电影那样被一个叫做“天网”为首的人工智能统治？这当然是胡说八道。计算机思维，只是表明是一种思想，一种思考的方法。下面，介绍其中一种，计算机思维的其中之一“自顶向下“，也就是递归 基于我们通常生活的思维，我们是通常用递推的思维来去分析一个问题的。比如一辆汽车如何知道的？首先，一般人想到的是得先有一个汽车引擎，这样汽车才有动力；其次，汽车需要载人，那么需要一个车架以及各种配件组合一个能动的汽车，以及四个轮子；最后，我们的汽车要好看也需要很多功能，这时候就需要上漆，增加一个类似音乐的播放器，还要考虑到天气热的时候，需要装一个空调。这些都是基于生活的经验去层层递推想出来，自然而然的，因为我们所处的环境就是如此。 再比如，我们是如何从一个细胞变成一个人的。从小生物老师，就告诉我们。首先，你爸提供一个精子，你妈提供一个卵子，两者相结合形成受精卵；然后受精卵，从1变成2，2变成4，4变成8….一直如此下去，最后组成一个胚胎；胚胎慢慢发育一个小孩由母亲分娩。 而递归则很不一样。如果用递归思维去思考一个人如何产生的话，是这样的。表面看到这个人，有眼睛、鼻子、嘴巴、手和脚；然后大脑和五脏六腑去控制以及协作；这些器官如何产生？这是通过各种细胞组成；细胞如何产生？像上述例子一样，卵子和精子组合形成受精卵进行分裂。 启发及应用酱紫，这种逆向思维的思考方法，给我工作带了启发。如果给我负责一个项目，那么如何从零开始搭建和开发？ 前端1、拿到UI图，根据UI图去创建各个页面的目录，比如首页、详情页、我的页面等。2、编写各个页面的HTML、CSS、JS3、最后和后端进行接口对接 这个则是递推思维 后端1、根据UI图，进行整体规划，用什么数据库、用什么框架以及提供什么样的接口给前端2、进行设计数据库表以及使用对应的后端语言编写接口，大数据情况下的边界处理3、和前端进行接口对接 这个则是递归思维 有人可能会问，懂得这些思维和应用有什么用？有时候，让你去从零开始负责一件事情的时候，往往最难的不是去做这件事情，而且缺少一个对这件事情整体流程的把握和思考，有了整体思路，具体问题具体去解决就行。但是如果对整体没有流程的把握，最后发现做出来的东西根本不是你想要的。所以，了解递归和递推思维，就可以利用他们推演出整体的流程，也通过反推，双重思考也可以增加自己对这件事情的把握！","link":"/2020/02/13/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E5%AD%A6%E4%B9%A0%E3%80%8A%E5%90%B4%E5%86%9B%E7%9A%84%E8%B0%B7%E6%AD%8C%E6%96%B9%E6%B3%95%E8%AE%BA%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"title":"拥抱浪潮 -- 吴军的《浪潮之巅》读后感","text":"从书中举一个成功和一个失败的例子，给我的启发。讲明站在浪潮之巅的重要性，以及做的事情应该为下一个浪潮而准备。同时，从更长时间轴看待问题更具有全面性。 IBM - 蓝色的巨人也可以跳舞拥抱浪潮的好处非常明显，就是在每次都能在下一个浪潮的时候成功转型找到自己的位置，无论是公司还是自己。 为了更加全面看待这个问题，先了解一些背景。 首先全世界从温饱过渡到产能过剩的时代，是因为经历工业革命之后的事情。第一次工业革命是以蒸汽机为代表，第二次工业革命以电力的大规模应用为代表，电灯的发明为标志。第三次工业革命则是在第二次世界大战之后，因计算机和电子数据的普及和推广而在各行各业发生的从机械和模拟电路到数字电路的变革。 第二次世界大战可以看作是机械时代和电子时代的分水岭。英国在二战后很长时间里试图恢复它的机械工业，虽然它做到了，但是也已经落伍了。而一片焦土的日本，已经没有剩下什么工业基础，因为另起炉灶，发展电子工业，结果成为世界第二大经济体，直到近几年才被中国超越。 二战后，IBM的情况也类似，是继续发展机械时代的产品，还是拥抱电子产品，进入电子时代。这两派争执不下，而代表人物是老沃森和小沃森，老沃森是当时IBM的CEO，小沃森是他的儿子。最终，小沃森赢得了胜利。 1952年，小沃森成为IBM的新总裁。IBM从此进入电子时代，并且在小沃森领导下IBM成功进入电子时代，由于没有其它公司和IBM竞争，一直顺风顺水发展了30年。直到因为没有由于在小沃森退休之后，IBM进入信息革命的浪潮，也就是没有进入PC时代，被微软和英特尔逐步给占领了市场，这个时候已经没什么IBM的位置了，所以IBM的发展每况日下，几乎接近倒闭的阶段。 幸运地是IBM迎来了传奇它自己传奇的CEO郭士纳，在操作系统和芯片上已经没有了微软和英特尔占领了。郭士纳决定另谋出路，打造一个专门toB的IT服务航空母舰，虽然艰难重重，但最终郭士纳得以成功，IBM成为了专门成为一个针对企业级的IT服务商，同时重新焕发了活力，其实就是重新赶上了信息革命的浪潮，但不是在微软和英特尔的个人电脑，而是企业服务上。 网景 – 曾经可能超越微软的公司 和它的浏览器从上面的例子可以知道，如果想主导一个时代，首先你得必须控制住类似于操作系统和芯片这种关键的技术和市场，为什么控住这些技术和市场就可以主导一个时代呢？举一个简单的例子，大家有没有想过，为什么虽然我们从市场购买电脑都是预装windows系统的，很多人以为操作系统都是免费的，其实不是的。商家只是把需要购买操作系统的钱，转移到了你购买的电脑价格上，每个电脑几乎的CPU几乎都英特尔生产的。所以，每个人一旦购买PC机，微软和英特尔都挣一分钱。这个就是控制住操作系统和关键芯片的重要性。 网景公司曾经也有控制住“互联网操作系统”的机会，只是被微软给打败了。接下来，聊聊网景公司如何被微软给打败的。 如果提起网景公司，大家首先想到肯定是它的浏览器，在PC的互联网时代，当时网景公司的浏览器的市场份额72，微软的则是18。然而，网景公司明明有机会把握住互联网的入口，却错失机会，被微软打败。为什么说它错失机会？ 比如当初，网景牢牢把握住了当时的互联网入口，因为大家都需要通过它的浏览器去浏览网页和查询资料。如果网景公司把软件变成免费，同时意识到整合互联网内容的重要性，当时的互联网内容其实很少，雅虎的门户仅仅是靠人工编辑就可知。这样，网景公司在对抗微软竞争，实际上微软不是对抗网景了，而是整个互联网。 但网景并没有这样做，没有看到下一个浪潮是互联网，依旧专注于卖软件，被微软通过windows捆绑的逐步超越并打败，最终退出了市场。 从更长时间轴看待问题是了解它产生、发展、结束，然后吸取它的经验去看待未来从这两个件事情可以看出，站浪潮的重要性。本来我个人对职业发展很迷茫和焦虑的，因为我在做开发，总觉得开发是一门青春饭。 在我看完之后《浪潮之巅》，我对自己的职业发展有了较为清晰的认识。虽然我现在的行业（互联网）还不错，但是随着下一个”人工智能（Artificial Intelligence)、区块链（Block Chain）、云计算（Cloud）、大数据（Big Data）“时代的到来，我现在应该开始准备，而不是仅仅在互联网行业继续深造，就算你在这个行业做到顶尖，如果不及时准备为下一个浪潮转型，那么迟早会被下一个浪潮淘汰掉。IBM就是一个很好的例子。 所以为了下一个浪潮站稳脚跟，我需要学习数学、计算机基础、计算机网络、计算机操作系统、数据结构和算法等等，但是这些不都是值得的吗？","link":"/2020/04/24/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E6%8B%A5%E6%8A%B1%E6%B5%AA%E6%BD%AE%20--%20%E5%90%B4%E5%86%9B%E7%9A%84%E3%80%8A%E6%B5%AA%E6%BD%AE%E4%B9%8B%E5%B7%85%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F/"},{"title":"程序员职业规划建议","text":"搜集一些职业规划建议,方便自己参考 如何在适合的时候转型程序员的职业发展有几个选择：专注于技术，成为技术专家；转型到技术型销售、技术支持等；随着技术成长，从技术性管理到高级管理。 这归根结底，都是以技术为基础。在扎实的技术基础上（高级软件工程师），如果有着比较强的抽象设计能力，又打算专注于技术开发，架构师是个好的选 择；如果性格更适合做管理，情商能力突出，技术型管理应该是下一步的方向。这种发展规划属于‘瘸腿走路’的类型，各有侧重主攻发展的职业方向，也是目前一 般程序员普遍采用的发展路线规划。 已经工作两年以上的程序员可以有几种基本的职业规划：技术专家、软件架构师、实施顾问或销售。其中程序员最主要的发展方向是资深技术专家，无论是 Java、.NET还是数据库领域，都要首先成为专家，然后才可能继续发展为架构师。尽管架构师的职位可以工作一辈子，待遇也非常好，对于科班出身的程序 员最为适合，但这种工作职位非常有限，因为在中国目前的IT行业，架构师需要的条件比较复杂，而且需求量也比较少，这也是我国软件行业走向国际并有待成熟 的因素之一。 目前国内缺乏的是管理能力和专业知识技能并驾齐驱的IT人才。特别是懂得运用目标管理技术的项目管理人才，既掌握核心技术又有全局掌控能力的项目管 理人才，非常难找。我建议对于大多数人来说，首先是要专，只有在技术方向上做得比较深入，才能适当做工作调整，把自己转变为某个领域的专家。 根据自己的情况，决定自己做软件架构师还是高级的顾问销售，另外一部分人可能就会走向管理，这和个人性格与情商有关。软件优秀的管理者都必须懂得技术，掌握核心技能的人才向管理岗位转型有很大的优势，因而提升管理能力成了转型的关键。譬如，当唐骏还 是微软一名普通程序员时，就从公司发展的角度考虑，向老板提议开发了中文版Windows，最终使他从几万名工程师中脱颖而出，成为部门经理。正如他所 说，虽然是程序员，但自己不能只把自己当程序员，你可以为老板和公司着想。 调查研究后，带着解决方案去找老板，就会得到老板的重视和信任，所以一定要增强工作主动性和参与性。无论是软件开发还是项目管理，国内员工大多只是做好份内事或完成交派任务，很少能主动发现问题。其实，只有拥有更高眼界，才能谋取大发展。 总之，程序员要根据本身的基本素质、技术能力选择开发层次，由低到高，逐步发展。也是一名程序员本身具备相应素质的循序渐进的发展轨迹，包括很强的技术背景和综合管理才能等素养，这也就是所谓‘两条腿走路’的职业规划发展路线。","link":"/2018/04/11/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92%E5%BB%BA%E8%AE%AE/"},{"title":"论从一个电影情节解释女孩子为什么离开还要收拾行李箱","text":"从电影的情节发现，很多情侣吵架，女方都会进入一个收拾的画面。从小时候开始就一直喜欢看电影，虽然大多数看的都是科技电影。但是，偶尔也会放空一下看看爱情类的片子。每次看到这些片子，我都发现有一个很“诡异”的情节，女主往往会因为某些事情跟男主吵架或者生气什么的，女主会生气回到家里（这时他们已经同居了）疯狂地收拾行李，男主总会劝，劝着劝着两方又吵起来最终闹得不欢而散。 先看一个视频 为什么要设计这样的一个情节那时候心里总有一个疑问？为什么要设计这样的一个情节，**吵架-&gt; 收拾行李 -&gt; 尝试劝留 -&gt;劝不住 -&gt; 闹得不欢而散** 电影情节需要从电影的角度来分析，对于爱情电影来说往往这种情节都是需要的。比如爱情电影，具有这几种套路 开头男主和女主吵架，女主离开，然后就男主和女主如何虐心情节，最终的结局复合或者分手 男主和女主经过电影一般的时间，经历各种“磨难”，终于在一起，然后因为某些事情吵架，又经历各种磨难加深感情，复合。 电影开始男主疯狂追求女主，经历各种“磨难”，开始了甜甜的爱情虐狗情节，然而峰回路转，结局却是男主和女主惨淡分手，女主迫于现实嫁给了一只“猪”…… 可以用来继续“吵架”，起到承上启下的作用以第二种套路为例，“吵架”起到承上启下的作用。承上就是，预示上半场的情节发展到这个时候有转折点了，启下就是延续上半场的发展的需要 承上情侣之间的种种矛盾，导致这样的一个结果,生活上的矛盾, 比如刚开始同居时，生活习惯的矛盾，比如女孩比较爱情，男孩子比较邋遢,从热恋过渡到平静生活的矛盾，比如男方不再热情，不再花那么心思在女孩子身上；外来的矛盾，比如男主的前女友死灰复燃或者是女主的，稍微处理不当就会来一波吵架。 各种对细节上的描述都预示着他们终有一波吵架，为后面的情节进行铺垫。 启下对应现实审过可以告诉男生，如果现实生活碰到这样的情况，其实女孩子心里面都是非常你能动情地挽留，你只要死皮赖脸跪地求饶往往是可以得到原谅和理解的。但是，这个时候的情节往往发展的，男猪脚动情地挽留最终女孩子留下。或者男猪脚被女猪脚旧事重提，比如前女友，以前一些小事啊。（女孩子很记仇，手动狗头）。男猪脚顿时暴跳如雷，失去理智跟女猪脚吵起来，女猪脚拖着行李夺门而出 假设男猪脚没有挽留成功，女猪脚夺门而出。 那么接下来的情节。就是有一个“和事老”，凑合偶遇，找借口拉来一起吃饭等 又吵起来…，和事佬计划失败 和事佬出了很多招都没有,计划通通失败 突然女猪脚飞来横祸，男猪脚英勇抵挡为女主受伤，男猪脚昏迷，女猪脚伤心欲绝，接下来的剧情… 我想大家都猜得到了，毕竟这是一部爱情喜剧片，为什么爱情多数是喜剧片呢？因为爱情悲剧片没人看，手动狗头 返回到现实，电影情节虽然虚构，但是里面的“对付”女生却是很管用比如只要在女猪脚收拾行李，晓之以情，动之以理，甚至不要脸。多数都可以挽留的，电影有时候为了剧情需要才有时候挽留不成功而已。 我的感悟这些电影给了我一个启发，就是如果一个“不要脸”去争取，才能得到你珍惜的东西。比如，对待父母，想美国那样毫不掩饰地说“I love u”，中国可能比较内敛，但是表达爱的方式很多，周末回家，节日回家，放假少出去玩，在家陪他们聊聊天，总之只要在家都比你经常出去乱跑强。 愿自己早日脱离单身狗的标签，蜜汁！","link":"/2020/02/18/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E8%AE%BA%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%94%B5%E5%BD%B1%E6%83%85%E8%8A%82%E8%A7%A3%E9%87%8A%E5%A5%B3%E5%AD%A9%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%BB%E5%BC%80%E8%BF%98%E8%A6%81%E6%94%B6%E6%8B%BE%E8%A1%8C%E6%9D%8E%E7%AE%B1/"},{"title":"读吴晓波《激荡三十年》的读后感 - 从身边的人看格局","text":"事实上很早以前就知道这本书了，2017年的某一天，我的一个同学去找了我，他每周都会看一次吴晓波的节目。他写了这本书，起初很不以为然。感觉根本没有什么卵用，直到学到《谷歌吴军方法论》才明白，那些在我看来毫无用处的东西，其实扩展了我的视野，了解它们可以让我从更长的时间轴和更大的空间轴看未来发展，同时也可以为我自己做事情提供一个新的角度，更全面。 从文化大革命后的1978年改革开放到2008年中国经济发展的历史可以为我解答，比如，为什么很多人说改革开放是出来创业的最佳时期？既然这样，我们爸妈为什么还不确定呢？有些人说他们那时年轻，那么，问题来了，你爷爷奶奶和其他许多亲戚，为什么把握了这么好的时机？ 改革开放初期大致 1978 ~ 1987间 “傻子”成功到被捕到失败经过文革后，中国经济急需复苏。但是，文革时期留下的恐惧仍然笼罩着普通民众，那时的中国，不像现在的中国，通过网络就可以获得各种各样的信息。每个人都是通过对自己身边发生的事情，然后才判断政府的政策倾向，否则做生意就会被抓。只有鬼才愿意冒这样的险。这时，聪明并且还能活下去的人，暂时不愿冒着这个险做生意，反而让一个只会写自己名字、没有文化的人成功了。 这位年广九，因邓小平两次高谈阔论此人而闻名于世，号称“中国第一商贩”，这里的第一个意思是第一个做生意的意思，也就是第一个首富的意思。那是一件相当讽刺的事，在中国第一个做生意的人，既不是受过良好教育的人，也不是有商业头脑的人；而是一个没有受过良好文化教育的人，甚至有点粗俗。成功也很简单，迫于生计的压力，他又找不到工作，那时好工作都在国企的，号称铁饭碗。于是，他甘愿冒被抓的风险，开了一家名叫“傻瓜子”的瓜子店。因为没人可以竞争，加上比其他小道商人更好的品质，所以一举成功并迅速成名。 正好碰上邓爷爷(邓小平)要大力发展经济，正好碰上了年广九的生意做起来，所以中央决定抓紧一个典型，大力宣传年广九。「傻子瓜子」的生意好得一团糟。有时真的是在感叹命运的不可捉摸。所以问题来了，年广九暂且叫“傻子”，就这么好记。究竟他赚了多少钱呢？ 在中国改革开放前，大多数人并不富裕，万元户是富人，而1976年，年广九年的个人现金财富已经上百万了，这在当时人们的观念中是一个天文数字。年广九觉得钱太多了，不敢存银行，放家里也不安全，于是用牛皮把自己包好，乘天黑偷了埋在院内。考虑到1976年唐山大地震造成的破坏，他担心如果芜湖地震将房屋倒塌，人们就会把钱挖出来，然后自己再把钱挖出来，发现钞票发霉了。为了避免损失，年广九的钱都用来铺满院子，晒在阳光下，还打趣说，别家晒粮食，我家晒了钱。 好景不长，1986年春节前，傻子瓜子公司在全国率先搞到有奖销售，并以一辆上海牌轿车作为头等大奖，3个月实现盈利100万元，但好景不长，中央下文停止了一切有奖销售活动，让年广九的销售计划失败，公司血本无归。 最后，“傻子”因为不懂管理，所以财务管理非常的乱用，什么程度的混乱呢？被逮捕受审时，他自己就说：“我只知道进帐的钱是多少，不知道要出帐多少，如何办到。” 尽管最后“傻子”，因为邓爷爷放了出去，但生意从此陷入萧条。 万科老总这本书《激荡三十年》，万科老总的王石，刚开始创业的时候。也和大家一样，以为自己什么都可以做，以至于公司的业务复杂到让人无法想象，因为公司没有一个人可以理清楚。于是在向证券商解释时，其中一人就问他：”王总，实在不能不问一下，贵公司究竟在经营什么？” 而且这一问题引起万科老总的深思，最后他下决心说，万科以后只做房地产生意，把其他的一切都抛弃了。如今证明，万科老总的决定是非常英明的，因为当时如日中天的公司很多，现已不复存在，万科仍在继续发展壮大。 对比我现实生活中的具有代表性的例子以上两件事我总结对比了一下，“傻子”和万科老总，其实在做生意的道路上都是有困难的，虽然他们的难处略有不同。但不是每个人都具备克服困难的策略和应对困难的能力，这样才能取得商业上的成功。 我们还可以从两个人的对比中看出，两个人的格局差异并不普遍。假如当初万科老总不是格局比较大，就不会做出转型万科的决策。 武汉疫情爆发，过年时我身边的人反应，让我重新审视了格局的重要性尽管政府一再强调，他们不信也不造谣。但表面上的效果对我身边的人并不太理想。如今抖音短视频和自媒体(公众号)发展成熟，大家可以很容易地获得信息。 但是，首先我们必须知道，在获取信息时，无论是短片还是自带媒体，以及传统新闻媒体，都要有一个前提。这种信息都是由人过滤产生的，既然是由人过滤产生的，那么加入主观意识就容易了，很多小编甚至断章取义来吸引眼球。 但在我的家乡，却发生了一件让人哭笑不得的事。为什么每个人都去抢米，原因很简单就是有人在朋友的圈子里发了一条短信，说由于湖北暴发的疫情很少，所以可能会出现粮食短缺。 其实，就在他们抢完米之后，米铺老板第二天又重新来了一批，店里堆满了米。 光阴似箭，已接近恢复工作的时期。我的一位朋友，依然笼罩在暴发的恐惧之中，不敢出门，不敢外出，也不敢复工。简单来说，就是：“狗命紧”。 但是，藏匿在家中并不能解决问题，不恢复工作只会阻碍社会的运转，只有社会的正常运作继续创造价值，才能继续提供对武汉疫情的支持。由于许多物资都需要人手正常运行，物流也需要人手操作等。 他说我在做互联网，远程办公也没有问题。但他忘了，只要他去超市买早餐，他就会产生消费欲望，比如去超市买东西。商户可以生存下去，整个社会就会正常运转，你也可以继续享受商户提供给你的服务。 尽管如此，他还是很坚决地驳斥了我的意见。那时我就在想，如果国家有困难需要他站出来的话，应该说是小一点的，或者是在企业陷入困境的时候，他只会躲在后面坐等公司倒闭。 于是躲在家里，封村不能解决问题。如前线的人那样在战斗，或如外卖的小哥小哥快递的小哥为大家送东西，大家一起维持正常的社会运转才能渡过难关 网络员工也是这样，有人可能会说是远程办公呀。撇开效率问题不说，只要确定来公司上班，这个人一定会消费的，比如买早餐、搭公交车、去超市购物等等，只有大家都买东西，企业才能赚钱，企业挣钱才能交税，这样才能成为一个良性循环若防御力过强，到时候大批企业倒闭，最终物价上涨，失业人数增加。其结果是普通民众买单 就像我刚毕业的同学，今年找工作只会是件难事 因此，只要愿意采取行动，创造属于自己的价值，不仅对社会有益，而且对自己的价值也有促进作用。这种人，也许会有人失败，但成功的机率肯定比那些待在人大党空中阁楼里的人要大得多！ 我自己的感慨年少无知，认为读书无用论，直到碰到吴军老师才幡然醒悟，并不是以前的世界有多好，而是自己格局有问题，并且太懒惰。格局看问题的角度就不一样，看问题的角度不一样就会有不一样的行动。","link":"/2020/02/14/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E8%AF%BB%E5%90%B4%E6%99%93%E6%B3%A2%E3%80%8A%E6%BF%80%E8%8D%A1%E4%B8%89%E5%8D%81%E5%B9%B4%E3%80%8B%E7%9A%84%E8%AF%BB%E5%90%8E%E6%84%9F%20-%20%E4%BB%8E%E8%BA%AB%E8%BE%B9%E7%9A%84%E4%BA%BA%E7%9C%8B%E6%A0%BC%E5%B1%80/"},{"title":"请珍惜自己的身体-《手术两百年》记录片观后感","text":"看完《手术两百年》的记录后，感叹外科发展如今这个地步，不仅感叹的发展迅速，同时也为自己感到幸运。因为在外科还没有发展如今这么完善的时候，手术都是在“三无”的状态下进行的，而且简单粗暴，那场面甚至有点血腥。 外科发展简史好了，为了梳理出清晰的脉络，我们把目光放在外科，从它的六个阶段，来看看外科乃至整个医学如何逐步摆脱宗教的影响： 原始社会时代：巫术和宗教统治着医学，所谓外科医学不过是「驱魔仪式」的一部分。 古希腊宗教宽容，哲学兴起，这促使医学摆脱宗教，但是推动了外科与内科分离。 古罗马和中世纪，基督教思想统治欧洲，外科停滞不前。 文艺复兴时期，维萨里开创解剖学、帕雷则让外科成为一门职业。 18 世纪，以英国约翰亨特为代表的外科医生，将外科提升为自成体系的医学学科。 19 世纪 40 年代，麻醉术和无菌术，推动外科手术走向成熟。此后，器官修复和移植技术的出现，更是让外科医学打开了新领域。 有兴趣的可以点击这里查看六个阶段的介绍世界外科简史,这里就不一一介绍了。 这里我介绍我看的《手术两百年》介绍一下，在古罗马和中世纪的外科医生，是我们经常看到但又万万想不到的理发师。因为当时人们觉得，理发师也是用刀子的职业嘛，而且也经常见血，所以兼职当个外科大夫也很自然。 但是你能像得到，在一个“三无”的情况做手术的场景嘛，“三无”，就是无麻醉，没有无菌的环境，无止血（有效地止血方法）。特别是没有麻醉，要进行手术的人在当时基本都算是半只脚踏入鬼门关的人了，并且在手术的时候会伴随着鬼哭狼嚎的惨叫声，场面一度血腥。用文字描述没什么感染力，直接看下面的一张图，隔着屏幕，都能感受到有多痛。 得来不易外科经过这么长的时间发展到今天，上面看到让人感到非常痛并且有点恐怖的手术，现在如今不存在了，进行这些手术可以进行麻醉，在手术时可以完全感觉不到痛，而且风险相比较之前来说已经非常低了。 在写到这里的时候，我感到如此的幸运啊，在生病甚至需要手术的时候，在以前需要鼓起勇气才能做的手术，现如今能以非常低的风险并且伴随“无痛”（手术ing）。 但，我发现身边的人不仅经常熬夜，而且无节制的抽烟和酗酒。这实在不是一种明智的行为。虽然年轻的时候，身体强壮，发病的机率很小，可是透支了身体的健康，老了还能这么有底气么？ 在这里不仅希望，我的朋友们，能够爱护的自己身体，同时希望我的父亲，少抽烟少喝酒。他可能看不到这篇文章，但我会心里一直向上帝祈祷我的父亲能够无病无痛。 参考链接 手术两百年 世界外科简史（上篇） 世界外科简史（下篇） 隔着屏幕，都能感受到维多利亚时期做手术的病人们有多痛","link":"/2020/04/10/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/%E8%AF%B7%E7%8F%8D%E6%83%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BA%AB%E4%BD%93-%E3%80%8A%E6%89%8B%E6%9C%AF%E4%B8%A4%E7%99%BE%E5%B9%B4%E3%80%8B%E8%AE%B0%E5%BD%95%E7%89%87%E8%A7%82%E5%90%8E%E6%84%9F/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Example","slug":"Example","link":"/tags/Example/"},{"name":"GO","slug":"GO","link":"/tags/GO/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"布局","slug":"布局","link":"/tags/%E5%B8%83%E5%B1%80/"},{"name":"网络安全","slug":"网络安全","link":"/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"随心所欲","slug":"随心所欲","link":"/tags/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"categories":[{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Example","slug":"Example","link":"/categories/Example/"},{"name":"GO","slug":"GO","link":"/categories/GO/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"JAVASCRIPT","slug":"JAVASCRIPT","link":"/categories/JAVASCRIPT/"},{"name":"小程序","slug":"小程序","link":"/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"REACT","slug":"REACT","link":"/categories/REACT/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"数据结构和算法","slug":"数据结构和算法","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"计算机","slug":"计算机","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"随心所欲","slug":"随心所欲","link":"/categories/%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2/"}]}